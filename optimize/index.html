<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>前端性能优化 | 高级前端进阶</title><meta name="keywords" content="前端进阶，前端面试,前端八股文,前端经典面试题"><meta name="author" content="souldjl"><meta name="copyright" content="souldjl"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. 减少 HTTP 请求 一个完整的 HTTP 请求需要经历 DNS 查找，TCP 握手，浏览器发出 HTTP 请求，服务器接收请求，服务器处理请求并发回响应，浏览器接收响应等过程。文件越小，这个比例越小，文件越大，比例就越高。这就是为什么要建议将多个小文件合并为一个大文件，从而减少 HTTP 请求次数的原因。   参考资料： understanding-resource-timing  2."><meta property="og:type" content="website"><meta property="og:title" content="前端性能优化"><meta property="og:url" content="https://www.daijl.cn/optimize/index.html"><meta property="og:site_name" content="高级前端进阶"><meta property="og:description" content="1. 减少 HTTP 请求 一个完整的 HTTP 请求需要经历 DNS 查找，TCP 握手，浏览器发出 HTTP 请求，服务器接收请求，服务器处理请求并发回响应，浏览器接收响应等过程。文件越小，这个比例越小，文件越大，比例就越高。这就是为什么要建议将多个小文件合并为一个大文件，从而减少 HTTP 请求次数的原因。   参考资料： understanding-resource-timing  2."><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.daijl.cn/img/cover/cover_10.jpg"><meta property="article:published_time" content="2022-02-08T07:14:45.000Z"><meta property="article:modified_time" content="2022-02-08T07:36:53.036Z"><meta property="article:author" content="souldjl"><meta property="article:tag" content="前端进阶，前端面试,前端八股文,前端经典面试题"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.daijl.cn/img/cover/cover_10.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://www.daijl.cn/optimize/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="T8zNWQNhDDztzYe6Y7pYKuJIY8LO45bxxN1iGheQnI"><meta name="baidu_site_verification" content="code-UTlFxDZspp"><meta name="sogou_site_verification" content="pSw0CiDaj7"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?f30a76e6d5701be25349f80c829c0a52";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:50,languages:{author:"作者: souldjl",link:"链接: ",source:"来源: 高级前端进阶",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"null",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"前端性能优化",isPost:!1,isHome:!1,isHighlightShrink:!1,isToc:!1,postUpdate:"2022-02-08 15:36:53"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0!==o){const a=new Date;o=864e5*o,o={value:t,expiry:a.getTime()+o};localStorage.setItem(e,JSON.stringify(o))}},get:function(e){var t=localStorage.getItem(e);if(t){t=JSON.parse(t);const o=new Date;if(!(o.getTime()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=a=>new Promise((t,e)=>{const o=document.createElement("script");o.src=a,o.async=!0,o.onerror=e,o.onload=o.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(o.onload=o.onreadystatechange=null,t())},document.head.appendChild(o)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};e=saveToLocal.get("theme");"dark"===e?activateDarkMode():"light"===e&&activateLightMode();e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/Swiper/7.4.1/swiper-bundle.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">52</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/recommend-books/"><i class="fa-fw fas fa-link"></i><span> 好书推荐</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-tools"></i><span> 实用工具</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://nav.daijl.cn/"><span>编程导航</span></a></li></ul></div></div></div></div><div class="page" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">高级前端进阶</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/recommend-books/"><i class="fa-fw fas fa-link"></i><span> 好书推荐</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-tools"></i><span> 实用工具</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://nav.daijl.cn/"><span>编程导航</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout hide-aside" id="content-inner"><div id="page"><h1 class="page-title">前端性能优化</h1><div id="article-container"><h3 id="1-减少-HTTP-请求"><a href="#1-减少-HTTP-请求" class="headerlink" title="1. 减少 HTTP 请求"></a>1. 减少 HTTP 请求</h3><blockquote><p>一个完整的 HTTP 请求需要经历 DNS 查找，TCP 握手，浏览器发出 HTTP 请求，服务器接收请求，服务器处理请求并发回响应，浏览器接收响应等过程。文件越小，这个比例越小，文件越大，比例就越高。这就是为什么要建议将多个小文件合并为一个大文件，从而减少 HTTP 请求次数的原因。</p></blockquote><blockquote><p>参考资料： understanding-resource-timing</p></blockquote><h3 id="2-使用-HTTP2"><a href="#2-使用-HTTP2" class="headerlink" title="2. 使用 HTTP2"></a>2. 使用 HTTP2</h3><blockquote><p>HTTP2 相比 HTTP1.1 有如下几个优点：</p></blockquote><h4 id="解析速度快"><a href="#解析速度快" class="headerlink" title="解析速度快"></a>解析速度快</h4><blockquote><p>服务器解析 HTTP1.1 的请求时，必须不断地读入字节，直到遇到分隔符 CRLF 为止。而解析 HTTP2 的请求就不用这么麻烦，因为 HTTP2 是基于帧的协议，每个帧都有表示帧长度的字段。</p></blockquote><h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4><blockquote><p>HTTP1.1 如果要同时发起多个请求，就得建立多个 TCP 连接，因为一个 TCP 连接同时只能处理一个 HTTP1.1 的请求。</p></blockquote><blockquote><p>在 HTTP2 上，多个请求可以共用一个 TCP 连接，这称为多路复用。同一个请求和响应用一个流来表示，并有唯一的流 ID 来标识。<br>多个请求和响应在 TCP 连接中可以乱序发送，到达目的地后再通过流 ID 重新组建。</p></blockquote><h4 id="首部压缩"><a href="#首部压缩" class="headerlink" title="首部压缩"></a>首部压缩</h4><blockquote><p>HTTP2 提供了首部压缩功能。</p></blockquote><blockquote><p>例如有如下两个请求：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:authority: unpkg.zhimg.com</span><br><span class="line">:method: GET</span><br><span class="line">:path: /za-js-sdk@0/dist/zap.js</span><br><span class="line">:scheme: https</span><br><span class="line">accept: */*</span><br><span class="line">accept-encoding: gzip, deflate, br</span><br><span class="line">accept-language: zh-CN,zh;q=9</span><br><span class="line">cache-control: no-cache</span><br><span class="line">pragma: no-cache</span><br><span class="line">referer: https://www.zhihu.com/</span><br><span class="line">sec-fetch-dest: script</span><br><span class="line">sec-fetch-mode: no-cors</span><br><span class="line">sec-fetch-site: cross-site</span><br><span class="line">user-agent: Mozilla/0 (Windows NT 1; Win64; x64) AppleWebKit/536 (KHTML, like Gecko) Chrome/39122 Safari/536</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:authority: zz.bdstatic.com</span><br><span class="line">:method: GET</span><br><span class="line">:path: /linksubmit/push.js</span><br><span class="line">:scheme: https</span><br><span class="line">accept: */*</span><br><span class="line">accept-encoding: gzip, deflate, br</span><br><span class="line">accept-language: zh-CN,zh;q=9</span><br><span class="line">cache-control: no-cache</span><br><span class="line">pragma: no-cache</span><br><span class="line">referer: https://www.zhihu.com/</span><br><span class="line">sec-fetch-dest: script</span><br><span class="line">sec-fetch-mode: no-cors</span><br><span class="line">sec-fetch-site: cross-site</span><br><span class="line">user-agent: Mozilla/0 (Windows NT 1; Win64; x64) AppleWebKit/536 (KHTML, like Gecko) Chrome/39122 Safari/536</span><br></pre></td></tr></table></figure><blockquote><p>从上面两个请求可以看出来，有很多数据都是重复的。如果可以把相同的首部存储起来，仅发送它们之间不同的部分，就可以节省不少的流量，加快请求的时间。</p></blockquote><blockquote><p>HTTP/2 在客户端和服务器端使用首部表来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送。</p></blockquote><blockquote><p>下面再来看一个简化的例子，假设客户端按顺序发送如下请求首部：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Header1:foo</span><br><span class="line">Header2:bar</span><br><span class="line">Header3:bat</span><br></pre></td></tr></table></figure><blockquote><p>当客户端发送请求时，它会根据首部值创建一张表：</p></blockquote><table><thead><tr><th>索引</th><th>首部名称</th><th>值</th></tr></thead><tbody><tr><td>62</td><td>Header1</td><td>foo</td></tr><tr><td>63</td><td>Header2</td><td>bar</td></tr><tr><td>64</td><td>Header3</td><td>bat</td></tr></tbody></table><blockquote><p>如果服务器收到了请求，它会照样创建一张表。<br>当客户端发送下一个请求的时候，如果首部相同，它可以直接发送这样的首部块：</p></blockquote><p><code>62 63 64</code></p><blockquote><p>服务器会查找先前建立的表格，并把这些数字还原成索引对应的完整首部。</p></blockquote><h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><blockquote><p>HTTP2 可以对比较紧急的请求设置一个较高的优先级，服务器在收到这样的请求后，可以优先处理。</p></blockquote><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><blockquote><p>由于一个 TCP 连接流量带宽（根据客户端到服务器的网络带宽而定）是固定的，当有多个请求并发时，一个请求占的流量多，另一个请求占的流量就会少。流量控制可以对不同的流的流量进行精确控制。</p></blockquote><h4 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h4><blockquote><p>HTTP2 新增的一个强大的新功能，就是服务器可以对一个客户端请求发送多个响应。换句话说，除了对最初请求的响应外，服务器还可以额外向客户端推送资源，而无需客户端明确地请求。</p></blockquote><blockquote><p>例如当浏览器请求一个网站时，除了返回 HTML 页面外，服务器还可以根据 HTML 页面中的资源的 URL，来提前推送资源。</p></blockquote><h3 id="3-使用服务端渲染"><a href="#3-使用服务端渲染" class="headerlink" title="3. 使用服务端渲染"></a>3. 使用服务端渲染</h3><blockquote><p>客户端渲染: 获取 HTML 文件，根据需要下载 JavaScript 文件，运行文件，生成 DOM，再渲染。</p></blockquote><blockquote><p>服务端渲染：服务端返回 HTML 文件，客户端只需解析 HTML。</p></blockquote><ul><li>优点：首屏渲染快，SEO 好。</li><li>缺点：配置麻烦，增加了服务器的计算压力。</li></ul><blockquote><p>下面我用 Vue SSR 做示例，简单的描述一下 SSR 过程。</p></blockquote><h4 id="客户端渲染过程"><a href="#客户端渲染过程" class="headerlink" title="客户端渲染过程"></a>客户端渲染过程</h4><ol><li>访问客户端渲染的网站。</li><li>服务器返回一个包含了引入资源语句和 <code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code> 的 HTML 文件。</li><li>客户端通过 HTTP 向服务器请求资源，当必要的资源都加载完毕后，执行 <code>new Vue()</code> 开始实例化并渲染页面。</li></ol><h4 id="服务端渲染过程"><a href="#服务端渲染过程" class="headerlink" title="服务端渲染过程"></a>服务端渲染过程</h4><ol><li>访问服务端渲染的网站。</li><li>服务器会查看当前路由组件需要哪些资源文件，然后将这些文件的内容填充到 HTML 文件。如果有 ajax 请求，就会执行它进行数据预取并填充到 HTML 文件里，最后返回这个 HTML 页面。</li><li>当客户端接收到这个 HTML 页面时，可以马上就开始渲染页面。与此同时，页面也会加载资源，当必要的资源都加载完毕后，开始执行 <code>new Vue()</code> 开始实例化并接管页面。</li></ol><blockquote><p>从上述两个过程中可以看出，区别就在于第二步。客户端渲染的网站会直接返回 HTML 文件，而服务端渲染的网站则会渲染完页面再返回这个 HTML 文件。</p></blockquote><blockquote><p><code>这样做的好处是什么？是更快的内容到达时间 (time-to-content)</code>。</p></blockquote><blockquote><p>假设你的网站需要加载完 abcd 四个文件才能渲染完毕。并且每个文件大小为 1 M。</p></blockquote><blockquote><p>这样一算：客户端渲染的网站需要加载 4 个文件和 HTML 文件才能完成首页渲染，总计大小为 4M（忽略 HTML 文件大小）。而服务端渲染的网站只需要加载一个渲染完毕的 HTML 文件就能完成首页渲染，总计大小为已经渲染完毕的 HTML 文件（这种文件不会太大，一般为几百K，我的个人博客网站（SSR）加载的 HTML 文件为 400K）。<code>这就是服务端渲染更快的原因</code>。</p></blockquote><blockquote><p>参考资料：</p></blockquote><ul><li>vue-ssr-demo</li><li>Vue.js 服务器端渲染指南</li></ul><h3 id="4-静态资源使用-CDN"><a href="#4-静态资源使用-CDN" class="headerlink" title="4. 静态资源使用 CDN"></a>4. 静态资源使用 CDN</h3><blockquote><p>内容分发网络（CDN）是一组分布在多个不同地理位置的 Web 服务器。我们都知道，当服务器离用户越远时，延迟越高。CDN 就是为了解决这一问题，在多个位置部署服务器，让用户离服务器更近，从而缩短请求时间。</p></blockquote><h4 id="CDN-原理"><a href="#CDN-原理" class="headerlink" title="CDN 原理"></a>CDN 原理</h4><blockquote><p>当用户访问一个网站时，如果没有 CDN，过程是这样的：</p></blockquote><ol><li>浏览器要将域名解析为 IP 地址，所以需要向本地 DNS 发出请求。</li><li>本地 DNS 依次向根服务器、顶级域名服务器、权限服务器发出请求，得到网站服务器的 IP 地址。</li><li>本地 DNS 将 IP 地址发回给浏览器，浏览器向网站服务器 IP 地址发出请求并得到资源。</li></ol><blockquote><p>如果用户访问的网站部署了 CDN，过程是这样的：</p></blockquote><ol><li>浏览器要将域名解析为 IP 地址，所以需要向本地 DNS 发出请求。</li><li>本地 DNS 依次向根服务器、顶级域名服务器、权限服务器发出请求，得到全局负载均衡系统（GSLB）的 IP 地址。</li><li>本地 DNS 再向 GSLB 发出请求，GSLB 的主要功能是根据本地 DNS 的 IP 地址判断用户的位置，筛选出距离用户较近的本地负载均衡系统（SLB），并将该 SLB 的 IP 地址作为结果返回给本地 DNS。</li><li>本地 DNS 将 SLB 的 IP 地址发回给浏览器，浏览器向 SLB 发出请求。</li><li>SLB 根据浏览器请求的资源和地址，选出最优的缓存服务器发回给浏览器。</li><li>浏览器再根据 SLB 发回的地址重定向到缓存服务器。</li><li>如果缓存服务器有浏览器需要的资源，就将资源发回给浏览器。如果没有，就向源服务器请求资源，再发给浏览器并缓存在本地。</li></ol><blockquote><p>参考资料：</p></blockquote><ul><li>CDN是什么？使用CDN有什么优势？</li><li>CDN原理简析</li></ul><h3 id="5-将-CSS-放在文件头部，JavaScript-文件放在底部"><a href="#5-将-CSS-放在文件头部，JavaScript-文件放在底部" class="headerlink" title="5. 将 CSS 放在文件头部，JavaScript 文件放在底部"></a>5. 将 CSS 放在文件头部，JavaScript 文件放在底部</h3><ul><li>CSS 执行会阻塞渲染，阻止 JS 执行</li><li>JS 加载和执行会阻塞 HTML 解析，阻止 CSSOM 构建</li></ul><blockquote><p>如果这些 CSS、JS 标签放在 HEAD 标签里，并且需要加载和解析很久的话，那么页面就空白了。所以 JS 文件要放在底部（不阻止 DOM 解析，但会阻塞渲染），等 HTML 解析完了再加载 JS 文件，尽早向用户呈现页面的内容。</p></blockquote><blockquote><p>那为什么 CSS 文件还要放在头部呢？</p></blockquote><blockquote><p>因为先加载 HTML 再加载 CSS，会让用户第一时间看到的页面是没有样式的、丑陋的，为了避免这种情况发生，就要将 CSS 文件放在头部了。</p></blockquote><blockquote><p>另外，JS 文件也不是不可以放在头部，只要给 script 标签加上 defer 属性就可以了，异步下载，延迟执行。</p></blockquote><blockquote><p>参考资料：</p></blockquote><ul><li>使用 JavaScript 添加交互</li></ul><h3 id="6-使用字体图标-iconfont-代替图片图标"><a href="#6-使用字体图标-iconfont-代替图片图标" class="headerlink" title="6. 使用字体图标 iconfont 代替图片图标"></a>6. 使用字体图标 iconfont 代替图片图标</h3><blockquote><p>字体图标就是将图标制作成一个字体，使用时就跟字体一样，可以设置属性，例如 font-size、color 等等，非常方便。并且字体图标是矢量图，不会失真。还有一个优点是生成的文件特别小。</p></blockquote><h4 id="压缩字体文件"><a href="#压缩字体文件" class="headerlink" title="压缩字体文件"></a>压缩字体文件</h4><blockquote><p>使用 fontmin-webpack 插件对字体文件进行压缩。</p></blockquote><blockquote><p>参考资料：</p></blockquote><ul><li>fontmin-webpack</li><li>Iconfont-阿里巴巴矢量图标库</li></ul><h3 id="7-善用缓存，不重复加载相同的资源"><a href="#7-善用缓存，不重复加载相同的资源" class="headerlink" title="7. 善用缓存，不重复加载相同的资源"></a>7. 善用缓存，不重复加载相同的资源</h3><blockquote><p>为了避免用户每次访问网站都得请求文件，我们可以通过添加 Expires 或 max-age 来控制这一行为。Expires 设置了一个时间，只要在这个时间之前，浏览器都不会请求文件，而是直接使用缓存。而 max-age 是一个相对时间，建议使用 max-age 代替 Expires 。</p></blockquote><blockquote><p>不过这样会产生一个问题，当文件更新了怎么办？怎么通知浏览器重新请求文件？</p></blockquote><blockquote><p>可以通过更新页面中引用的资源链接地址，让浏览器主动放弃缓存，加载新资源。</p></blockquote><blockquote><p>具体做法是把资源地址 URL 的修改与文件内容关联起来，也就是说，只有文件内容变化，才会导致相应 URL 的变更，从而实现文件级别的精确缓存控制。什么东西与文件内容相关呢？我们会很自然的联想到利用数据摘要要算法对文件求摘要信息，摘要信息与文件内容一一对应，就有了一种可以精确到单个文件粒度的缓存控制依据了。</p></blockquote><blockquote><p>参考资料：</p></blockquote><ul><li>webpack + express 实现文件精确缓存</li><li>webpack-缓存</li><li>张云龙–大公司里怎样开发和部署前端代码？</li></ul><h3 id="8-压缩文件"><a href="#8-压缩文件" class="headerlink" title="8. 压缩文件"></a>8. 压缩文件</h3><blockquote><p>压缩文件可以减少文件下载时间，让用户体验性更好。</p></blockquote><blockquote><p>得益于 webpack 和 node 的发展，现在压缩文件已经非常方便了。</p></blockquote><blockquote><p>在 webpack 可以使用如下插件进行压缩：</p></blockquote><ul><li>JavaScript：UglifyPlugin</li><li>CSS ：MiniCssExtractPlugin</li><li>HTML：HtmlWebpackPlugin</li></ul><blockquote><p>其实，我们还可以做得更好。那就是使用 gzip 压缩。可以通过向 HTTP 请求头中的 Accept-Encoding 头添加 gzip 标识来开启这一功能。当然，服务器也得支持这一功能。</p></blockquote><blockquote><p>gzip 是目前最流行和最有效的压缩方法。举个例子，我用 Vue 开发的项目构建后生成的 app.js 文件大小为 1.4MB，使用 gzip 压缩后只有 573KB，体积减少了将近 60%。</p></blockquote><blockquote><p>附上 webpack 和 node 配置 gzip 的使用方法。</p></blockquote><blockquote><p><code>下载插件</code></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install compression-webpack-plugin --save-dev</span><br><span class="line">npm install compression</span><br></pre></td></tr></table></figure><blockquote><p><code>webpack 配置</code></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const CompressionPlugin = require(&#x27;compression-webpack-plugin&#x27;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  plugins: [new CompressionPlugin()],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>node 配置</code></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const compression = require(&#x27;compression&#x27;)</span><br><span class="line">// 在其他中间件前使用</span><br><span class="line">app.use(compression())</span><br></pre></td></tr></table></figure><h3 id="9-图片优化"><a href="#9-图片优化" class="headerlink" title="9. 图片优化"></a>9. 图片优化</h3><h4 id="1-图片延迟加载"><a href="#1-图片延迟加载" class="headerlink" title="(1). 图片延迟加载"></a>(1). 图片延迟加载</h4><blockquote><p>在页面中，先不给图片设置路径，只有当图片出现在浏览器的可视区域时，才去加载真正的图片，这就是延迟加载。对于图片很多的网站来说，一次性加载全部图片，会对用户体验造成很大的影响，所以需要使用图片延迟加载。</p></blockquote><blockquote><p>首先可以将图片这样设置，在页面不可见时图片不会加载：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img data-src=&quot;https://avatarsgithubusercontent.com/u/22117876?s=460&amp;u=7bd8f32788df6988833da6bd155c3cfbebc68006&amp;v=4&quot;&gt;</span><br></pre></td></tr></table></figure><blockquote><p>等页面可见时，使用 JS 加载图片：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const img = document.querySelector(&#x27;img&#x27;)</span><br><span class="line">img.src = img.dataset.src</span><br></pre></td></tr></table></figure><blockquote><p>这样图片就加载出来了，完整的代码可以看一下参考资料。</p></blockquote><blockquote><p>参考资料：</p></blockquote><ul><li>web 前端图片懒加载实现原理</li></ul><h4 id="2-响应式图片"><a href="#2-响应式图片" class="headerlink" title="(2). 响应式图片"></a>(2). 响应式图片</h4><blockquote><p>响应式图片的优点是浏览器能够根据屏幕大小自动加载合适的图片。</p></blockquote><blockquote><p>通过 <code>picture</code> 实现</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;picture&gt;</span><br><span class="line">    &lt;source srcset=&quot;banner_w10jpg&quot; media=&quot;(min-width: 801px)&quot;&gt;</span><br><span class="line">    &lt;source srcset=&quot;banner_w8jpg&quot; media=&quot;(max-width: 800px)&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;banner_w8jpg&quot; alt=&quot;&quot;&gt;</span><br><span class="line">&lt;/picture&gt;</span><br></pre></td></tr></table></figure><blockquote><p>通过 <code>@media</code> 实现</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@media (min-width: 769px) &#123;</span><br><span class="line">    .bg &#123;</span><br><span class="line">        background-image: url(bg10jpg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media (max-width: 768px) &#123;</span><br><span class="line">    .bg &#123;</span><br><span class="line">        background-image: url(bg7jpg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-调整图片大小"><a href="#3-调整图片大小" class="headerlink" title="(3). 调整图片大小"></a>(3). 调整图片大小</h4><blockquote><p>例如，你有一个 1920 * 1080 大小的图片，用缩略图的方式展示给用户，并且当用户鼠标悬停在上面时才展示全图。如果用户从未真正将鼠标悬停在缩略图上，则浪费了下载图片的时间。</p></blockquote><blockquote><p>所以，我们可以用两张图片来实行优化。一开始，只加载缩略图，当用户悬停在图片上时，才加载大图。还有一种办法，即对大图进行延迟加载，在所有元素都加载完成后手动更改大图的 src 进行下载。</p></blockquote><h4 id="4-降低图片质量"><a href="#4-降低图片质量" class="headerlink" title="(4). 降低图片质量"></a>(4). 降低图片质量</h4><blockquote><p>例如 JPG 格式的图片，100% 的质量和 90% 质量的通常看不出来区别，尤其是用来当背景图的时候。我经常用 PS 切背景图时， 将图片切成 JPG 格式，并且将它压缩到 60% 的质量，基本上看不出来区别。</p></blockquote><blockquote><p>压缩方法有两种，一是通过 webpack 插件 <code>image-webpack-loader</code>，二是通过在线网站进行压缩。</p></blockquote><blockquote><p>以下附上 webpack 插件 <code>image-webpack-loader</code> 的用法。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i -D image-webpack-loader</span><br></pre></td></tr></table></figure><blockquote><p>webpack 配置</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: /\.(png|jpe?g|gif|svg)(\\?.*)?$/,</span><br><span class="line">  use:[</span><br><span class="line">    &#123;</span><br><span class="line">    loader: &#x27;url-loader&#x27;,</span><br><span class="line">    options: &#123;</span><br><span class="line">      limit: 10000, /* 图片大小小于1000字节限制时会自动转成 base64 码引用*/</span><br><span class="line">      name: utils.assetsPath(&#x27;img/[name].[hash:7].[ext]&#x27;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    /*对图片进行压缩*/</span><br><span class="line">    &#123;</span><br><span class="line">      loader: &#x27;image-webpack-loader&#x27;,</span><br><span class="line">      options: &#123;</span><br><span class="line">        bypassOnDebug: true,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-尽可能利用-CSS3-效果代替图片"><a href="#5-尽可能利用-CSS3-效果代替图片" class="headerlink" title="(5). 尽可能利用 CSS3 效果代替图片"></a>(5). 尽可能利用 CSS3 效果代替图片</h4><blockquote><p>有很多图片使用 CSS 效果（渐变、阴影等）就能画出来，这种情况选择 CSS3 效果更好。因为代码大小通常是图片大小的几分之一甚至几十分之一。</p></blockquote><blockquote><p>参考资料：</p></blockquote><ul><li>img图片在webpack中使用</li></ul><h4 id="6-使用-webp-格式的图片"><a href="#6-使用-webp-格式的图片" class="headerlink" title="(6). 使用 webp 格式的图片"></a>(6). 使用 webp 格式的图片</h4><blockquote><p>WebP 的优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量；同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性，在 JPEG 和 PNG 上的转化效果都相当优秀、稳定和统一。</p></blockquote><blockquote><p>参考资料：</p></blockquote><ul><li>WebP 相对于 PNG、JPG 有什么优势？</li></ul><h3 id="10-通过-webpack-按需加载代码，提取第三库代码，减少-ES6-转为-ES5-的冗余代码"><a href="#10-通过-webpack-按需加载代码，提取第三库代码，减少-ES6-转为-ES5-的冗余代码" class="headerlink" title="10. 通过 webpack 按需加载代码，提取第三库代码，减少 ES6 转为 ES5 的冗余代码"></a>10. 通过 webpack 按需加载代码，提取第三库代码，减少 ES6 转为 ES5 的冗余代码</h3><blockquote><p>懒加载或者按需加载，是一种很好的优化网页或应用的方式。这种方式实际上是先把你的代码在一些逻辑断点处分离开，然后在一些代码块中完成某些操作后，立即引用或即将引用另外一些新的代码块。这样加快了应用的初始加载速度，减轻了它的总体体积，因为某些代码块可能永远不会被加载。</p></blockquote><h4 id="根据文件内容生成文件名，结合-import-动态引入组件实现按需加载"><a href="#根据文件内容生成文件名，结合-import-动态引入组件实现按需加载" class="headerlink" title="根据文件内容生成文件名，结合 import 动态引入组件实现按需加载"></a>根据文件内容生成文件名，结合 import 动态引入组件实现按需加载</h4><blockquote><p>通过配置 output 的 filename 属性可以实现这个需求。filename 属性的值选项中有一个 [contenthash]，它将根据文件内容创建出唯一 hash。当文件内容发生变化时，[contenthash] 也会发生变化。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    filename: &#x27;[name].[contenthash].js&#x27;,</span><br><span class="line">    chunkFilename: &#x27;[name].[contenthash].js&#x27;,</span><br><span class="line">    path: path.resolve(__dirname, &#x27;../dist&#x27;),</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="提取第三方库"><a href="#提取第三方库" class="headerlink" title="提取第三方库"></a>提取第三方库</h4><blockquote><p>由于引入的第三方库一般都比较稳定，不会经常改变。所以将它们单独提取出来，作为长期缓存是一个更好的选择。<br>这里需要使用 webpack4 的 splitChunk 插件 cacheGroups 选项。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">      runtimeChunk: &#123;</span><br><span class="line">        name: &#x27;manifest&#x27; // 将 webpack 的 runtime 代码拆分为一个单独的 chunk。</span><br><span class="line">    &#125;,</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">        cacheGroups: &#123;</span><br><span class="line">            vendor: &#123;</span><br><span class="line">                name: &#x27;chunk-vendors&#x27;,</span><br><span class="line">                test: /[\\\\/]node_modules[\\\\/]/,</span><br><span class="line">                priority: -10,</span><br><span class="line">                chunks: &#x27;initial&#x27;</span><br><span class="line">            &#125;,</span><br><span class="line">            common: &#123;</span><br><span class="line">                name: &#x27;chunk-common&#x27;,</span><br><span class="line">                minChunks: 2,</span><br><span class="line">                priority: -20,</span><br><span class="line">                chunks: &#x27;initial&#x27;,</span><br><span class="line">                reuseExistingChunk: true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ul><li>test: 用于控制哪些模块被这个缓存组匹配到。原封不动传递出去的话，它默认会选择所有的模块。可以传递的值类型：RegExp、String和Function;</li><li>priority：表示抽取权重，数字越大表示优先级越高。因为一个 module 可能会满足多个 cacheGroups 的条件，那么抽取到哪个就由权重最高的说了算；</li><li>reuseExistingChunk：表示是否使用已有的 chunk，如果为 true 则表示如果当前的 chunk 包含的模块已经被抽取出去了，那么将不会重新生成新的。</li><li>minChunks（默认是1）：在分割之前，这个代码块最小应该被引用的次数（译注：保证代码块复用性，默认配置的策略是不需要多次引用也可以被分割）</li><li>chunks (默认是async) ：initial、async和all</li><li>name(打包的chunks的名字)：字符串或者函数(函数可以根据条件自定义名字)</li></ul><h4 id="减少-ES6-转为-ES5-的冗余代码"><a href="#减少-ES6-转为-ES5-的冗余代码" class="headerlink" title="减少 ES6 转为 ES5 的冗余代码"></a>减少 ES6 转为 ES5 的冗余代码</h4><blockquote><p>Babel 转化后的代码想要实现和原来代码一样的功能需要借助一些帮助函数，比如：</p></blockquote><p><code>class Person &#123;&#125;</code></p><blockquote><p>会被转换为：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line"></span><br><span class="line">function _classCallCheck(instance, Constructor) &#123;</span><br><span class="line">  if (!(instance instanceof Constructor)) &#123;</span><br><span class="line">    throw new TypeError(&quot;Cannot call a class as a function&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var Person = function Person() &#123;</span><br><span class="line">  _classCallCheck(this, Person);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>这里 <code>_classCallCheck</code> 就是一个 <code>helper</code> 函数，如果在很多文件里都声明了类，那么就会产生很多个这样的 <code>helper</code> 函数。</p></blockquote><blockquote><p>这里的 <code>@babel/runtime</code> 包就声明了所有需要用到的帮助函数，而</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@babel/plugin-transform-runtime</span><br></pre></td></tr></table></figure><p>的作用就是将所有需要 <code>helper</code> 函数的文件，从 <code>@babel/runtime包</code> 引进来：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line"></span><br><span class="line">var _classCallCheck2 = require(&quot;@babel/runtime/helpers/classCallCheck&quot;);</span><br><span class="line"></span><br><span class="line">var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);</span><br><span class="line"></span><br><span class="line">function _interopRequireDefault(obj) &#123;</span><br><span class="line">  return obj &amp;&amp; obj.__esModule ? obj : &#123; default: obj &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var Person = function Person() &#123;</span><br><span class="line">  (0, _classCallCheckdefault)(this, Person);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>这里就没有再编译出 <code>helper</code> 函数 <code>classCallCheck</code> 了，而是直接引用了 <code>@babel/runtime</code> 中的</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">helpers/classCallCheck</span><br></pre></td></tr></table></figure><p>。</p><blockquote><p><code>安装</code></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i -D @babel/plugin-transform-runtime @babel/runtime</span><br></pre></td></tr></table></figure><blockquote><p><code>使用</code><br>在 <code>.babelrc</code> 文件中</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;plugins&quot;: [</span><br><span class="line">        &quot;@babel/plugin-transform-runtime&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>参考资料：</p></blockquote><ul><li>Babel 7.1介绍 transform-runtime polyfill env</li><li>懒加载</li><li>Vue 路由懒加载</li><li>webpack 缓存</li><li>一步一步的了解webpack4的splitChunk插件</li></ul><h3 id="11-减少重绘重排"><a href="#11-减少重绘重排" class="headerlink" title="11. 减少重绘重排"></a>11. 减少重绘重排</h3><blockquote><p><code>浏览器渲染过程</code></p></blockquote><ol><li>解析HTML生成DOM树。</li><li>解析CSS生成CSSOM规则树。</li><li>将DOM树与CSSOM规则树合并在一起生成渲染树。</li><li>遍历渲染树开始布局，计算每个节点的位置大小信息。</li><li>将渲染树每个节点绘制到屏幕。</li></ol><blockquote><p><code>重排</code></p></blockquote><blockquote><p>当改变 DOM 元素位置或大小时，会导致浏览器重新生成渲染树，这个过程叫重排。</p></blockquote><blockquote><p><code>重绘</code></p></blockquote><blockquote><p>当重新生成渲染树后，就要将渲染树每个节点绘制到屏幕，这个过程叫重绘。不是所有的动作都会导致重排，例如改变字体颜色，只会导致重绘。记住，重排会导致重绘，重绘不会导致重排 。</p></blockquote><blockquote><p>重排和重绘这两个操作都是非常昂贵的，因为 JavaScript 引擎线程与 GUI 渲染线程是互斥，它们同时只能一个在工作。</p></blockquote><blockquote><p>什么操作会导致重排？</p></blockquote><ul><li>添加或删除可见的 DOM 元素</li><li>元素位置改变</li><li>元素尺寸改变</li><li>内容改变</li><li>浏览器窗口尺寸改变</li></ul><blockquote><p>如何减少重排重绘？</p></blockquote><ul><li>用 JavaScript 修改样式时，最好不要直接写样式，而是替换 class 来改变样式。</li><li>如果要对 DOM 元素执行一系列操作，可以将 DOM 元素脱离文档流，修改完成后，再将它带回文档。推荐使用隐藏元素（display:none）或文档碎片（DocumentFragement），都能很好的实现这个方案。</li></ul><h3 id="12-使用事件委托"><a href="#12-使用事件委托" class="headerlink" title="12. 使用事件委托"></a>12. 使用事件委托</h3><blockquote><p>事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。所有用到按钮的事件（多数鼠标事件和键盘事件）都适合采用事件委托技术， 使用事件委托可以节省内存。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;苹果&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;香蕉&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;凤梨&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">document.querySelector(&#x27;ul&#x27;).onclick = (event) =&gt; &#123;</span><br><span class="line">  const target = event.target</span><br><span class="line">  if (target.nodeName === &#x27;LI&#x27;) &#123;</span><br><span class="line">    console.log(target.innerHTML)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// bad</span><br><span class="line">document.querySelectorAll(&#x27;li&#x27;).forEach((e) =&gt; &#123;</span><br><span class="line">  e.onclick = function() &#123;</span><br><span class="line">    console.log(this.innerHTML)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="13-注意程序的局部性"><a href="#13-注意程序的局部性" class="headerlink" title="13. 注意程序的局部性"></a>13. 注意程序的局部性</h3><blockquote><p>一个编写良好的计算机程序常常具有良好的局部性，它们倾向于引用最近引用过的数据项附近的数据项，或者最近引用过的数据项本身，这种倾向性，被称为局部性原理。有良好局部性的程序比局部性差的程序运行得更快。</p></blockquote><blockquote><p><code>局部性通常有两种不同的形式：</code></p></blockquote><ul><li>时间局部性：在一个具有良好时间局部性的程序中，被引用过一次的内存位置很可能在不远的将来被多次引用。</li><li>空间局部性 ：在一个具有良好空间局部性的程序中，如果一个内存位置被引用了一次，那么程序很可能在不远的将来引用附近的一个内存位置。</li></ul><blockquote><p>时间局部性示例</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function sum(arry) &#123;</span><br><span class="line">    let i, sum = 0</span><br><span class="line">    let len = arry.length</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        sum += arry[i]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这个例子中，变量sum在每次循环迭代中被引用一次，因此，对于sum来说，具有良好的时间局部性</p></blockquote><blockquote><p>空间局部性示例</p></blockquote><blockquote><p><code>具有良好空间局部性的程序</code></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 二维数组 </span><br><span class="line">function sum1(arry, rows, cols) &#123;</span><br><span class="line">    let i, j, sum = 0</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; rows; i++) &#123;</span><br><span class="line">        for (j = 0; j &lt; cols; j++) &#123;</span><br><span class="line">            sum += arry[i][j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>空间局部性差的程序</code></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 二维数组 </span><br><span class="line">function sum2(arry, rows, cols) &#123;</span><br><span class="line">    let i, j, sum = 0</span><br><span class="line"></span><br><span class="line">    for (j = 0; j &lt; cols; j++) &#123;</span><br><span class="line">        for (i = 0; i &lt; rows; i++) &#123;</span><br><span class="line">            sum += arry[i][j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>看一下上面的两个空间局部性示例，像示例中从每行开始按顺序访问数组每个元素的方式，称为具有步长为1的引用模式。<br>如果在数组中，每隔k个元素进行访问，就称为步长为k的引用模式。<br>一般而言，随着步长的增加，空间局部性下降。</p></blockquote><blockquote><p>这两个例子有什么区别？区别在于第一个示例是按行扫描数组，每扫描完一行再去扫下一行；第二个示例是按列来扫描数组，扫完一行中的一个元素，马上就去扫下一行中的同一列元素。</p></blockquote><blockquote><p>数组在内存中是按照行顺序来存放的，结果就是逐行扫描数组的示例得到了步长为 1 引用模式，具有良好的空间局部性；而另一个示例步长为 rows，空间局部性极差。</p></blockquote><h4 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h4><blockquote><p>运行环境：</p></blockquote><ul><li>cpu: i5-7400</li><li>浏览器: chrome 70.0.3538.110</li></ul><blockquote><p>对一个长度为9000的二维数组（子数组长度也为9000）进行10次空间局部性测试，时间（毫秒）取平均值，结果如下：</p></blockquote><blockquote><p>所用示例为上述两个空间局部性示例</p></blockquote><table><thead><tr><th>步长为 1</th><th>步长为 9000</th></tr></thead><tbody><tr><td>124</td><td>2316</td></tr></tbody></table><blockquote><p>从以上测试结果来看，步长为 1 的数组执行时间比步长为 9000 的数组快了一个数量级。</p></blockquote><blockquote><p>总结：</p></blockquote><ul><li>重复引用相同变量的程序具有良好的时间局部性</li><li>对于具有步长为 k 的引用模式的程序，步长越小，空间局部性越好；而在内存中以大步长跳来跳去的程序空间局部性会很差</li></ul><blockquote><p>参考资料：</p></blockquote><ul><li>深入理解计算机系统</li></ul><h3 id="14-if-else-对比-switch"><a href="#14-if-else-对比-switch" class="headerlink" title="14. if-else 对比 switch"></a>14. if-else 对比 switch</h3><blockquote><p>当判断条件数量越来越多时，越倾向于使用 switch 而不是 if-else。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (color == &#x27;blue&#x27;) &#123;</span><br><span class="line"></span><br><span class="line">&#125; else if (color == &#x27;yellow&#x27;) &#123;</span><br><span class="line"></span><br><span class="line">&#125; else if (color == &#x27;white&#x27;) &#123;</span><br><span class="line"></span><br><span class="line">&#125; else if (color == &#x27;black&#x27;) &#123;</span><br><span class="line"></span><br><span class="line">&#125; else if (color == &#x27;green&#x27;) &#123;</span><br><span class="line"></span><br><span class="line">&#125; else if (color == &#x27;orange&#x27;) &#123;</span><br><span class="line"></span><br><span class="line">&#125; else if (color == &#x27;pink&#x27;) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">switch (color) &#123;</span><br><span class="line">    case &#x27;blue&#x27;:</span><br><span class="line"></span><br><span class="line">        break</span><br><span class="line">    case &#x27;yellow&#x27;:</span><br><span class="line"></span><br><span class="line">        break</span><br><span class="line">    case &#x27;white&#x27;:</span><br><span class="line"></span><br><span class="line">        break</span><br><span class="line">    case &#x27;black&#x27;:</span><br><span class="line"></span><br><span class="line">        break</span><br><span class="line">    case &#x27;green&#x27;:</span><br><span class="line"></span><br><span class="line">        break</span><br><span class="line">    case &#x27;orange&#x27;:</span><br><span class="line"></span><br><span class="line">        break</span><br><span class="line">    case &#x27;pink&#x27;:</span><br><span class="line"></span><br><span class="line">        break</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>像上面的这种情况，从可读性来说，使用 switch 是比较好的（js 的 switch 语句不是基于哈希实现，而是循环判断，所以说 if-else、switch 从性能上来说是一样的）。</p></blockquote><h3 id="15-查找表"><a href="#15-查找表" class="headerlink" title="15. 查找表"></a>15. 查找表</h3><blockquote><p>当条件语句特别多时，使用 switch 和 if-else 不是最佳的选择，这时不妨试一下查找表。查找表可以使用数组和对象来构建。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">switch (index) &#123;</span><br><span class="line">    case &#x27;0&#x27;:</span><br><span class="line">        return result0</span><br><span class="line">    case &#x27;1&#x27;:</span><br><span class="line">        return result1</span><br><span class="line">    case &#x27;2&#x27;:</span><br><span class="line">        return result2</span><br><span class="line">    case &#x27;3&#x27;:</span><br><span class="line">        return result3</span><br><span class="line">    case &#x27;4&#x27;:</span><br><span class="line">        return result4</span><br><span class="line">    case &#x27;5&#x27;:</span><br><span class="line">        return result5</span><br><span class="line">    case &#x27;6&#x27;:</span><br><span class="line">        return result6</span><br><span class="line">    case &#x27;7&#x27;:</span><br><span class="line">        return result7</span><br><span class="line">    case &#x27;8&#x27;:</span><br><span class="line">        return result8</span><br><span class="line">    case &#x27;9&#x27;:</span><br><span class="line">        return result9</span><br><span class="line">    case &#x27;10&#x27;:</span><br><span class="line">        return result10</span><br><span class="line">    case &#x27;11&#x27;:</span><br><span class="line">        return result11</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以将这个 switch 语句转换为查找表</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const results = [result0,result1,result2,result3,result4,result5,result6,result7,result8,result9,result10,result11]</span><br><span class="line"></span><br><span class="line">return results[index]</span><br></pre></td></tr></table></figure><blockquote><p>如果条件语句不是数值而是字符串，可以用对象来建立查找表</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const map = &#123;</span><br><span class="line">  red: result0,</span><br><span class="line">  green: result1,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return map[color]</span><br></pre></td></tr></table></figure><h3 id="16-避免页面卡顿"><a href="#16-避免页面卡顿" class="headerlink" title="16. 避免页面卡顿"></a>16. 避免页面卡顿</h3><blockquote><p><code>60fps 与设备刷新率</code></p></blockquote><blockquote><p>目前大多数设备的屏幕刷新率为 60 次/秒。因此，如果在页面中有一个动画或渐变效果，或者用户正在滚动页面，那么浏览器渲染动画或页面的每一帧的速率也需要跟设备屏幕的刷新率保持一致。<br>其中每个帧的预算时间仅比 16 毫秒多一点 (1 秒/ 60 = 16.66 毫秒)。但实际上，浏览器有整理工作要做，因此您的所有工作需要在 10 毫秒内完成。如果无法符合此预算，帧率将下降，并且内容会在屏幕上抖动。 此现象通常称为卡顿，会对用户体验产生负面影响。</p></blockquote><blockquote><p>假如你用 JavaScript 修改了 DOM，并触发样式修改，经历重排重绘最后画到屏幕上。如果这其中任意一项的执行时间过长，都会导致渲染这一帧的时间过长，平均帧率就会下降。假设这一帧花了 50 ms，那么此时的帧率为 1s / 50ms = 20fps，页面看起来就像卡顿了一样。</p></blockquote><blockquote><p>对于一些长时间运行的 JavaScript，我们可以使用定时器进行切分，延迟执行。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (let i = 0, len = arry.length; i &lt; len; i++) &#123;</span><br><span class="line">    process(arry[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>假设上面的循环结构由于 process() 复杂度过高或数组元素太多，甚至两者都有，可以尝试一下切分。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const todo = arry.concat()</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    process(todo.shift())</span><br><span class="line">    if (todo.length) &#123;</span><br><span class="line">        setTimeout(arguments.callee, 25)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        callback(arry)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, 25)</span><br></pre></td></tr></table></figure><blockquote><p>如果有兴趣了解更多，可以查看一下高性能JavaScript第 6 章和高效前端：Web高效编程与优化实践第 3 章。</p></blockquote><blockquote><p>参考资料：</p></blockquote><ul><li>渲染性能</li></ul><h3 id="17-使用-requestAnimationFrame-来实现视觉变化"><a href="#17-使用-requestAnimationFrame-来实现视觉变化" class="headerlink" title="17. 使用 requestAnimationFrame 来实现视觉变化"></a>17. 使用 requestAnimationFrame 来实现视觉变化</h3><blockquote><p>从第 16 点我们可以知道，大多数设备屏幕刷新率为 60 次/秒，也就是说每一帧的平均时间为 16.66 毫秒。在使用 JavaScript 实现动画效果的时候，最好的情况就是每次代码都是在帧的开头开始执行。而保证 JavaScript 在帧开始时运行的唯一方式是使用</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">requestAnimationFrame</span><br></pre></td></tr></table></figure><p>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * If run as a requestAnimationFrame callback, this</span><br><span class="line"> * will be run at the start of the frame.</span><br><span class="line"> */</span><br><span class="line">function updateScreen(time) &#123;</span><br><span class="line">  // Make visual updates here.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">requestAnimationFrame(updateScreen);</span><br></pre></td></tr></table></figure><blockquote><p>如果采取 <code>setTimeout</code> 或 <code>setInterval</code> 来实现动画的话，回调函数将在帧中的某个时点运行，可能刚好在末尾，而这可能经常会使我们丢失帧，导致卡顿。</p></blockquote><blockquote><p>参考资料：</p></blockquote><ul><li>优化 JavaScript 执行</li></ul><h3 id="18-使用-Web-Workers"><a href="#18-使用-Web-Workers" class="headerlink" title="18. 使用 Web Workers"></a>18. 使用 Web Workers</h3><blockquote><p>Web Worker 使用其他工作线程从而独立于主线程之外，它可以执行任务而不干扰用户界面。一个 worker 可以将消息发送到创建它的 JavaScript 代码, 通过将消息发送到该代码指定的事件处理程序（反之亦然）。</p></blockquote><blockquote><p>Web Worker 适用于那些处理纯数据，或者与浏览器 UI 无关的长时间运行脚本。</p></blockquote><blockquote><p>创建一个新的 worker 很简单，指定一个脚本的 URI 来执行 worker 线程（main.js）：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var myWorker = new Worker(&#x27;worker.js&#x27;);</span><br><span class="line">// 你可以通过postMessage() 方法和onmessage事件向worker发送消息。</span><br><span class="line">first.onchange = function() &#123;</span><br><span class="line">  myWorker.postMessage([first.value,second.value]);</span><br><span class="line">  console.log(&#x27;Message posted to worker&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">second.onchange = function() &#123;</span><br><span class="line">  myWorker.postMessage([first.value,second.value]);</span><br><span class="line">  console.log(&#x27;Message posted to worker&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在 worker 中接收到消息后，我们可以写一个事件处理函数代码作为响应（worker.js）：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">onmessage = function(e) &#123;</span><br><span class="line">  console.log(&#x27;Message received from main script&#x27;);</span><br><span class="line">  var workerResult = &#x27;Result: &#x27; + (e.data[0] * e.data[1]);</span><br><span class="line">  console.log(&#x27;Posting message back to main script&#x27;);</span><br><span class="line">  postMessage(workerResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>onmessage处理函数在接收到消息后马上执行，代码中消息本身作为事件的data属性进行使用。这里我们简单的对这2个数字作乘法处理并再次使用postMessage()方法，将结果回传给主线程。</p></blockquote><blockquote><p>回到主线程，我们再次使用onmessage以响应worker回传的消息：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">myWorker.onmessage = function(e) &#123;</span><br><span class="line">  result.textContent = e.data;</span><br><span class="line">  console.log(&#x27;Message received from worker&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这里我们获取消息事件的data，并且将它设置为result的textContent，所以用户可以直接看到运算的结果。</p></blockquote><blockquote><p>不过在worker内，不能直接操作DOM节点，也不能使用window对象的默认方法和属性。然而你可以使用大量window对象之下的东西，包括WebSockets，IndexedDB以及FireFox OS专用的Data Store API等数据存储机制。</p></blockquote><blockquote><p>参考资料：</p></blockquote><ul><li>Web Workers</li></ul><h3 id="19-使用位操作"><a href="#19-使用位操作" class="headerlink" title="19. 使用位操作"></a>19. 使用位操作</h3><blockquote><p>JavaScript 中的数字都使用 IEEE-754 标准以 64 位格式存储。但是在位操作中，数字被转换为有符号的 32 位格式。即使需要转换，位操作也比其他数学运算和布尔操作快得多。</p></blockquote><h5 id="取模"><a href="#取模" class="headerlink" title="取模"></a>取模</h5><blockquote><p>由于偶数的最低位为 0，奇数为 1，所以取模运算可以用位操作来代替。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (value % 2) &#123;</span><br><span class="line">    // 奇数</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // 偶数 </span><br><span class="line">&#125;</span><br><span class="line">// 位操作</span><br><span class="line">if (value &amp; 1) &#123;</span><br><span class="line">    // 奇数</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // 偶数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="取整"><a href="#取整" class="headerlink" title="取整"></a>取整</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~~12 // 10</span><br><span class="line">~~10 // 10</span><br><span class="line">~~&#x27;5&#x27; // 1</span><br><span class="line">~~undefined // 0</span><br><span class="line">~~null // 0</span><br></pre></td></tr></table></figure><h5 id="位掩码"><a href="#位掩码" class="headerlink" title="位掩码"></a>位掩码</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const a = 1</span><br><span class="line">const b = 2</span><br><span class="line">const c = 4</span><br><span class="line">const options = a | b | c</span><br></pre></td></tr></table></figure><blockquote><p>通过定义这些选项，可以用按位与操作来判断 a/b/c 是否在 options 中。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 选项 b 是否在选项中</span><br><span class="line">if (b &amp; options) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="20-不要覆盖原生方法"><a href="#20-不要覆盖原生方法" class="headerlink" title="20. 不要覆盖原生方法"></a>20. 不要覆盖原生方法</h3><blockquote><p>无论你的 JavaScript 代码如何优化，都比不上原生方法。因为原生方法是用低级语言写的（C/C++），并且被编译成机器码，成为浏览器的一部分。当原生方法可用时，尽量使用它们，特别是数学运算和 DOM 操作。</p></blockquote><h3 id="21-降低-CSS-选择器的复杂性"><a href="#21-降低-CSS-选择器的复杂性" class="headerlink" title="21. 降低 CSS 选择器的复杂性"></a>21. 降低 CSS 选择器的复杂性</h3><h4 id="1-浏览器读取选择器，遵循的原则是从选择器的右边到左边读取。"><a href="#1-浏览器读取选择器，遵循的原则是从选择器的右边到左边读取。" class="headerlink" title="(1). 浏览器读取选择器，遵循的原则是从选择器的右边到左边读取。"></a>(1). 浏览器读取选择器，遵循的原则是从选择器的右边到左边读取。</h4><blockquote><p>看个示例</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#block .text p &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>查找所有 P 元素。</li><li>查找结果 1 中的元素是否有类名为 text 的父元素</li><li>查找结果 2 中的元素是否有 id 为 block 的父元素</li></ol><h4 id="2-CSS-选择器优先级"><a href="#2-CSS-选择器优先级" class="headerlink" title="(2). CSS 选择器优先级"></a>(2). CSS 选择器优先级</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">内联 &gt; ID选择器 &gt; 类选择器 &gt; 标签选择器</span><br></pre></td></tr></table></figure><blockquote><p>根据以上两个信息可以得出结论。</p></blockquote><ol><li>选择器越短越好。</li><li>尽量使用高优先级的选择器，例如 ID 和类选择器。</li><li>避免使用通配符 *。</li></ol><h3 id="网站性能检查"><a href="#网站性能检查" class="headerlink" title="网站性能检查"></a>网站性能检查</h3><h5 id="检查加载性能"><a href="#检查加载性能" class="headerlink" title="检查加载性能"></a>检查加载性能</h5><blockquote><p>一个网站加载性能如何主要看白屏时间和首屏时间。</p></blockquote><ul><li>白屏时间：指从输入网址，到页面开始显示内容的时间。</li><li>首屏时间：指从输入网址，到页面完全渲染的时间。</li></ul><blockquote><p>将以下脚本放在 <code>&lt;/head&gt;</code> 前面就能获取白屏时间。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  new Date() - performance.timing.navigationStart</span><br><span class="line">  // 通过 domLoading 和 navigationStart 也可以</span><br><span class="line">  performance.timing.domLoading - performance.timing.navigationStart</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><blockquote><p>在 <code>window.onload</code> 事件里执行</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new Date() - performance.timing.navigationStart</span><br></pre></td></tr></table></figure><p>即可获取首屏时间。</p><h5 id="检查运行性能"><a href="#检查运行性能" class="headerlink" title="检查运行性能"></a>检查运行性能</h5><blockquote><p>配合 chrome 的开发者工具，我们可以查看网站在运行时的性能。</p></blockquote><blockquote><p>打开网站，按 F12 选择 performance，点击左上角的灰色圆点，变成红色就代表开始记录了。这时可以模仿用户使用网站，在使用完毕后，点击 stop，然后你就能看到网站运行期间的性能报告。如果有红色的块，代表有掉帧的情况；如果是绿色，则代表 FPS 很好。performance 的具体使用方法请用搜索引擎搜索一下，毕竟篇幅有限。</p></blockquote><blockquote><p>通过检查加载和运行性能，相信你对网站性能已经有了大概了解。所以这时候要做的事情，就是使用上述 建议尽情地去优化你的网站，加油！</p></blockquote></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By souldjl</div><div class="footer_custom_text">没有行动的梦想，都是妄想～</div><a href="/statement">免责申明</a><span class="footer-separator">| 友情链接:</span><a target="_blank" rel="noopener" href="https://blog.xujiayao.top">Xujiayao's Blog</a></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script src="https://cdn.bootcdn.net/ajax/libs/Swiper/7.4.1/swiper-bundle.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",function(){if(window.removeEventListener("scroll",window.tocScrollFn),window.removeEventListener("scroll",scrollCollect),"object"==typeof preloader&&preloader.initLoading(),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")}),document.addEventListener("pjax:complete",function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script");var o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()}),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>