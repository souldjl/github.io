<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>React hooks | 高级前端进阶</title><meta name="keywords" content="高级前端开发,JavaScript,面试,js,React,React.js,React面试题"><meta name="author" content="souldjl"><meta name="copyright" content="souldjl"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="高级前端开发,JavaScript,面试,js,React,React.js,React面试题"><meta property="og:type" content="article"><meta property="og:title" content="React hooks"><meta property="og:url" content="https://www.daijl.cn/11559/index.html"><meta property="og:site_name" content="高级前端进阶"><meta property="og:description" content="高级前端开发,JavaScript,面试,js,React,React.js,React面试题"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.daijl.cn/img/cover/cover_10.jpg"><meta property="article:published_time" content="2022-02-08T06:21:43.000Z"><meta property="article:modified_time" content="2022-02-08T06:21:43.000Z"><meta property="article:author" content="souldjl"><meta property="article:tag" content="React"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.daijl.cn/img/cover/cover_10.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://www.daijl.cn/11559/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="T8zNWQNhDDztzYe6Y7pYKuJIY8LO45bxxN1iGheQnI"><meta name="baidu_site_verification" content="code-UTlFxDZspp"><meta name="sogou_site_verification" content="pSw0CiDaj7"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?f30a76e6d5701be25349f80c829c0a52";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:50,languages:{author:"作者: souldjl",link:"链接: ",source:"来源: 高级前端进阶",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"null",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"React hooks",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-02-08 14:21:43"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0!==o){const a=new Date;o=864e5*o,o={value:t,expiry:a.getTime()+o};localStorage.setItem(e,JSON.stringify(o))}},get:function(e){var t=localStorage.getItem(e);if(t){t=JSON.parse(t);const o=new Date;if(!(o.getTime()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=a=>new Promise((t,e)=>{const o=document.createElement("script");o.src=a,o.async=!0,o.onerror=e,o.onload=o.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(o.onload=o.onreadystatechange=null,t())},document.head.appendChild(o)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};e=saveToLocal.get("theme");"dark"===e?activateDarkMode():"light"===e&&activateLightMode();e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/Swiper/7.4.1/swiper-bundle.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">52</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/recommend-books/"><i class="fa-fw fas fa-link"></i><span> 书籍推荐</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-tools"></i><span> 实用工具</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://nav.daijl.cn/"><span>编程导航</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">高级前端进阶</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/recommend-books/"><i class="fa-fw fas fa-link"></i><span> 书籍推荐</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-tools"></i><span> 实用工具</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://nav.daijl.cn/"><span>编程导航</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">React hooks</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-02-08T06:21:43.000Z" title="发表于 2022-02-08 14:21:43">2022-02-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-02-08T06:21:43.000Z" title="更新于 2022-02-08 14:21:43">2022-02-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%A1%86%E6%9E%B6/React/">React</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>33分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="React hooks"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/11559/#post-comment"><span class="gitalk-comment-count"></span></a></span></div></div></div><article class="post-content" id="article-container"><h2 id="8-1-React-hooks"><a href="#8-1-React-hooks" class="headerlink" title="8.1 React-hooks"></a>8.1 React-hooks</h2><h3 id="8-1-1-hooks使命"><a href="#8-1-1-hooks使命" class="headerlink" title="8.1.1 hooks使命"></a>8.1.1 hooks使命</h3><h4 id="逻辑组件复用"><a href="#逻辑组件复用" class="headerlink" title="逻辑组件复用"></a>逻辑组件复用</h4><ul><li><p>逻辑与UI组件分离</p><p>React 官方推荐在开发中将逻辑部分与视图部分结耦，便于定位问题和职责清晰</p></li><li><p>函数组件拥有state</p><p>在函数组件中如果要实现类似拥有state的状态，必须要将组件转成class组件</p></li><li><p>逻辑组件复用</p></li></ul><p>社区一直致力于逻辑层面的复用，像 render props / HOC，不过它们都有对应的问题，Hooks是目前为止相对完美的解决方案</p><h4 id="hooks-解决的问题"><a href="#hooks-解决的问题" class="headerlink" title="hooks 解决的问题"></a>hooks 解决的问题</h4><p>render props</p><p>Avator 组件是一个渲染头像的组件，里面包含其中一些业务逻辑，User组件是纯ui组件，用于展示用户昵称</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> funtion <span class="function"><span class="title">APP</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Avatar</span>&gt;</span></span></span><br><span class="line"><span class="xml">               &#123;data=&gt; <span class="tag">&lt;<span class="name">User</span> <span class="attr">name</span>=<span class="string">&#123;data&#125;/</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">Avatar</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过渲染props来实现逻辑组件复用</li><li>render props 通过嵌套组件实现，在真实的业务中，会出现嵌套多层，以及梭理props不清晰的问题</li></ul><p>Hoc</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Avatar</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">funtion <span class="function"><span class="title">HocAvatar</span>(<span class="params">Component</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">()=&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">Component</span> <span class="attr">name</span>=<span class="string">&#x27;王艺瑾&#x27;</span>/&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过对现有组件进行扩展、增强的方式来实现复用，通常采用包裹方法来实现</li><li>高阶组件的实现会额外地增加元素层级，使得页面元素的数量更加臃肿</li></ul><p>Hooks</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;useState&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">HooksAvatar</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [name,setName]=useState(<span class="string">&#x27;王一瑾&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;&gt;</span>&#123;name&#125;<span class="tag">&lt;/&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>React 16.8引入的Hooks，使得实现相同功能而代码量更少成为现实</li><li>通过使用Hooks，不仅在编码层面减少代码的数量，同样在编译之后的代码也会更少</li></ul><h3 id="8-1-2-hooks实践"><a href="#8-1-2-hooks实践" class="headerlink" title="8.1.2 hooks实践"></a>8.1.2 hooks实践</h3><h4 id="Hook官方APi（大概率用到的）"><a href="#Hook官方APi（大概率用到的）" class="headerlink" title="Hook官方APi（大概率用到的）"></a>Hook官方APi（大概率用到的）</h4><ul><li>useState<br>函数组件中的state方法</li><li>useEffect<br>函数组件处理副作用的方法，什么是副作用？异步请求、订阅原生的dom实事件、setTimeoutd等</li><li>useContext<br>接受一个context对象（React.createContext的返回值）并返回该context的当前值，当前的context由上层组件中距离最近的<code>&lt;Mycontext.provider&gt;&lt;/Mycontext.provider&gt;</code>的<br>value prop决定</li><li>useReducer<br>另一种”useState”，跟redux有点类似</li><li>useRef<br>返回一个突变的ref对象，对象在函数的生命周期内一直存在</li><li>useMemo 缓存数值</li><li>useCallback 缓存函数</li><li>useCustom<br>自定义Hooks组件</li></ul><ol><li>useState</li></ol><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;useState&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">const</span> HooksTest = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 声明一个count的state变量，useState可以给一个默认值</span></span><br><span class="line">    <span class="keyword">const</span> [count,setCount]=useState(<span class="number">0</span>) </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        useState也可以传递一个函数，</span></span><br><span class="line"><span class="comment">            const [count,setCount]=useState(()=&gt;&#123;</span></span><br><span class="line"><span class="comment">            return 2</span></span><br><span class="line"><span class="comment">        &#125;)  </span></span><br><span class="line"><span class="comment">        setCount也可以传递一个函数</span></span><br><span class="line"><span class="comment">        这个函数第一个参数可以拿到上一次的值，</span></span><br><span class="line"><span class="comment">        在可以在函数里做一些操作</span></span><br><span class="line"><span class="comment">        setCount((preState)=&gt;&#123;</span></span><br><span class="line"><span class="comment">            return &#123;...preState,..updatedValues&#125;</span></span><br><span class="line"><span class="comment">        &#125;) </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &#123;<span class="comment">/*通过setCount来改变count的值*/</span>&#125;</span><br><span class="line">            &lt;button onClick=&#123;<span class="function">()=&gt;</span>&#123;</span><br><span class="line">               setCount(count+<span class="number">1</span>) </span><br><span class="line">            &#125;&#125;</span><br><span class="line">            &gt;Add&lt;/button&gt;</span><br><span class="line">            &#123;count&#125;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ol start="2"><li>useEffect</li></ol><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;useEffect&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="comment">// 我们可以把useEffect 看做componentDidmount、componentDidUpdate、componntWillUnmount</span></span><br><span class="line"><span class="keyword">const</span> HooksTest = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// useEffect可以让你在第一个参数的函数中执行副作用操作，就是请求数据，dom操作之类的</span></span><br><span class="line">    <span class="comment">// useEffect返回一个函数，函数里表示要清除的副作用，例如清除定时器,返回的函数会在卸载组件时执行</span></span><br><span class="line">    useEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">clearInterval</span>(timer)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      useEffect的第二个参数，通过在数组中传递值，例如只有count变化时才调用Effect，达到</span></span><br><span class="line"><span class="comment">      不用每次渲染后都执行清理或执行effect导致的性能问题</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    useEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">     <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">    &#125;,[count])</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    如果想执行只运行一次的effect（仅在组件挂载和卸载时执行），可以传递一个空数组，</span></span><br><span class="line"><span class="comment">    告诉React你的Effect不依赖与props或state中任何值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    useEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">     <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">    &#125;,[])</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">      可以使用多个Effect，将不相关的逻辑分离到不同的effect中</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   useEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">       axios.get(<span class="string">&#x27;login&#x27;</span>)</span><br><span class="line">   &#125;,[])</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">         <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>You clicked &#123;count&#125; times<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="xml">                Click me</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">         <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>useContext</li></ol><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 创建一个上下文管理组件context-manager.js，用于统一导出context实例</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ItemsContext = React.createContext(&#123; <span class="attr">name</span>: <span class="string">&#x27;&#x27;</span> &#125;) <span class="comment">//接受一个默认值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 父组件提供数据</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Child <span class="keyword">from</span> <span class="string">&#x27;./child&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; ItemsContext &#125; <span class="keyword">from</span> <span class="string">&#x27;./context-manager&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./index.scss&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> items = &#123; <span class="attr">name</span>: <span class="string">&#x27;测试&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">const</span> Father = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;father&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">ItemsContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;items&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Child</span>&gt;</span><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">ItemsContext.Provider</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Father</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.子组件用useContext解析上下文</span></span><br><span class="line"><span class="keyword">import</span> React ,&#123;useContext&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; ItemsContext &#125; <span class="keyword">from</span> <span class="string">&#x27;./context-manager&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./index.scss&#x27;</span></span><br><span class="line"><span class="keyword">const</span> Child = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> items=useContext(ItemsContext)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;child&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        子组件</span></span><br><span class="line"><span class="xml">        &#123;items.name&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Child</span><br></pre></td></tr></table></figure><ol start="4"><li>useReducer</li></ol><p>useReducer是useState的替代方案，它接受一个形如(state,action)=&gt;newState的reducer，并返回当前的state以及与其配套的dispatch方法</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;useReducer&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">const</span> initialState=&#123;<span class="attr">count</span>:<span class="number">0</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span> (<span class="params">state,action</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.type)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;increment&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">count</span>:state.count+<span class="number">1</span>&#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;decrement&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">count</span>:state.count-<span class="number">1</span>&#125;</span><br><span class="line">        <span class="attr">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> [state.dispatch]=useReducer(reducer,initialState)</span><br><span class="line"><span class="keyword">const</span> HooksTest = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &#123;state.count&#125;</span><br><span class="line">            &lt;button onClick=&#123;<span class="function">()=&gt;</span>&#123;</span><br><span class="line">             dispatch(&#123;<span class="attr">type</span>:<span class="string">&#x27;increment&#x27;</span>&#125;)</span><br><span class="line">            &#125;&#125;&gt;increment&lt;/button&gt;</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="xml">             dispatch(&#123;type:&#x27;decrement&#x27;&#125;)</span></span><br><span class="line"><span class="xml">            &#125;&#125;&gt;increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">        &lt;div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><ol start="5"><li>useRef</li></ol><ul><li>获取dom</li></ul><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;useRef&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">const</span> HooksTest = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> inputEl=useRef(<span class="literal">null</span>)</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">onButtion</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//  inputEl.current 就是我们获取的dom对象</span></span><br><span class="line">      inputEl.current.focus() </span><br><span class="line">   &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;input type=&#x27;text&#x27; ref=&#123;inputEl&#125;&gt;</span><br><span class="line">            &lt;button onClick=&#123;onButtion&#125;</span><br><span class="line">            &gt;Add&lt;/button&gt;</span><br><span class="line">            &#123;count&#125;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>存变量</li></ul><p>因为在函数式组件里没有this来存放一些实例的变量，所以React建议使用useRef来存放有一些会发生变化的值，useRef 不单是为了DOM的ref，同时也是为了存放实例属性</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> intervalRef=useRef()</span><br><span class="line">useEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    intervalRef.current=setInterVal(<span class="function">()=&gt;</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">clearInterval</span>(intervalRef.current)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="6"><li>useImperativeHandle</li></ol><p>可以让你在使用ref时自定义暴露给父组件的实例值,useImperativeHandle 应当与forwardRef 一起使用，这样可以父组件可以调用子组件的方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">const</span> modelRef = useRef(<span class="literal">null</span>);</span><br><span class="line"> <span class="comment">/* 确定 */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sureBtn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 调用子组件的方法</span></span><br><span class="line">    inputRef.current.model();</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">return</span> (</span><br><span class="line">     <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onClick</span>=<span class="string">&#123;sureBtn&#125;</span>&gt;</span>确定<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;<span class="name">Children</span> <span class="attr">ref</span>=<span class="string">&#123;modelRef&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Children</span>&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;/&gt;</span></span></span><br><span class="line"> )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="keyword">const</span> Children = React.forwardRef(<span class="function">(<span class="params">props,ref</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">const</span> [visible, setVisible] = useState(<span class="literal">false</span>);</span><br><span class="line">    useImperativeHandle(ref, <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">      <span class="attr">model</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        setVisible(<span class="literal">true</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="7"><li>useMemo</li></ol><p>useMemo的理念和memo差不多，都是根据判断是否满足当前的有限条件来决定是否执行useMemo的callback函数，第二个参数是一个deps数组，数组里的参数变化决定了useMemo是否更新回调函数。</p><p>useMemo和useCallback参数一样，区别是useMemo的返回的是缓存的值，useCallback返回的是函数。</p><ul><li>useMemo减少不必要的渲染<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用 useMemo包裹的list可以限定当且仅当list改变的时候才更新此list，这样就可以避免List重新循环 </span></span><br><span class="line"> &#123;useMemo(<span class="function">() =&gt;</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;</span></span><br><span class="line"><span class="xml">          list.map((i, v) =&gt; (</span></span><br><span class="line"><span class="xml">              <span class="tag">&lt;<span class="name">span</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                  <span class="attr">key</span>=<span class="string">&#123;v&#125;</span> &gt;</span></span></span><br><span class="line"><span class="xml">                  &#123;i.patentName&#125; </span></span><br><span class="line"><span class="xml">              <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">          ))&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">), [list])&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>useMemo减少子组件的渲染次数</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">useMemo(<span class="function">() =&gt;</span> (</span><br><span class="line">    &#123; <span class="comment">/* 减少了PatentTable组件的渲染 */</span> &#125;</span><br><span class="line">       &lt;PatentTable</span><br><span class="line">           getList=&#123;getList&#125;</span><br><span class="line">           selectList=&#123;selectList&#125;</span><br><span class="line">           cacheSelectList=&#123;cacheSelectList&#125;</span><br><span class="line">           setCacheSelectList=&#123;setCacheSelectList&#125; /&gt;</span><br><span class="line">), [listshow, cacheSelectList])</span><br></pre></td></tr></table></figure><ul><li>useMemo避免很多不必要的计算开销</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> Demo=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">/* 用useMemo 包裹之后的log函数可以避免了每次组件更新再重新声明 ，可以限制上下文的执行 */</span></span><br><span class="line">    <span class="keyword">const</span> newLog = useMemo(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">     <span class="keyword">const</span> log =<span class="function">()=&gt;</span>&#123;</span><br><span class="line">           <span class="comment">// 大量计算 </span></span><br><span class="line">           <span class="comment">// 在这里面不能获取实时的其他值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> log</span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="comment">// or</span></span><br><span class="line">   <span class="keyword">const</span> log2 = useMemo（()=&gt;&#123;</span><br><span class="line">           <span class="comment">// 大量计算 </span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="comment">// 计算后的值</span></span><br><span class="line">    &#125;,[list])</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>newLog()&#125; &gt;&#123;log2&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>useCallback</li></ol><p>useMemo和useCallback接收的参数都是一样，都是依赖项发生变化后才会执行；useMemo返回的是函数运行结果，useCallback返回的是函数；父组件传递一个函数<br>给子组件的时候，由于函数组件每一次都会生成新的props函数，这就使的每次一个传递给子组件的函数都发生的变化，这样就会触发子组件的更新，有些更新是没有必要的。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> Father=<span class="function">(<span class="params">&#123; id &#125;</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> getInfo  = useCallback(<span class="function">(<span class="params">sonName</span>)=&gt;</span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(sonName)</span><br><span class="line">    &#125;,[id])</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;/* 点击按钮触发父组件更新 ，但是子组件没有更新 */&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span>setNumber(number+1) &#125; &gt;增加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">DemoChildren</span> <span class="attr">getInfo</span>=<span class="string">&#123;getInfo&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用react.memo */</span></span><br><span class="line"><span class="keyword">const</span> Children = React.memo(<span class="function">(<span class="params">props</span>)=&gt;</span>&#123;</span><br><span class="line">   <span class="comment">/* 只有初始化的时候打印了 子组件更新 */</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;子组件更新&#x27;</span>,props.getInfo())</span><br><span class="line">   <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>子组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>useCallback必须配合 react.memo pureComponent，否则不但不会提升性能，还有可能降低性能。</p><p>react-hooks的诞生，也不是说它能够完全代替class声明的组件，对于业务比较复杂的组件，class组件还是首选，只不过我们可以把class组件内部拆解成funciton组件，根据业务需求，哪些负责逻辑交互，哪些需要动态渲染，然后配合usememo等api，让性能提升起来。react-hooks使用也有一些限制条件，比如说不能放在流程控制语句中，执行上下文也有一定的要求。</p><h3 id="8-1-5扩展资料"><a href="#8-1-5扩展资料" class="headerlink" title="8.1.5扩展资料"></a>8.1.5扩展资料</h3><p><a target="_blank" rel="noopener" href="https://reactjs.org/docs/hooks-intro.html">React Hooks 官方文档</a></p><p><a target="_blank" rel="noopener" href="https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/">useEffect 完整指南</a></p><h2 id="8-2-React-hooks原理解析"><a href="#8-2-React-hooks原理解析" class="headerlink" title="8.2 React-hooks原理解析"></a>8.2 React-hooks原理解析</h2><h3 id="8-2-1-前言"><a href="#8-2-1-前言" class="headerlink" title="8.2.1 前言"></a>8.2.1 前言</h3><p>::: warning<br>阅读以下内容之前先了解一下，<a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/hooks-intro.html#motivation">hooks出现的动机</a>,同时也要熟悉hooks的用法，可以参考上一篇文章；看完<code>useState</code>、<code>useEffect</code>源码，我相信你已经基本掌握了hooks；其它的很简单。<br>:::</p><p>废话不多说，我首先克隆一份代码下来</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --branch v17.0.2 https://github.com/facebook/react.git</span><br></pre></td></tr></table></figure><p>hooks导出部分在<code>react/packages/react/src/ReactHooks.js</code>，虽然在react导出，但是真正实现在<code>react-reconciler</code>这个包里面。</p><p>前置知识点:</p><ol><li>fiber</li></ol><p>Fiber是一种数据结构，React使用链表把VirtualDOM节点表示一个Fiber，Fiber是一个执行单元，每次执行完一个执行单元，React会检查现在还剩多少时间，如果没有时间就将控制权让出去，去执行一些高优先级的任务。</p><ol start="2"><li>循环链表</li></ol><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="~@/react/hooksupdate.png"></p><ul><li>是一种链式存储结构，整个链表形成一个环</li><li>它的特点是最后一个节点的指针指向头节点</li></ul><p>读源码，我们逐个击破的方式:</p><ol><li><p>useState</p></li><li><p>useEffect</p></li><li><p>useRef</p></li><li><p>useCallback</p></li><li><p>useMemo</p></li></ol><p><code>hooks不是一个新api也不是一个黑魔法，就是单纯的一个数组，看下面的例子hooks api返回一个数组，一个是当前值，一个是设置当前值的函数。</code></p><h4 id="hooks中的useState"><a href="#hooks中的useState" class="headerlink" title="hooks中的useState"></a>hooks中的useState</h4><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React ,&#123;useState&#125;<span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [name,setName]=useState(<span class="string">&#x27;王艺瑾&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">             <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">             <span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span> setName(&#x27;张艺凡&#x27;)&#125;</span></span><br><span class="line"><span class="xml">               &gt;切换<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">           <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">       );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><ul><li><p>上边是一个非常简单的Hook API，创建了name和setName，在页面上展示name，按钮的点击事件修改name</p></li><li><p>那么在这个过程中setState是如何实现的呢？</p></li></ul><h4 id="react-包中导出的useState"><a href="#react-包中导出的useState" class="headerlink" title="react 包中导出的useState"></a>react 包中导出的useState</h4><p>源码出处：<code>react/packages/react/src/ReactHooks.js</code></p><p>react包中导出的usesate，其实没什么东西，大致看一下就能明白</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useState</span>&lt;<span class="title">S</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  initialState: (() =&gt; S) | S, <span class="comment">// flow类型注解</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dispatcher = resolveDispatcher();</span><br><span class="line">  <span class="keyword">return</span> dispatcher.useState(initialState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>ReactHooks.js</code>搜索到了useState，函数里先执行了<code>resolveDispatcher</code>,我们先看看resolveDispatcher函数做了写什么？<br><code>resolveDispatcher</code>函数的执行，获取了<code>ReactCurrentDispatcher</code>的current，那我们在看看<code>ReactCurrentDispatcher</code>是什么？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveDispatcher</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dispatcher = ReactCurrentDispatcher.current;</span><br><span class="line">  invariant(</span><br><span class="line">    dispatcher !== <span class="literal">null</span>,</span><br><span class="line">    <span class="string">&#x27;Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27; one of the following reasons:\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;1. You might have mismatching versions of React and the renderer (such as React DOM)\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;2. You might be breaking the Rules of Hooks\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;3. You might have more than one copy of React in the same app\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.&#x27;</span>,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> dispatcher;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码出处：<code>react/packages/react/src/ReactCurrentDispatcher.js</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Keeps track of the current dispatcher.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> ReactCurrentDispatcher = &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@internal</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@type <span class="type">&#123;ReactComponent&#125;</span></span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">current</span>: (<span class="literal">null</span>: <span class="literal">null</span> | Dispatcher),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ReactCurrentDispatcher;</span><br></pre></td></tr></table></figure><p><code>ReactCurrentDispatcher</code>现在是null，到这里我们线索好像中断了，因为current要有个hooks方法才行；我们可以断点的形式，去看看在mount阶段，react执行了什么？也就是在mount阶段ReactCurrentDispatcher.current挂载的hooks，蓝色部分就是react在初始化阶段执行的函数</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="~@/react/Hooksprinciple.png"></p><p><font color="red">下面才是正文，千万不要放弃</font></p><p>源码出处：<code>react/packages/react-reconciler/src/ReactFiberHooks.new.js</code></p><p>renderWithHooks</p><ul><li>为什么从renderWithhooks讲起？</li></ul><p>因为<code>renderWithhooks</code>是调用函数组件的主要函数，所有的函数组件执行，都会执行这个方法。</p><p>下面我说的<code>hooks</code>代表组件中的hooks，例如：useState；<code>hook对象</code>是每次执行<code>hooks</code>所创建的对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 挂载和更新页面的时候，用的是不同的hooks，hooks在不同的阶段有不同的实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  举个例子，页面在初始化阶段我们在页面中调用的useSate实际调用的是mountState，</span></span><br><span class="line"><span class="comment">  在更新阶段调用的是updateState；其他的hooks也是同理</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> HooksDispatcherOnMount = &#123; <span class="comment">// 存储初次挂载的hook</span></span><br><span class="line">    <span class="attr">useState</span>: mountState,</span><br><span class="line">    <span class="attr">useEffect</span>:mountEffect</span><br><span class="line">     ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> HooksDispatcherOnUpdate = &#123; <span class="comment">// 存储更新时候的hook</span></span><br><span class="line">     <span class="attr">useState</span>: updateState,</span><br><span class="line">     <span class="attr">useEffect</span>:updateEffect</span><br><span class="line">     ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> currentlyRenderingFiber; <span class="comment">//当前正在使用的fiber</span></span><br><span class="line"><span class="keyword">let</span> workInProgressHook = <span class="literal">null</span> <span class="comment">// 存储当前最新的hook，跟链表有关系，往下看会明白</span></span><br><span class="line"><span class="keyword">let</span> currentHook=<span class="literal">null</span> <span class="comment">// 在组件更新阶段对应是老的hook</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>current 上一个fiber 初次挂载 的时候null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>workInProgress 这一次正在构建中的fiber树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>Component 当前组件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">renderWithHooks</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  current, </span></span></span><br><span class="line"><span class="params"><span class="function">  workInProgress, </span></span></span><br><span class="line"><span class="params"><span class="function">  Component,</span></span></span><br><span class="line"><span class="params"><span class="function">  props,</span></span></span><br><span class="line"><span class="params"><span class="function">  secondArg,</span></span></span><br><span class="line"><span class="params"><span class="function">  </span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// currentlyRenderingFiber指向本次要构建的fiber（workInProgress）</span></span><br><span class="line">   <span class="comment">// 要区分一下workInProgress和workInProgressHook，不要搞混了</span></span><br><span class="line">    currentlyRenderingFiber = workInProgress; </span><br><span class="line"></span><br><span class="line">   <span class="comment">//在执行组件方法之前，要清空hook链表 因为你肯定要创建新的hook链表，要把新的信息挂载到这2个属性上</span></span><br><span class="line">   <span class="comment">//在函数组件中 memoizedState以链表的形式存放hook信息，如果在class组件中，memoizedState存放state信息</span></span><br><span class="line">    workInProgress.memoizedState = <span class="literal">null</span>;</span><br><span class="line">   <span class="comment">// updateQueue存 effect对象，阅读完useEffect源码就会明白</span></span><br><span class="line">    workInProgress.updateQueue = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// current === null || current.memoizedState === null 说明是mount阶段，否则是update阶段</span></span><br><span class="line">    <span class="comment">// 我们就在这里给ReactCurrentDispatcher.current赋值了</span></span><br><span class="line">     ReactCurrentDispatcher.current =</span><br><span class="line">      current === <span class="literal">null</span> || current.memoizedState === <span class="literal">null</span></span><br><span class="line">        ? HooksDispatcherOnMount</span><br><span class="line">        : HooksDispatcherOnUpdate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用我们的组件函数，然后我们组件里的hooks才会被依次执行</span></span><br><span class="line">    <span class="keyword">let</span> children = Component(props,secondArg); </span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    我们的hooks必须写在组件函数的内部，当上面组件里的hooks执行完后，</span></span><br><span class="line"><span class="comment">    我们又给ReactCurrentDispatcher.current赋值了，ContextOnlyDispatcher会报错的形式提示，hooks不能函数外面；</span></span><br><span class="line"><span class="comment">    在不同的阶段赋值不同的hooks对象，判断hooks执行是否在函数组件内部</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    ReactCurrentDispatcher.current = ContextOnlyDispatcher;</span><br><span class="line"></span><br><span class="line">    currentlyRenderingFiber = <span class="literal">null</span>;<span class="comment">//渲染结束 后把currentlyRenderingFiber清空</span></span><br><span class="line">    workInProgressHook = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 指向当前调度的hooks节点,主要用于update阶段</span></span><br><span class="line">    currentHook = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> children;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不在函数内写的hooks指向的函数</span></span><br><span class="line"><span class="keyword">const</span> ContextOnlyDispatcher = &#123;</span><br><span class="line">    <span class="attr">useState</span>:throwInvalidHookError</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throwInvalidHookError</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  invariant(</span><br><span class="line">    <span class="literal">false</span>,</span><br><span class="line">    <span class="string">&#x27;Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27; one of the following reasons:\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;1. You might have mismatching versions of React and the renderer (such as React DOM)\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;2. You might be breaking the Rules of Hooks\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;3. You might have more than one copy of React in the same app\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;See https://fb.me/react-invalid-hook-call for tips about how to debug and fix this problem.&#x27;</span>,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>renderWithHooks主要做的事情：</p><ol><li>判断是mount阶段还是update阶段给ReactCurrentDispatcher.current赋值。</li><li>执行组件函数，执行hooks。</li><li>清空在执行hooks所赋值的全局对象，下一次更新函数需要再次用到。</li></ol><ul><li><p>有几个memoizedState，需要注意：</p><ol><li><code>currentlyRenderingFiber.memoizedState</code> 是存整个链表，就是每次执行hooks就会创建hook对象，多个hooks所形成的链表。</li><li><code>hook.memoizedState</code> 用于存当前执行的hooks的一些信息。</li></ol></li><li><p>workInProgress和workInProgressHook：</p><ol><li><code>workInProgress</code> 正在构建的fiber</li><li><code>workInProgressHook</code> 正在构建的hook对象</li></ol></li><li><p>currentHook和workInProgressHook</p><ol><li><code>currentHook</code>主要用于更新阶段，在mount阶段创建了hook对象，在更新阶段我们需要取出来，需要复用上一次存的信息，<code>currentHook</code>就是正在执行的这个hooks上一次存的信息。</li><li><code>workInProgressHook</code>正在创建的hook对象，在mount和update阶段都会创建。</li></ol></li></ul><ul><li><p>current：初始化阶段为null，当第一次渲染之后会产生一个fiber树，最终会换成真实的dom树</p></li><li><p>workInProgress：正在构建的fiber树，更新过程中会从current赋值给workInProgress，更新完毕后将当前的<br>workInProgress树赋值给current。</p></li></ul><h3 id="8-2-2-useState"><a href="#8-2-2-useState" class="headerlink" title="8.2.2 useState"></a>8.2.2 useState</h3><h4 id="tomato-mount阶段"><a href="#tomato-mount阶段" class="headerlink" title=":tomato: mount阶段 "></a>:tomato: mount阶段<badge text="重要"></badge></h4><h4 id="1-mountState"><a href="#1-mountState" class="headerlink" title="1. mountState"></a>1. mountState</h4><p>初次挂载的时候，useState对应的函数是mountState</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">basicStateReducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> action === <span class="string">&#x27;function&#x27;</span> ? action(state) : action;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountState</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  initialState</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 返回当前正在运行的hook对象,构建hook单项链表，下面会详细讲解</span></span><br><span class="line">  <span class="keyword">const</span> hook = mountWorkInProgressHook();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     初始值如果是函数，就执行函数拿到初始值</span></span><br><span class="line"><span class="comment">     useState((preState)=&gt; return &#x27;初始值&#x27;)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> initialState === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    initialState = initialState();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 把初始值赋值给 hook.baseState和hook.memoizedState</span></span><br><span class="line">  hook.memoizedState = hook.baseState = initialState;</span><br><span class="line"> <span class="comment">// 定义一个队列</span></span><br><span class="line">  <span class="keyword">const</span> queue = (hook.queue = &#123;</span><br><span class="line">    <span class="attr">pending</span>: <span class="literal">null</span>, <span class="comment">// 存放update对象</span></span><br><span class="line">    <span class="attr">dispatch</span>: <span class="literal">null</span>,  <span class="comment">// 放hooks更新函数</span></span><br><span class="line">    <span class="attr">lastRenderedReducer</span>: basicStateReducer, <span class="comment">//它是一个函数， 用于得到最新的 state</span></span><br><span class="line">    <span class="attr">lastRenderedState</span>: initialState,  <span class="comment">// 最后一次得到的 state</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">  dispatchAction 是负责更新的函数,就是代表下面的setState函数</span></span><br><span class="line"><span class="comment">  const [state,setState]=useState()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="keyword">const</span> dispatch = (queue.dispatch = (dispatchAction.bind(</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    currentlyRenderingFiber,</span><br><span class="line">    queue,</span><br><span class="line">  )));</span><br><span class="line"></span><br><span class="line"> <span class="comment">//  2个值以数值的形式返回</span></span><br><span class="line">  <span class="keyword">return</span> [hook.memoizedState, dispatch];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mountState主要做的事情：</p><ol><li>创建hook对象，在上面存上hooks信息，下次更新的时候可以从对象上获取。</li><li>返回一个数组，包括初始化的值和更新函数<h4 id="2-mountWorkInProgressHook"><a href="#2-mountWorkInProgressHook" class="headerlink" title="2. mountWorkInProgressHook"></a>2. mountWorkInProgressHook</h4></li></ol><p>构建hooks单向链表，将组件中的hooks函数以链表的形式串连起来，并赋值给workInProgress的memoizedState；</p><p>例子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">work</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [name,setName]=useState(<span class="string">&#x27;h&#x27;</span>) <span class="comment">// hooks1</span></span><br><span class="line">  <span class="keyword">const</span> age=useRef(<span class="number">20</span>) <span class="comment">// hooks2</span></span><br><span class="line">   useEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;,[]) <span class="comment">// hooks3</span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 构建单向链表</span></span><br><span class="line"> currentlyRenderingFiber.memoizedState=&#123;</span><br><span class="line">   <span class="attr">memoizedState</span>:<span class="string">&#x27;h&#x27;</span>,</span><br><span class="line">   <span class="attr">next</span>:&#123;</span><br><span class="line">      <span class="attr">memoizedState</span>:<span class="string">&#x27;20&#x27;</span>,</span><br><span class="line">      <span class="attr">next</span>:&#123;</span><br><span class="line">          <span class="attr">memoizedState</span>:effect,</span><br><span class="line">          <span class="attr">next</span>:<span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// hooks1的next指向hooks2，hooks2的next指向hooks3</span></span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="~@/react/mountLinkedlist.png"></p><p>为什么构建一个单向链表？</p><p>因为我们在组件更新阶段，需要拿到上次的值，拿到上次的值与本次设置的值做对比来判断是否更新</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountWorkInProgressHook</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//创建一个hooks对象</span></span><br><span class="line">  <span class="keyword">const</span> hook  = &#123; </span><br><span class="line">    <span class="attr">memoizedState</span>: <span class="literal">null</span>, <span class="comment">// useState中保存state信息，useEffect中保存Effect对象，useMemo中保存缓存的值和依赖；useRef保存的是ref对象</span></span><br><span class="line">    <span class="attr">baseState</span>: <span class="literal">null</span>, <span class="comment">// useState和useReducer中保存最新的state</span></span><br><span class="line">    <span class="attr">baseQueue</span>: <span class="literal">null</span>,<span class="comment">// useState和useReducer中保存最新的更新队列</span></span><br><span class="line">    <span class="attr">queue</span>: <span class="literal">null</span>, <span class="comment">// 自己的更新队列，形成环状链表</span></span><br><span class="line">    <span class="attr">next</span>: <span class="literal">null</span>, <span class="comment">// 下一个更新，就是我们下的页面中下一个hooks</span></span><br><span class="line">  &#125;;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (workInProgressHook === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//说明这是我们的第一个hook</span></span><br><span class="line">        currentlyRenderingFiber.memoizedState = workInProgressHook = hook;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 说明函数组件中不止一个hooks</span></span><br><span class="line">        workInProgressHook = workInProgressHook.next = hook;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workInProgressHook;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上面构建hooks单向链表没有看懂，请看下面解析</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (workInProgressHook === <span class="literal">null</span>) &#123;</span><br><span class="line">   <span class="comment">//说明这是我们的第一个hook</span></span><br><span class="line">     currentlyRenderingFiber.memoizedState = workInProgressHook = hook;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// 说明函数组件中不止一个hooks</span></span><br><span class="line">     workInProgressHook = workInProgressHook.next = hook;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>第一次我们创建了hook对象，在堆内存中开辟了一块空间， <code>currentlyRenderingFiber.memoizedState</code>、<code>workInProgressHook</code>都指向了这个值，对象是引用类型值；我们称这个值为hooks1吧。</li></ol><p>currentlyRenderingFiber.memoizedState = hooks1</p><ol start="2"><li>第二次我们再次创建了hook对象，在堆内存中又开辟了一块空间，我们称这个值为hooks2吧，<code>workInProgressHook.next</code>指向了hooks2，也就是hooks1.next指向了hook2；因为当前的<code>workInProgressHook</code>和hooks1指向同一个地址，只要有一个修改内存里的值，其他变量只要引用该值了，也会随之发生变化；最后又把hooks2又赋值给<code>workInProgressHook</code>，那么<code>workInProgressHook</code>又指向了hooks2。</li></ol><p>hooks1.next= hooks2</p><p>workInProgressHook=hooks2</p><ol start="3"><li>第三次我们再次创建了hook对象，在堆内存中又开辟了一块空间，我们称这个值为hooks3吧，hooks3又赋值给了<code>workInProgressHook.next</code>，现在的workInProgressHook和hooks2指向是同一个地址，那么我改变<code>workInProgressHook.next</code>就是改变hooks2的next。</li></ol><p>hooks2.next= hooks3</p><p>workInProgressHook=hooks3</p><p>workInProgressHook始终和最新hook对象指向同一个地址，这样就方便修改上一个hook对象的next</p><h4 id="3-dispatchAction"><a href="#3-dispatchAction" class="headerlink" title="3. dispatchAction"></a>3. dispatchAction</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>fiber 当前正在使用的fiber</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>queue 队列的初始对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>action 更新函数或者要更新的值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchAction</span>(<span class="params">fiber, queue, action</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个update对象</span></span><br><span class="line"> <span class="keyword">const</span> update= &#123;</span><br><span class="line">    action,</span><br><span class="line">    <span class="attr">eagerReducer</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">eagerState</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">next</span>: <span class="literal">null</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> pending = queue.pending;</span><br><span class="line">  <span class="keyword">if</span> (pending === <span class="literal">null</span>) &#123;  <span class="comment">// 证明第一次更新</span></span><br><span class="line">    update.next = update;<span class="comment">//让自己和自己构建成一个环状链表</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不是第一次更新</span></span><br><span class="line">    update.next = pending.next;</span><br><span class="line">    pending.next = update;</span><br><span class="line">  &#125;</span><br><span class="line">  queue.pending = update;</span><br><span class="line"><span class="comment">// queue.pending`永远指向最后一个更新，pending.next 永远指向第一个更新</span></span><br><span class="line">  <span class="keyword">const</span> currentState = queue.lastRenderedState;<span class="comment">// 上一次的state</span></span><br><span class="line">  <span class="keyword">const</span> eagerState = lastRenderedReducer(currentState, action);<span class="comment">//获取最新的state</span></span><br><span class="line"></span><br><span class="line">  update.eagerState = eagerState; </span><br><span class="line">  <span class="comment">// 判断上一次的值和当前的值是否一样，是同一个值或同一个引用就return，不进行更新</span></span><br><span class="line">  <span class="keyword">if</span> (is(eagerState, currentState)) &#123; </span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调度渲染当前fiber，scheduleUpdateOnFiber是react渲染更新的主要函数。</span></span><br><span class="line">  scheduleUpdateOnFiber(fiber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类组件更新调用<code>setState</code>,函数组件hooks更新调用<code>dispatchAction</code>,都会产生一个update对象，里面记录此处更新的信息；<br>把update对象放在<code>queue.pending</code>上。</p><p>为什么创建update对象？</p><p>每次创建update对象，是希望形成一个环状链表。我们看下面一个例子，三次setCount的update对象会暂时放在<code>queue.pending</code>上，组件里的state不会立即更新，在下一次函数组件执行的时候，三次update会被合并到baseQueue上，我们要获取最新的状态，会一次执行update上的每一个action，得到最新的state。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">work</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count,setCount]=useState(<span class="number">0</span>) </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    setCount(<span class="number">1</span>)</span><br><span class="line">    setCount(<span class="number">2</span>)</span><br><span class="line">    setCount(<span class="number">3</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;add&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么不是直接执行最后一个setCount？</p><p>如果<code>setCount((state)=&gt;&#123;state+1&#125;)</code>参数是函数，那么需要依赖state，下一个要依赖上一个的state；所以需要都执行一遍才能<br>拿到准确的值。</p><h4 id="tomato-update阶段"><a href="#tomato-update阶段" class="headerlink" title=":tomato: update阶段 "></a>:tomato: update阶段<badge text="重要"></badge></h4><h4 id="1-updateState"><a href="#1-updateState" class="headerlink" title="1.updateState"></a>1.updateState</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">basicStateReducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// $FlowFixMe: Flow doesn&#x27;t like mixed types</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> action === <span class="string">&#x27;function&#x27;</span> ? action(state) : action;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以看出updateState其实调用的是updateReducer</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateState</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  initialState</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> updateReducer(basicStateReducer, initialState);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateReducer</span>(<span class="params">reducer, initialArg</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> hook = updateWorkInProgressHook(); <span class="comment">// 构建新的链表</span></span><br><span class="line">    <span class="keyword">const</span> queue = hook.queue;<span class="comment">//hooks自己的更新队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// lastRenderedReducer用于得到最新state，它是一个函数</span></span><br><span class="line">    queue.lastRenderedReducer = reducer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// currentHook记录了当前这个hooks上一次存在链表上的memoizedState、queue、next等信息</span></span><br><span class="line">    <span class="keyword">const</span> current = currentHook;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// pendingQueue就是更新队列的最后一个update对象</span></span><br><span class="line">    <span class="keyword">const</span> pendingQueue  = queue.pending;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pendingQueue!==<span class="literal">null</span>)&#123;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">let</span> first = pendingQueue.next;<span class="comment">//第一个更新对象</span></span><br><span class="line">        <span class="keyword">let</span> newState = current.memoizedState;<span class="comment">//拿到老状态</span></span><br><span class="line">        <span class="keyword">let</span> update = first;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> action = update.action;<span class="comment">//action：就是传的参数，例如setState(&#x27;参数&#x27;)</span></span><br><span class="line">            newState = reducer(newState,action);<span class="comment">//计算新状态，因为如果传的是函数，要依赖老状态</span></span><br><span class="line">            update = update.next;</span><br><span class="line">        &#125;<span class="keyword">while</span>(update !== <span class="literal">null</span> &amp;&amp; update !== first);</span><br><span class="line"></span><br><span class="line">        queue.pending = <span class="literal">null</span>;<span class="comment">//更新过了可以清空更新环形链表</span></span><br><span class="line">        hook.memoizedState =  newState;<span class="comment">//让新的hook对象的memoizedState等于计算的新状态    </span></span><br><span class="line">        queue.lastRenderedState = newState;<span class="comment">//把新状态也赋值给lastRenderedState一份</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> dispatch = dispatchAction.bind(<span class="literal">null</span>, currentlyRenderingFiber, queue);</span><br><span class="line">    <span class="keyword">return</span> [hook.memoizedState, dispatch];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-updateWorkInProgressHook"><a href="#2-updateWorkInProgressHook" class="headerlink" title="2. updateWorkInProgressHook"></a>2. updateWorkInProgressHook</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateWorkInProgressHook</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> nextCurrentHook;</span><br><span class="line">   <span class="comment">//currentHook为null，说明执行的是第一个hooks；currentHook就是老的hook对象</span></span><br><span class="line">    <span class="keyword">if</span>(currentHook === <span class="literal">null</span>)&#123;</span><br><span class="line">       <span class="comment">// current:老的fiber、workInProgress:正在构建的fiber</span></span><br><span class="line">      <span class="keyword">let</span> current = currentlyRenderingFiber.alternate;<span class="comment">//alternate属性 对应的是老的fiBer</span></span><br><span class="line">      <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 老的fiber的memoizedState对应的是链表的第一个节点</span></span><br><span class="line">        nextCurrentHook = current.memoizedState;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nextCurrentHook = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">// 不是第一个hooks，那么指向下一个 hooks</span></span><br><span class="line">        nextCurrentHook=currentHook.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    currentHook=nextCurrentHook;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建新的hook对象</span></span><br><span class="line">    <span class="keyword">const</span> newHook = &#123;</span><br><span class="line">        <span class="attr">memoizedState</span>:currentHook.memoizedState,</span><br><span class="line">        <span class="attr">queue</span>:currentHook.queue,</span><br><span class="line">        <span class="attr">next</span>:<span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新链表</span></span><br><span class="line">    <span class="keyword">if</span>(workInProgressHook === <span class="literal">null</span>)&#123;</span><br><span class="line">        currentlyRenderingFiber.memoizedState = workInProgressHook = newHook;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       workInProgressHook = workInProgressHook.next = newHook;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> workInProgressHook;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-3-useEffect"><a href="#8-2-3-useEffect" class="headerlink" title="8.2.3 useEffect"></a>8.2.3 useEffect</h3><h4 id="tomato-mount阶段-1"><a href="#tomato-mount阶段-1" class="headerlink" title=":tomato: mount阶段 "></a>:tomato: mount阶段<badge text="重要"></badge></h4><h4 id="1-mountEffect"><a href="#1-mountEffect" class="headerlink" title="1.  mountEffect"></a>1. mountEffect</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;function&#125;</span> <span class="variable">create</span></span> - 回调函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> <span class="variable">deps</span></span> - 依赖数组</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> PassiveEffect = <span class="number">0b000000001000000000</span>; <span class="comment">// useEffect</span></span><br><span class="line"> <span class="keyword">const</span> PassiveStaticEffect = <span class="number">0b001000000000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountEffect</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  create,</span></span></span><br><span class="line"><span class="params"><span class="function">  deps,</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//  如果在代码中看见 __DEV__，可以不用关心，开发环境才会执行里面的代码，生产会tree shaking</span></span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;&#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mountEffectImpl(</span><br><span class="line">      PassiveEffect | PassiveStaticEffect, <span class="comment">// 按位操作</span></span><br><span class="line">      HookPassive,</span><br><span class="line">      create,</span><br><span class="line">      deps,</span><br><span class="line">    );</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-mountEffectImpl"><a href="#2-mountEffectImpl" class="headerlink" title="2. mountEffectImpl"></a>2. mountEffectImpl</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 位操作 ：| 、&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> HookHasEffect= <span class="number">0b001</span>;</span><br><span class="line"> hookFlags = <span class="number">0b100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountEffectImpl</span>(<span class="params">fiberFlags, hookFlags, create, deps</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = mountWorkInProgressHook(); <span class="comment">// 构建单向链表</span></span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  currentlyRenderingFiber.flags |= fiberFlags;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    每个hooks都会创建个hook对象，memoizedState在useState中保存的是state</span></span><br><span class="line"><span class="comment">    在useEffect中保存的effect对象</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  hook.memoizedState = pushEffect(</span><br><span class="line">    HookHasEffect | hookFlags,</span><br><span class="line">    create,</span><br><span class="line">    <span class="literal">undefined</span>,</span><br><span class="line">    nextDeps,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-pushEffect"><a href="#3-pushEffect" class="headerlink" title="3. pushEffect"></a>3. pushEffect</h4><p>pushEffect 创建effec对象，并形成环状链表存值与updateQueue上</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctionComponentUpdateQueue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">lastEffect</span>: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pushEffect</span>(<span class="params">tag, create, destroy, deps</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建effect对象</span></span><br><span class="line">  <span class="keyword">const</span> effect = &#123;</span><br><span class="line">    tag,</span><br><span class="line">    create,</span><br><span class="line">    destroy,</span><br><span class="line">    deps,</span><br><span class="line">    <span class="attr">next</span>:<span class="literal">null</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> componentUpdateQueue = currentlyRenderingFiber.updateQueue;</span><br><span class="line">  <span class="comment">// 第一个useEffect</span></span><br><span class="line">  <span class="keyword">if</span> (componentUpdateQueue === <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="comment">// componentUpdateQueue : &#123;lastEffect:null&#125;</span></span><br><span class="line">    componentUpdateQueue = createFunctionComponentUpdateQueue();</span><br><span class="line"></span><br><span class="line">    currentlyRenderingFiber.updateQueue =  componentUpdateQueue</span><br><span class="line">      <span class="comment">// effect 赋值给effect.next；它们指向了内存中同一个地址</span></span><br><span class="line">      <span class="comment">// componentUpdateQueue.lastEffect指向effect 也就是componentUpdateQueue.updateQueue.lastEffect指向了 Effect</span></span><br><span class="line">    componentUpdateQueue.lastEffect = effect.next = effect;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 存在多个useEffect</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// componentUpdateQueue.lastEffect 就是上一个Effect对象</span></span><br><span class="line">      <span class="keyword">const</span> lastEffect = componentUpdateQueue.lastEffect; </span><br><span class="line">      <span class="keyword">const</span> firstEffect = lastEffect.next; </span><br><span class="line">      lastEffect.next = effect;</span><br><span class="line">      effect.next = firstEffect;</span><br><span class="line">      componentUpdateQueue.lastEffect = effect;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> effect;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// componentUpdateQueue.lastEffect 永远指向最新的</span></span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="~@/react/effect.png"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">useEffect(<span class="function">()=&gt;</span>&#123;consoe.log(<span class="number">1</span>)&#125;,[])</span><br><span class="line">useEffect(<span class="function">()=&gt;</span>&#123;consoe.log(<span class="number">2</span>)&#125;,[])</span><br><span class="line">useEffect(<span class="function">()=&gt;</span>&#123;consoe.log(<span class="number">3</span>)&#125;,[])</span><br><span class="line"><span class="comment">// 执行第一个effect</span></span><br><span class="line"><span class="keyword">const</span> effect1=&#123;</span><br><span class="line">  <span class="attr">create</span>:<span class="function">()=&gt;</span>&#123;consoe.log(<span class="number">1</span>)&#125;,</span><br><span class="line">  <span class="attr">deps</span>:[]</span><br><span class="line">  <span class="attr">next</span>:effect1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行第二个effect</span></span><br><span class="line"><span class="keyword">const</span> effect1=&#123;</span><br><span class="line">  <span class="attr">create</span>:<span class="function">()=&gt;</span>&#123;consoe.log(<span class="number">1</span>)&#125;,</span><br><span class="line">  <span class="attr">deps</span>:[]</span><br><span class="line">  <span class="attr">next</span>:effect2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> effect2=&#123;</span><br><span class="line">  <span class="attr">create</span>:<span class="function">()=&gt;</span>&#123;consoe.log(<span class="number">1</span>)&#125;,</span><br><span class="line">  <span class="attr">deps</span>:[]</span><br><span class="line">  <span class="attr">next</span>:effect1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行第三个effect</span></span><br><span class="line"><span class="keyword">const</span> effect2=&#123;</span><br><span class="line">  <span class="attr">create</span>:<span class="function">()=&gt;</span>&#123;consoe.log(<span class="number">1</span>),</span><br><span class="line">  <span class="attr">deps</span>:[]</span><br><span class="line">  <span class="attr">next</span>:effect3</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> effect3=&#123;</span><br><span class="line">  <span class="attr">create</span>:<span class="function">()=&gt;</span>&#123;consoe.log(<span class="number">1</span>),</span><br><span class="line">  <span class="attr">deps</span>:[]</span><br><span class="line">  <span class="attr">next</span>:effect1  <span class="comment">// effect1指向的是effect2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="tomato-update阶段-1"><a href="#tomato-update阶段-1" class="headerlink" title=":tomato: update阶段 "></a>:tomato: update阶段<badge text="重要"></badge></h4><h4 id="1-updateEffect"><a href="#1-updateEffect" class="headerlink" title="1. updateEffect"></a>1. updateEffect</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateEffect</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  create,</span></span></span><br><span class="line"><span class="params"><span class="function">  deps,</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> updateEffectImpl(PassiveEffect, HookPassive, create, deps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-updateEffectImpl"><a href="#2-updateEffectImpl" class="headerlink" title="2. updateEffectImpl"></a>2. updateEffectImpl</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">areHookInputsEqual</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  nextDeps,</span></span></span><br><span class="line"><span class="params"><span class="function">  prevDeps,</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; prevDeps.length &amp;&amp; i &lt; nextDeps.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is(nextDeps[i], prevDeps[i])) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateEffectImpl</span>(<span class="params">fiberFlags, hookFlags, create, deps</span>) </span>&#123;</span><br><span class="line"><span class="comment">// updateWorkInProgressHook可以往上看，就是创建新的hook对象，不过会复用上一次存的一些信息</span></span><br><span class="line">  <span class="keyword">const</span> hook = updateWorkInProgressHook();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="keyword">let</span> destroy = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// currentHook 可以说是老的hook</span></span><br><span class="line">  <span class="keyword">if</span> (currentHook !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 拿到上一次存的effect对象</span></span><br><span class="line">    <span class="keyword">const</span> prevEffect = currentHook.memoizedState;</span><br><span class="line">    destroy = prevEffect.destroy;</span><br><span class="line">    <span class="keyword">if</span> (nextDeps !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> prevDeps = prevEffect.deps;</span><br><span class="line">      <span class="comment">// 对比依赖对象，是否发生更新，没有更新就复用nextDeps</span></span><br><span class="line">      <span class="keyword">if</span> (areHookInputsEqual(nextDeps, prevDeps)) &#123;</span><br><span class="line">        pushEffect(hookFlags, create, destroy, nextDeps);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  currentlyRenderingFiber.flags |= fiberFlags;</span><br><span class="line"><span class="comment">// deps里发生更新，就创建新的effect对象</span></span><br><span class="line">  hook.memoizedState = pushEffect(</span><br><span class="line">    HookHasEffect | hookFlags,</span><br><span class="line">    create,</span><br><span class="line">    destroy,</span><br><span class="line">    nextDeps,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="8-2-3-useRef"><a href="#8-2-3-useRef" class="headerlink" title="8.2.3 useRef"></a>8.2.3 useRef</h3><h4 id="mountRef-mount阶段"><a href="#mountRef-mount阶段" class="headerlink" title="mountRef (mount阶段)"></a>mountRef (mount阶段)</h4><p>看起来很简单，就是把initialValue 赋值给hook.memoizedState，<br>所以说只要弄懂useState、useEffect ，其他的看一眼就明白</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;any&#125;</span> <span class="variable">initialValue</span></span> - 初始化值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountRef</span>(<span class="params">initialValue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = mountWorkInProgressHook();</span><br><span class="line">  <span class="keyword">const</span> ref =  initialValue;</span><br><span class="line">  hook.memoizedState = ref;</span><br><span class="line">  <span class="keyword">return</span> ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="updateRef-update阶段"><a href="#updateRef-update阶段" class="headerlink" title="updateRef (update阶段)"></a>updateRef (update阶段)</h4><p>拿到上一次的值并返回</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;any&#125;</span> <span class="variable">initialValue</span></span> - 初始化值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateRef</span>(<span class="params">initialValue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = mountWorkInProgressHook();</span><br><span class="line">  <span class="keyword">const</span> ref =  initialValue;</span><br><span class="line">  hook.memoizedState = ref;</span><br><span class="line">  <span class="keyword">return</span> ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-4-useCallback"><a href="#8-2-4-useCallback" class="headerlink" title="8.2.4 useCallback"></a>8.2.4 useCallback</h3><h4 id="mountCallback-mount阶段"><a href="#mountCallback-mount阶段" class="headerlink" title="mountCallback (mount阶段)"></a>mountCallback (mount阶段)</h4><p>把函数和依赖数组存到hook.memoizedState，并返回函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;function&#125;</span> <span class="variable">callback</span></span> - 函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> <span class="variable">deps</span></span> - 依赖数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;function&#125;</span> <span class="variable">callback</span></span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountCallback</span>(<span class="params">callback, deps</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = mountWorkInProgressHook();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  hook.memoizedState = [callback, nextDeps];</span><br><span class="line">  <span class="keyword">return</span> callback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="updateCallback-update阶段"><a href="#updateCallback-update阶段" class="headerlink" title="updateCallback  (update阶段)"></a>updateCallback (update阶段)</h4><p>对比依赖是否变化，变化就返回最新的函数，没有变化就返回上一个函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;function&#125;</span> <span class="variable">callback</span></span> - 函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> <span class="variable">deps</span></span> - 依赖数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;function&#125;</span> <span class="variable">callback</span></span></span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateCallback</span>(<span class="params">callback, deps</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = updateWorkInProgressHook();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="comment">// prevState：[callback, nextDeps]</span></span><br><span class="line">  <span class="keyword">const</span> prevState = hook.memoizedState;</span><br><span class="line">  <span class="keyword">if</span> (prevState !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextDeps !== <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> prevDeps = prevState[<span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span> (areHookInputsEqual(nextDeps, prevDeps)) &#123;</span><br><span class="line">        <span class="keyword">return</span> prevState[<span class="number">0</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  hook.memoizedState = [callback, nextDeps];</span><br><span class="line">  <span class="keyword">return</span> callback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-5-useMemo"><a href="#8-2-5-useMemo" class="headerlink" title="8.2.5 useMemo"></a>8.2.5 useMemo</h3><h4 id="mountMemo-mount阶段"><a href="#mountMemo-mount阶段" class="headerlink" title="mountMemo (mount阶段)"></a>mountMemo (mount阶段)</h4><p>调用传入函数拿到返回值，把值和依赖数组存到hook.memoizedState，并返回值</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;function&#125;</span> <span class="variable">nextCreate</span></span> - 函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> <span class="variable">deps</span></span> - 依赖数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;any&#125;</span> <span class="variable">nextValue</span></span></span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountMemo</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  nextCreate,</span></span></span><br><span class="line"><span class="params"><span class="function">  deps,</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = mountWorkInProgressHook();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="keyword">const</span> nextValue = nextCreate();</span><br><span class="line">  hook.memoizedState = [nextValue, nextDeps];</span><br><span class="line">  <span class="keyword">return</span> nextValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="updateMemo-update阶段"><a href="#updateMemo-update阶段" class="headerlink" title="updateMemo (update阶段)"></a>updateMemo (update阶段)</h4><p>对比依赖是否变化，变化就返回最新的值，没有变化就返回上一个值</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;function&#125;</span> <span class="variable">callback</span></span> - 函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> <span class="variable">deps</span></span> - 依赖数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;any&#125;</span> <span class="variable">nextValue</span></span></span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateMemo</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  nextCreate,</span></span></span><br><span class="line"><span class="params"><span class="function">  deps,</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = updateWorkInProgressHook();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="keyword">const</span> prevState = hook.memoizedState;</span><br><span class="line">  <span class="keyword">if</span> (prevState !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Assume these are defined. If they&#x27;re not, areHookInputsEqual will warn.</span></span><br><span class="line">    <span class="keyword">if</span> (nextDeps !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> prevDeps = prevState[<span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span> (areHookInputsEqual(nextDeps, prevDeps)) &#123;</span><br><span class="line">        <span class="keyword">return</span> prevState[<span class="number">0</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> nextValue = nextCreate();</span><br><span class="line">  hook.memoizedState = [nextValue, nextDeps];</span><br><span class="line">  <span class="keyword">return</span> nextValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-3-使用hooks会遇到的问题"><a href="#8-3-使用hooks会遇到的问题" class="headerlink" title="8.3 使用hooks会遇到的问题"></a>8.3 使用hooks会遇到的问题</h2><p><a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/hooks-faq.html">react hooks遇到的问题</a></p><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/92211533">React Hooks完全上手指南</a></p><p>在工程中必须引入lint插件，并开启相应规则，避免踩坑。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;plugins&quot;</span>: [<span class="string">&quot;react-hooks&quot;</span>],</span><br><span class="line">  <span class="string">&quot;rules&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;react-hooks/rules-of-hooks&quot;</span>: <span class="string">&quot;error&quot;</span>,</span><br><span class="line">    <span class="string">&quot;react-hooks/exhaustive-deps&quot;</span>: <span class="string">&quot;warn&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这2条规则，对于新手，这个过程可能是比较痛苦的，如果你觉得这2个规则对你编写代码造成了困扰，说明你还未完全掌握hooks，对于某写特殊场景，确实不需要「exhaustive-deps」，可在代码处加eslint-disable-next-line react-hooks/exhaustive-deps；切记只能禁止本处代码，不能偷懒把整个文件都禁了。</p><h3 id="8-3-1-useEffect相关问题"><a href="#8-3-1-useEffect相关问题" class="headerlink" title="8.3.1 useEffect相关问题"></a>8.3.1 useEffect相关问题</h3><ol><li>依赖变量问题</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ErrorDemo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> dom = useRef(<span class="literal">null</span>);</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    dom.current.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> setCount(count + <span class="number">1</span>));</span><br><span class="line">  &#125;, [count]);</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;dom&#125;</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><p>像这种情况，每次count变化都会重新绑定一次事件，那我们怎么解决呢？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ErrorDemo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> dom = useRef(<span class="literal">null</span>);</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    dom.current.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> setCount(count + <span class="number">1</span>));</span><br><span class="line">  &#125;, []);</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;dom&#125;</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><p>把依赖count变量去掉吗?如果把依赖去掉的话，意味着hooks只在组件挂载的时候运行一次，count的值永远不会超过1；因为在effect<br>执行时，我们会创建一个闭包，并将count的值保存在闭包当中，且初始值为0</p><h4 id="思路1-消除依赖"><a href="#思路1-消除依赖" class="headerlink" title="思路1:消除依赖"></a>思路1:消除依赖</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">// 在这不依赖于外部的 `count` 变量</span></span><br><span class="line">  dom.current.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> setCount(<span class="function">(<span class="params">precount</span>)=&gt;</span>++precount); </span><br><span class="line">&#125;, []) <span class="comment">// 我们的 effect 不使用组件作用域中的任何变量</span></span><br></pre></td></tr></table></figure><p>setCount也可以接收一个函数，这样就不用依赖count了</p><h4 id="思路1-重新绑定事件"><a href="#思路1-重新绑定事件" class="headerlink" title="思路1: 重新绑定事件"></a>思路1: 重新绑定事件</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> $dom = dom.current;</span><br><span class="line">  <span class="keyword">const</span> event = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setCount(count);</span><br><span class="line">  &#125;;</span><br><span class="line">  $dom.addEventListener(<span class="string">&#x27;click&#x27;</span>, event);</span><br><span class="line">  <span class="keyword">return</span>  $dom.removeEventListener(<span class="string">&#x27;click&#x27;</span>, event);</span><br><span class="line">&#125;, [count]);</span><br></pre></td></tr></table></figure><h4 id="思路2-ref"><a href="#思路2-ref" class="headerlink" title="思路2:ref"></a>思路2:ref</h4><p>你可以 使用一个 ref 来保存一个可变的变量。然后你就可以对它进行读写了</p><p>当你实在找不到更好的办法的时候，才这么做，因为依赖的变更使组件变的难以预测</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> dom = useRef(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">const</span> countRef=useRef(count)</span><br><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  countRef.current=count</span><br><span class="line">&#125;);</span><br><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">// 在任何时候读取最新的 count</span></span><br><span class="line">  dom.current.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> setCount(countRef.current + <span class="number">1</span>));</span><br><span class="line">&#125;, []); <span class="comment">// 这个 effect 从不会重新执行</span></span><br></pre></td></tr></table></figure><ol><li>依赖函数问题</li></ol><p>只有 当函数（以及它所调用的函数）不引用 props、state 以及由它们衍生而来的值时，你才能放心地把它们从依赖列表中省略。下面这个案例有一个 Bug：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ProductPage</span>(<span class="params">&#123; productId &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [product, setProduct] = useState(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchProduct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;http://myapi/product/&#x27;</span> + productId); <span class="comment">// 使用了 productId prop</span></span><br><span class="line">    <span class="keyword">const</span> json = <span class="keyword">await</span> response.json();</span><br><span class="line">    setProduct(json);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    fetchProduct();</span><br><span class="line">  &#125;, []); <span class="comment">// 🔴 这样是无效的，因为 `fetchProduct` 使用了 `productId`</span></span><br><span class="line">  <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h4 id="思路1-推荐的修复方案是把那个函数移动到你的-effect-内部"><a href="#思路1-推荐的修复方案是把那个函数移动到你的-effect-内部" class="headerlink" title="思路1:推荐的修复方案是把那个函数移动到你的 effect 内部"></a>思路1:推荐的修复方案是把那个函数移动到你的 effect 内部</h4><p>这样就能很容易的看出来你的 effect 使用了哪些 props 和 state，并确保它们都被声明了：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ProductPage</span>(<span class="params">&#123; productId &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [product, setProduct] = useState(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 把这个函数移动到 effect 内部后，我们可以清楚地看到它用到的值。</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchProduct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;http://myapi/product/&#x27;</span> + productId);</span><br><span class="line">      <span class="keyword">const</span> json = <span class="keyword">await</span> response.json();</span><br><span class="line">      setProduct(json);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fetchProduct();</span><br><span class="line">  &#125;, [productId]); <span class="comment">// ✅ 有效，因为我们的 effect 只用到了 productId</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路2-useCallback"><a href="#思路2-useCallback" class="headerlink" title="思路2: useCallback"></a>思路2: useCallback</h4><p>把函数加入 effect 的依赖但 把它的定义包裹 进 useCallback Hook。这就确保了它不随渲染而改变，除非 它自身 的依赖发生了改变</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ProductPage</span>(<span class="params">&#123; productId &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [product, setProduct] = useState(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> fetchProduct = useCallback(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;http://myapi/product/&#x27;</span> + productId); <span class="comment">// 使用了 productId prop</span></span><br><span class="line">    <span class="keyword">const</span> json = <span class="keyword">await</span> response.json();</span><br><span class="line">    setProduct(json);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;, [productId]); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    fetchProduct();</span><br><span class="line">  &#125;, [fetchProduct]); </span><br></pre></td></tr></table></figure></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/React/">React</a></div><div class="post_share"><div class="social-share" data-image="/img/cover/cover_10.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/file/donate.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/file/donate.png" alt="wechat"></a><div class="post-qr-code-desc">wechat</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/59814/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover_2.jpg" onerror='onerror=null,src="/img/404.png"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">React状态管理</div></div></a></div><div class="next-post pull-right"><a href="/59622/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover_10.jpg" onerror='onerror=null,src="/img/404.png"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">React原理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/10919/" title="步入React"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover_2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-08</div><div class="title">步入React</div></div></a></div><div><a href="/60006/" title="React正篇"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover_11.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-08</div><div class="title">React正篇</div></div></a></div><div><a href="/10279/" title="React生态"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover_10.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-08</div><div class="title">React生态</div></div></a></div><div><a href="/59622/" title="React原理"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover_10.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-08</div><div class="title">React原理</div></div></a></div><div><a href="/59815/" title="React高级实战"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover_9.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-08</div><div class="title">React高级实战</div></div></a></div><div><a href="/59814/" title="React状态管理"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover_2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-08</div><div class="title">React状态管理</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">总结整理前端知识点 \(￣︶￣*\))<br>持续更新中...<br>ヾ(•ω•`)o</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-React-hooks"><span class="toc-number">1.</span> <span class="toc-text">8.1 React-hooks</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-1-hooks%E4%BD%BF%E5%91%BD"><span class="toc-number">1.1.</span> <span class="toc-text">8.1.1 hooks使命</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E7%BB%84%E4%BB%B6%E5%A4%8D%E7%94%A8"><span class="toc-number">1.1.1.</span> <span class="toc-text">逻辑组件复用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hooks-%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.2.</span> <span class="toc-text">hooks 解决的问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-2-hooks%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.2.</span> <span class="toc-text">8.1.2 hooks实践</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Hook%E5%AE%98%E6%96%B9APi%EF%BC%88%E5%A4%A7%E6%A6%82%E7%8E%87%E7%94%A8%E5%88%B0%E7%9A%84%EF%BC%89"><span class="toc-number">1.2.1.</span> <span class="toc-text">Hook官方APi（大概率用到的）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-5%E6%89%A9%E5%B1%95%E8%B5%84%E6%96%99"><span class="toc-number">1.3.</span> <span class="toc-text">8.1.5扩展资料</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-React-hooks%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">8.2 React-hooks原理解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-1-%E5%89%8D%E8%A8%80"><span class="toc-number">2.1.</span> <span class="toc-text">8.2.1 前言</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#hooks%E4%B8%AD%E7%9A%84useState"><span class="toc-number">2.1.1.</span> <span class="toc-text">hooks中的useState</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#react-%E5%8C%85%E4%B8%AD%E5%AF%BC%E5%87%BA%E7%9A%84useState"><span class="toc-number">2.1.2.</span> <span class="toc-text">react 包中导出的useState</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-2-useState"><span class="toc-number">2.2.</span> <span class="toc-text">8.2.2 useState</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tomato-mount%E9%98%B6%E6%AE%B5"><span class="toc-number">2.2.1.</span> <span class="toc-text">:tomato: mount阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-mountState"><span class="toc-number">2.2.2.</span> <span class="toc-text">1. mountState</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-mountWorkInProgressHook"><span class="toc-number">2.2.3.</span> <span class="toc-text">2. mountWorkInProgressHook</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-dispatchAction"><span class="toc-number">2.2.4.</span> <span class="toc-text">3. dispatchAction</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tomato-update%E9%98%B6%E6%AE%B5"><span class="toc-number">2.2.5.</span> <span class="toc-text">:tomato: update阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-updateState"><span class="toc-number">2.2.6.</span> <span class="toc-text">1.updateState</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-updateWorkInProgressHook"><span class="toc-number">2.2.7.</span> <span class="toc-text">2. updateWorkInProgressHook</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-3-useEffect"><span class="toc-number">2.3.</span> <span class="toc-text">8.2.3 useEffect</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tomato-mount%E9%98%B6%E6%AE%B5-1"><span class="toc-number">2.3.1.</span> <span class="toc-text">:tomato: mount阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-mountEffect"><span class="toc-number">2.3.2.</span> <span class="toc-text">1. mountEffect</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-mountEffectImpl"><span class="toc-number">2.3.3.</span> <span class="toc-text">2. mountEffectImpl</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-pushEffect"><span class="toc-number">2.3.4.</span> <span class="toc-text">3. pushEffect</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tomato-update%E9%98%B6%E6%AE%B5-1"><span class="toc-number">2.3.5.</span> <span class="toc-text">:tomato: update阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-updateEffect"><span class="toc-number">2.3.6.</span> <span class="toc-text">1. updateEffect</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-updateEffectImpl"><span class="toc-number">2.3.7.</span> <span class="toc-text">2. updateEffectImpl</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-3-useRef"><span class="toc-number">2.4.</span> <span class="toc-text">8.2.3 useRef</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#mountRef-mount%E9%98%B6%E6%AE%B5"><span class="toc-number">2.4.1.</span> <span class="toc-text">mountRef (mount阶段)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#updateRef-update%E9%98%B6%E6%AE%B5"><span class="toc-number">2.4.2.</span> <span class="toc-text">updateRef (update阶段)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-4-useCallback"><span class="toc-number">2.5.</span> <span class="toc-text">8.2.4 useCallback</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#mountCallback-mount%E9%98%B6%E6%AE%B5"><span class="toc-number">2.5.1.</span> <span class="toc-text">mountCallback (mount阶段)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#updateCallback-update%E9%98%B6%E6%AE%B5"><span class="toc-number">2.5.2.</span> <span class="toc-text">updateCallback (update阶段)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-5-useMemo"><span class="toc-number">2.6.</span> <span class="toc-text">8.2.5 useMemo</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#mountMemo-mount%E9%98%B6%E6%AE%B5"><span class="toc-number">2.6.1.</span> <span class="toc-text">mountMemo (mount阶段)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#updateMemo-update%E9%98%B6%E6%AE%B5"><span class="toc-number">2.6.2.</span> <span class="toc-text">updateMemo (update阶段)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-%E4%BD%BF%E7%94%A8hooks%E4%BC%9A%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">3.</span> <span class="toc-text">8.3 使用hooks会遇到的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-1-useEffect%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"><span class="toc-number">3.1.</span> <span class="toc-text">8.3.1 useEffect相关问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-%E6%B6%88%E9%99%A4%E4%BE%9D%E8%B5%96"><span class="toc-number">3.1.1.</span> <span class="toc-text">思路1:消除依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-%E9%87%8D%E6%96%B0%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6"><span class="toc-number">3.1.2.</span> <span class="toc-text">思路1: 重新绑定事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-ref"><span class="toc-number">3.1.3.</span> <span class="toc-text">思路2:ref</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-%E6%8E%A8%E8%8D%90%E7%9A%84%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%E6%98%AF%E6%8A%8A%E9%82%A3%E4%B8%AA%E5%87%BD%E6%95%B0%E7%A7%BB%E5%8A%A8%E5%88%B0%E4%BD%A0%E7%9A%84-effect-%E5%86%85%E9%83%A8"><span class="toc-number">3.1.4.</span> <span class="toc-text">思路1:推荐的修复方案是把那个函数移动到你的 effect 内部</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-useCallback"><span class="toc-number">3.1.5.</span> <span class="toc-text">思路2: useCallback</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/59815/" title="React高级实战"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover_9.jpg" onerror='this.onerror=null,this.src="/img/404.png"' alt="React高级实战"></a><div class="content"><a class="title" href="/59815/" title="React高级实战">React高级实战</a><time datetime="2022-02-08T06:21:43.000Z" title="发表于 2022-02-08 14:21:43">2022-02-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/59814/" title="React状态管理"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover_2.jpg" onerror='this.onerror=null,this.src="/img/404.png"' alt="React状态管理"></a><div class="content"><a class="title" href="/59814/" title="React状态管理">React状态管理</a><time datetime="2022-02-08T06:21:43.000Z" title="发表于 2022-02-08 14:21:43">2022-02-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/11559/" title="React hooks"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover_10.jpg" onerror='this.onerror=null,this.src="/img/404.png"' alt="React hooks"></a><div class="content"><a class="title" href="/11559/" title="React hooks">React hooks</a><time datetime="2022-02-08T06:21:43.000Z" title="发表于 2022-02-08 14:21:43">2022-02-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/59622/" title="React原理"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover_10.jpg" onerror='this.onerror=null,this.src="/img/404.png"' alt="React原理"></a><div class="content"><a class="title" href="/59622/" title="React原理">React原理</a><time datetime="2022-02-08T06:21:39.000Z" title="发表于 2022-02-08 14:21:39">2022-02-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/10279/" title="React生态"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover_10.jpg" onerror='this.onerror=null,this.src="/img/404.png"' alt="React生态"></a><div class="content"><a class="title" href="/10279/" title="React生态">React生态</a><time datetime="2022-02-08T06:21:34.000Z" title="发表于 2022-02-08 14:21:34">2022-02-08</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By souldjl</div><div class="footer_custom_text">没有行动的梦想，都是妄想～</div><a href="/statement">免责申明</a></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function addGitalkSource(){const t=document.createElement("link");t.rel="stylesheet",t.href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css",document.getElementsByTagName("head")[0].appendChild(t)}function loadGitalk(){function t(){new Gitalk(Object.assign({clientID:"28388bc5382cb36e8b6a",clientSecret:"0976a3fb2d62d4e2b86385d26451a23ead66f6eb",repo:"souldjl.github.io",owner:"souldjl",admin:["souldjl"],id:"b99ab7000426c9dbee335484594218f7",updateCountCallback:commentCount},null)).render("gitalk-container")}"function"==typeof Gitalk?t():(addGitalkSource(),getScript("https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js").then(t))}function commentCount(t){let e=document.querySelector("#post-meta .gitalk-comment-count");e&&(e.innerHTML=t)}function loadOtherComment(){loadGitalk()}loadGitalk()</script></div><script src="https://cdn.bootcdn.net/ajax/libs/Swiper/7.4.1/swiper-bundle.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",function(){if(window.removeEventListener("scroll",window.tocScrollFn),window.removeEventListener("scroll",scrollCollect),"object"==typeof preloader&&preloader.initLoading(),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")}),document.addEventListener("pjax:complete",function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script");var o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()}),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>