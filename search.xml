<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>React状态管理</title>
      <link href="/59814/"/>
      <url>/59814/</url>
      
        <content type="html"><![CDATA[<h2 id="6-1-redux入门"><a href="#6-1-redux入门" class="headerlink" title="6.1 redux入门"></a>6.1 redux入门</h2><h3 id="6-1-1-redux基础"><a href="#6-1-1-redux基础" class="headerlink" title="6.1.1 redux基础"></a>6.1.1 redux基础</h3><h4 id="为什么需要Redux？"><a href="#为什么需要Redux？" class="headerlink" title="为什么需要Redux？"></a>为什么需要Redux？</h4><p> Redux 适合于大型复杂的单页面应用。</p><p><img src="~@/react/whyredux.png"></p><h4 id="Redux核心概念"><a href="#Redux核心概念" class="headerlink" title="Redux核心概念"></a>Redux核心概念</h4><ul><li><p>state： 应用全局数据的来源，数据驱动视图的核心</p></li><li><p>action：数据发生改变的动作描述</p></li><li><p>reducer： 结合state和action，并返回一个新的state</p></li></ul><h4 id="Redux三大原则"><a href="#Redux三大原则" class="headerlink" title="Redux三大原则"></a>Redux三大原则</h4><ul><li><p>单一数据源：整个应用的是state被存储在一棵object tree中，并且这个object tree只存在于唯一一个store中。</p></li><li><p>State是只读： 唯一改变state的方法就是触发action，action是一个用于描述已发生事件的普通对象。</p></li><li><p>使用纯函数来执行修改State ：纯函数意味着同样的输入就会有同样的输出。</p></li></ul><h4 id="Redux-运转图"><a href="#Redux-运转图" class="headerlink" title="Redux 运转图"></a>Redux 运转图</h4><p><img src="~@/react/reduxwork.png"></p><h3 id="6-1-2-react-amp-redux"><a href="#6-1-2-react-amp-redux" class="headerlink" title="6.1.2 react &amp; redux"></a>6.1.2 react &amp; redux</h3><h4 id="Redux-API"><a href="#Redux-API" class="headerlink" title="Redux API"></a>Redux API</h4><ul><li><p>createStore 创建一个Redux store来以存放应用中所有的state。</p></li><li><p>combineReducers 将多个不同reducer函数作为value的objcet，合并成一个最终的reducer函数。</p></li><li><p>applyMiddleware 接受自定义功能的middleware来扩展Redux。</p></li><li><p>compose 函数式编程中的方法，右到左来组合执行参数。</p></li></ul><h4 id="React-Redux-API"><a href="#React-Redux-API" class="headerlink" title="React-Redux API"></a>React-Redux API</h4><ul><li><p>connect 将React组件与Redux链接起来</p></li><li><p>Provider 提供被connnet链接起来的组件能够访问得到Store</p></li></ul><h3 id="6-1-3-扩展资料"><a href="#6-1-3-扩展资料" class="headerlink" title="6.1.3 扩展资料"></a>6.1.3 扩展资料</h3><p><a href="https://www.redux.org.cn/">Redux 文档</a></p><p><a href="https://zhuanlan.zhihu.com/p/20597452">Redux 插件</a></p><h2 id="6-2-redux进阶上"><a href="#6-2-redux进阶上" class="headerlink" title="6.2 redux进阶上"></a>6.2 redux进阶上</h2><p>优化使用Redux，让应用更高效</p><h3 id="6-2-1-Redux-异步"><a href="#6-2-1-Redux-异步" class="headerlink" title="6.2.1 Redux 异步"></a>6.2.1 Redux 异步</h3><p>Redux MiddleWare</p><p>Redux 的插件机制，使得Redux默认的同步Action扩展支持异步Action</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同步的Action</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span>  <span class="title">updateName</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">type</span>:<span class="string">&#x27;UPDATE_NAME&#x27;</span>,</span><br><span class="line">        <span class="attr">payload</span>:params</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 异步的Ation</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">queryUserInfo</span> (<span class="params">params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">dispatch,getState</span>)</span>&#123;</span><br><span class="line">        axios.post().then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">            dispatch(&#123;</span><br><span class="line">                  <span class="attr">type</span>:<span class="string">&#x27;UPDATE_NAME&#x27;</span>,</span><br><span class="line">                  <span class="attr">payload</span>:res.data</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="applyMiddleware"><a href="#applyMiddleware" class="headerlink" title="applyMiddleware"></a>applyMiddleware</h4><p>applyMiddleware接受一系列插件，每个插件（middleware）都会以dispatch和getState作为参数，并返回一个函数；该函数会被传入下一个插件中，直到调用结束。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createStore,combineReducers,applyMiddleware&#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">&#x27;redux-thunk&#x27;</span> <span class="comment">//处理异步的插件</span></span><br><span class="line"><span class="keyword">export</span> defalut createStore (</span><br><span class="line">    combineReducers,</span><br><span class="line">    applyMiddleware(...[thunk,otherMiddleware])</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="~@/react/middleware.png"></p><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>store</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createStore,applyMiddleware&#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">&#x27;redux-thunk&#x27;</span></span><br><span class="line"><span class="keyword">import</span> reducers <span class="keyword">from</span> <span class="string">&#x27;./reducer&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createStore(</span><br><span class="line">    reducers,</span><br><span class="line">    applyMiddleware(thunk)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>action</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">querAsyncName</span> (<span class="params">params</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">dispatch,getstate</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">          dispatch(&#123;</span><br><span class="line">              <span class="attr">type</span>:ASYNC_UPDATE_NAME,</span><br><span class="line">              <span class="attr">payload</span>:params</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>reducer</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> DEFAULT_NAME=<span class="string">&#x27;可可&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">homeReducer</span>(<span class="params">state = DEFAULT_NAME, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> ASYNC_UPDATE_NAME:</span><br><span class="line">      <span class="keyword">return</span> action.payload</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>home组件</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;connect&#125; <span class="keyword">from</span>  <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;querAsyncName&#125; <span class="keyword">from</span> <span class="string">&#x27;@/action/home&#x27;</span></span><br><span class="line">@connect(</span><br><span class="line">  <span class="function">(<span class="params">state</span>)=&gt;</span> state.homeReducer,</span><br><span class="line">  <span class="function">(<span class="params">dispatch</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="attr">onQuerAsyncName</span>:<span class="function">(<span class="params">params</span>)=&gt;</span>dispatch(querAsyncName(params))</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Home <span class="keyword">extends</span> Component &#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; onQuerAsyncNameAdync,homeReducer&#125;=<span class="built_in">this</span>.props</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;button onClick=&#123;()=&gt;&#123;</span><br><span class="line">                  onQuerAsyncName(&#x27;郑乃鑫&#x27;)</span><br><span class="line">                &#125;&#125;&gt;</span><br><span class="line">                &lt;/button&gt;</span><br><span class="line">                &lt;div&gt;&#123;homeReducer&#125;&lt;div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <font color="red"><strong>react+redux+ts 可以参考github上的demo</strong></font></p><p> <a href="https://github.com/hejialianghe/react-ts-redux">点击进入</a></p><h2 id="6-3-redux进阶下"><a href="#6-3-redux进阶下" class="headerlink" title="6.3 redux进阶下"></a>6.3 redux进阶下</h2><h3 id="6-3-1-Reselect-amp-Immutable-Data"><a href="#6-3-1-Reselect-amp-Immutable-Data" class="headerlink" title="6.3.1 Reselect &amp; Immutable Data"></a>6.3.1 Reselect &amp; Immutable Data</h3><h4 id="Reselect（同一数据需要重复渲染的时候）"><a href="#Reselect（同一数据需要重复渲染的时候）" class="headerlink" title="Reselect（同一数据需要重复渲染的时候）"></a>Reselect（同一数据需要重复渲染的时候）</h4><ul><li><p>针对mapStateToProps 中state在同一数据源中需要筛选的场景</p></li><li><p>mapStateToProps 中的state如果带有筛选函数，会导致每次都返回新对象</p></li></ul><h4 id="Immutable-Data（不影响原数据）"><a href="#Immutable-Data（不影响原数据）" class="headerlink" title="Immutable Data（不影响原数据）"></a>Immutable Data（不影响原数据）</h4><ul><li><p>避免副作用</p></li><li><p>状态可追溯</p></li><li><p>React中比较是shallowCompare</p></li></ul><h4 id="Immutable方案"><a href="#Immutable方案" class="headerlink" title="Immutable方案"></a>Immutable方案</h4><p>immutable</p><ul><li><p>提供完整的API，与普通的js对象不同，2者不能直接使用</p></li><li><p>对Redux的应用程序来说，整个state tree应该是Immutable.JS对象，根本不需要使用普通的javascript对象</p></li></ul><p>immer</p><ul><li>js原生数据结构实现的immutable，也提供了一套对应的API，相比immutable更推荐使用</li></ul><h3 id="6-3-2-Redux的不足"><a href="#6-3-2-Redux的不足" class="headerlink" title="6.3.2  Redux的不足"></a>6.3.2  Redux的不足</h3><ul><li><p>Redux范式繁琐 完成一次页面渲染，需要在Action层分别定义type，Action方法，Reducer中响应Action方法，完成一次流程需要在多个文件夹中来回切换。</p></li><li><p>基础功能匮乏 默认只能同步方法，异步数据请求需要安装插件（Redux-thunk），复杂功能交由第三方插件完成，有一定接入成本。</p></li></ul><h4 id="三种解决方案对比"><a href="#三种解决方案对比" class="headerlink" title="三种解决方案对比"></a>三种解决方案对比</h4><table><thead><tr><th align="center">解决方案</th><th align="center">多层范式</th><th align="left">同步/异步</th><th align="center">集成插件</th></tr></thead><tbody><tr><td align="center">redux-actions</td><td align="center">否</td><td align="left">不区分</td><td align="center">否</td></tr><tr><td align="center">@rematch-core</td><td align="center">否</td><td align="left">区分</td><td align="center">是</td></tr><tr><td align="center">dva</td><td align="center">否</td><td align="left">区分</td><td align="center">是</td></tr></tbody></table><h3 id="6-3-3-扩展预习资料"><a href="#6-3-3-扩展预习资料" class="headerlink" title="6.3.3 扩展预习资料"></a>6.3.3 扩展预习资料</h3><p><a href="https://redux-actions.js.org/introduction">redux-actions</a></p><p><a href="https://rematch.github.io/rematch/#/lang/zh-cn/">@rematch/core</a></p><p><a href="https://dvajs.com/guide/">dva</a></p><h2 id="6-4-Mobx-入门"><a href="#6-4-Mobx-入门" class="headerlink" title="6.4 Mobx 入门"></a>6.4 Mobx 入门</h2><p>响应式状态管理工具</p><h3 id="6-4-1-Mobx-核心概念"><a href="#6-4-1-Mobx-核心概念" class="headerlink" title="6.4.1 Mobx 核心概念"></a>6.4.1 Mobx 核心概念</h3><ul><li><p>Mobx 提供的一种状态（State）可供观察的解决方案。</p></li><li><p>可观察的状态（Observable state）意味这在Mobx构建应用中，更洗粒度和更高效的状态管理</p></li><li><p>与Redux 中状态变化取决于对比前后差异，Mobx中申明了观察对象便会依据框架本身的能力进行管理</p></li></ul><h4 id="Redux-流程-vs-Mobx-流程"><a href="#Redux-流程-vs-Mobx-流程" class="headerlink" title="Redux 流程 vs Mobx 流程"></a>Redux 流程 vs Mobx 流程</h4><p>Redux 应用流转图</p><p><img src="~@/react/reduxAbout.png"></p><p>Mobx 应用流转图</p><p><img src="~@/react/mobxAbout.png"></p><h4 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h4><ul><li><p>Observable State</p><ul><li>Mobx为常用的数据结构（如：对象，数组和类实例）添加了可观察的功能。</li><li>使用<code>@observable装饰器</code>更便捷完成添加Observable State功能。</li></ul></li><li><p>Derivations（衍生）</p><ul><li>Computed values（计算值）：使用纯函数（pure function）从当前可观察状态中衍生出的值。</li><li>Reacions（反应）：当状态改变时需要自动发生的副作用。</li></ul></li></ul><h2 id="6-5-Mobx接入实战"><a href="#6-5-Mobx接入实战" class="headerlink" title="6.5 Mobx接入实战"></a>6.5 Mobx接入实战</h2><h3 id="6-5-1-Mobx复杂应用"><a href="#6-5-1-Mobx复杂应用" class="headerlink" title="6.5.1 Mobx复杂应用"></a>6.5.1 Mobx复杂应用</h3><ul><li>Store 单例</li></ul><p>Store状态全局管理是解决复杂应用的标配</p><ul><li>状态跨组件 </li></ul><p>跨组件传递可以通过Provider传递</p><ul><li>拆分局部状态</li></ul><p>Mobx的特性可以使一些局部状态在当前组件完成</p><ul><li>清理autorun</li></ul><p>componentWillUnmount中执行autorun返回的函数</p><h5 id="Mobx5-Or-Mobx4"><a href="#Mobx5-Or-Mobx4" class="headerlink" title="Mobx5 Or Mobx4"></a>Mobx5 Or Mobx4</h5><p>Mobx5</p><ul><li><p>Mobx5内部实现对象 observbale的核心是基于ES的proxy</p></li><li><p>而目前 proxy没有对应的polyfill，所以只能运行在现代浏览器上</p></li></ul><p>Mobx4</p><ul><li><p>Mobx4 内部实现对象observable的核心是基于Object.defineProperty</p></li><li><p>Observable 数据并非真正的数组，其继承自对象，所以与普通的数组对象及某些行为不一样</p></li></ul><h5 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h5><ol><li>下载</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add mobx</span><br><span class="line">yarn add mobx-react</span><br></pre></td></tr></table></figure><ol start="2"><li>在src下新建models文件，在该文件下新件home.js 和index.js</li></ol><p>home.js</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; observable, action &#125; <span class="keyword">from</span> <span class="string">&#x27;mobx&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeInfo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定一个observable对象</span></span><br><span class="line">  @observable name = <span class="string">&#x27;蚂蚁&#x27;</span>;</span><br><span class="line">  <span class="comment">// 定义一个动作，修改这个name</span></span><br><span class="line">  @action</span><br><span class="line">  updateName = <span class="function">(<span class="params">params</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = params;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> HomeInfo();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>index.js</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> homeInfo <span class="keyword">from</span> <span class="string">&#x27;./home&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  homeInfo,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>关联组件</li></ol><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">&#x27;mobx-react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./models&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./app&#x27;</span>;</span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Provider</span> &#123;<span class="attr">...store</span>&#125;&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span>,</span><br><span class="line">  <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#app&#x27;</span>),</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li>将数据注入到组件中</li></ol><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; observer, inject &#125; <span class="keyword">from</span> <span class="string">&#x27;mobx-react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@inject(<span class="string">&#x27;homeInfo&#x27;</span>)</span><br><span class="line">@observer</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Home</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">  <span class="attr">homeInfo</span>: PropTypes.objectOf(PropTypes.object),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Home.defaultProps = &#123;</span><br><span class="line">    <span class="attr">homeInfo</span>: &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">handleClick=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;<span class="attr">homeInfo</span>:&#123;updateName&#125;&#125;=<span class="built_in">this</span>.props</span><br><span class="line">    updateName(<span class="string">&#x27;更改&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">homeInfo</span>: &#123; name &#125; &#125; = <span class="built_in">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;mobx&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-5-2-Mobx-vs-Redux"><a href="#6-5-2-Mobx-vs-Redux" class="headerlink" title="6.5.2 Mobx vs Redux"></a>6.5.2 Mobx vs Redux</h3><table><thead><tr><th align="center">对比维度</th><th align="center">范式</th><th align="left">异步</th><th align="center">插件化</th><th align="center">核心</th><th align="center">社区</th></tr></thead><tbody><tr><td align="center">Mobx</td><td align="center">简单</td><td align="left">支持</td><td align="center">不支持</td><td align="center">Mobx5（ES6 proxy）Mobx4(Object.defineProperty)</td><td align="center">相对繁荣</td></tr><tr><td align="center">Redux</td><td align="center">复杂</td><td align="left">插件支持</td><td align="center">支持</td><td align="center">Symbol.observable订阅更新</td><td align="center">繁荣</td></tr></tbody></table><h3 id="6-5-3-扩展学习资料"><a href="#6-5-3-扩展学习资料" class="headerlink" title="6.5.3 扩展学习资料"></a>6.5.3 扩展学习资料</h3><p><a href="https://cn.mobx.js.org/">mobx中文文档</a></p><p><a href="https://medium.com/@Zwenza/how-to-persist-your-mobx-state-4b48b3834a41">mobx英文</a></p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React高级实战</title>
      <link href="/59815/"/>
      <url>/59815/</url>
      
        <content type="html"><![CDATA[<h2 id="7-1-TypeScripts实战上"><a href="#7-1-TypeScripts实战上" class="headerlink" title="7.1 TypeScripts实战上"></a>7.1 TypeScripts实战上</h2><p>在编程语言中如果按类型检测划分，可以分为2大类，一类是静态类型和一类是动态类型；我们所了解的java、c、c++等后端语言都是静态类型，而javascript属于动态类型；由于静态类型已经被证明符合管理复杂的应用，所以我们要学一下typescript是有必要的。</p><h3 id="7-1-1-TypeScript-设计原则"><a href="#7-1-1-TypeScript-设计原则" class="headerlink" title="7.1.1 TypeScript 设计原则"></a>7.1.1 TypeScript 设计原则</h3><ul><li>静态识别可能出现错误的代码结构。</li><li>为大型应用的代码提供结构化的机制。</li><li>不增加程序运行时开销，保留javascript运行时行为这一特性。</li><li>语言层面提供可组合性、可推理性。</li><li>语法层面保持和ECMAScript提案一致。</li><li>不增家额外的表达示层面的语法。</li></ul><h3 id="7-1-2-TypeScript-基础"><a href="#7-1-2-TypeScript-基础" class="headerlink" title="7.1.2 TypeScript 基础"></a>7.1.2 TypeScript 基础</h3><h4 id="ts的特点"><a href="#ts的特点" class="headerlink" title="ts的特点"></a>ts的特点</h4><ol><li><p>跨平台，mac和window都支持。</p></li><li><p>静态类型检测。</p></li><li><p>可选的类型检测。</p></li><li><p>面向对象</p></li><li><p>ES6特性的支持</p></li><li><p>对DOM的支持</p></li></ol><h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sting类型</span></span><br><span class="line"><span class="keyword">const</span> name:<span class="built_in">string</span>=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="comment">// number类型</span></span><br><span class="line"><span class="keyword">const</span> money:<span class="built_in">number</span>=<span class="number">100</span></span><br><span class="line"><span class="comment">// boolean类型</span></span><br><span class="line"><span class="keyword">const</span> boolShow:<span class="built_in">boolean</span>=<span class="literal">true</span></span><br><span class="line"><span class="comment">// 定义数组类型</span></span><br><span class="line"> <span class="keyword">const</span> list:<span class="built_in">number</span>[]=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"> <span class="keyword">const</span> list2:<span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt;=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment">//  定义元组类型</span></span><br><span class="line"><span class="keyword">const</span> tuple:[<span class="built_in">number</span>,<span class="built_in">string</span>]=[<span class="number">1</span>,<span class="string">&#x27;nice&#x27;</span>]</span><br><span class="line"><span class="comment">// 枚举 Monday默认值0，剩下的依次递增</span></span><br><span class="line"><span class="built_in">enum</span> DateEnum &#123;</span><br><span class="line">    Monday,</span><br><span class="line">    Tuesday,</span><br><span class="line">    Wednesday,</span><br><span class="line">    Thursday,</span><br><span class="line">    Friday</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> date:DateEnum=DateEnum.Monday</span><br><span class="line"><span class="comment">// void 表示无返回值</span></span><br><span class="line"><span class="keyword">const</span> setValue:<span class="function">()=&gt;</span><span class="built_in">void</span>=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">otherSetValue</span>(<span class="params"></span>):<span class="title">void</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> simpvalue:<span class="built_in">any</span>=<span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="变量的基本类型"><a href="#变量的基本类型" class="headerlink" title="变量的基本类型"></a>变量的基本类型</h4><table><thead><tr><th align="center">类型名称</th><th align="center">表示式</th></tr></thead><tbody><tr><td align="center">布尔值</td><td align="center">boolean</td></tr><tr><td align="center">数字</td><td align="center">number</td></tr><tr><td align="center">字符串</td><td align="center">string</td></tr><tr><td align="center">数组</td><td align="center">number[] 或 Array&lt;number&gt;</td></tr><tr><td align="center">元组</td><td align="center">[number,string]</td></tr><tr><td align="center">枚举</td><td align="center">enum</td></tr><tr><td align="center">Any</td><td align="center">any</td></tr><tr><td align="center">Void</td><td align="center">void</td></tr><tr><td align="center">Null</td><td align="center">null</td></tr><tr><td align="center">Undefined</td><td align="center">undefined</td></tr><tr><td align="center">Never</td><td align="center">never</td></tr></tbody></table><p>Never永远不存在，或者不是我们想要的，用在抛出异常的函数里；never用try catch的catch</p><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>标准类型-interface</p><p>在面向对象语言中，接口（interface)是一个很重要的概念，它是对行为的抽象，而具体如何行动需要有类（class）去实现。</p><p>TypeScript中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「Shape」进行描述。</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首字母大写</span></span><br><span class="line">    <span class="keyword">interface</span> Iprops &#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="built_in">string</span>,</span><br><span class="line">        <span class="attr">gender</span>:<span class="built_in">number</span>,</span><br><span class="line">        <span class="attr">address</span>:<span class="built_in">string</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> staff:Iprops=&#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;zk&#x27;</span>,</span><br><span class="line">        <span class="attr">gender</span>:<span class="number">1</span>,</span><br><span class="line">        <span class="attr">address</span>:<span class="string">&#x27;suzhou&#x27;</span> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">register</span> (<span class="params"></span>):<span class="title">Iprops</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">name</span>:<span class="string">&#x27;zk&#x27;</span>,</span><br><span class="line">            <span class="attr">gender</span>:<span class="number">1</span>,</span><br><span class="line">            <span class="attr">address</span>:<span class="string">&#x27;suzhou&#x27;</span> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="类型别名-type"><a href="#类型别名-type" class="headerlink" title="类型别名-type"></a>类型别名-type</h4><ul><li>类型别名用来给一个类型起一个新名字</li><li>字符串字面量类型用来约束取值只能是某几个字符串中的一个</li><li>type可以扩展，但是不能继承</li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首字母大写</span></span><br><span class="line">    <span class="keyword">type</span> Iprops =&#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="built_in">string</span>,</span><br><span class="line">        <span class="attr">gender</span>:<span class="built_in">number</span>,</span><br><span class="line">        <span class="attr">address</span>:<span class="built_in">string</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> staff:Iprops=&#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;zk&#x27;</span>,</span><br><span class="line">        <span class="attr">gender</span>:<span class="number">1</span>,</span><br><span class="line">        <span class="attr">address</span>:<span class="string">&#x27;suzhou&#x27;</span> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">register</span> (<span class="params"></span>):<span class="title">Iprops</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">name</span>:<span class="string">&#x27;zk&#x27;</span>,</span><br><span class="line">            <span class="attr">gender</span>:<span class="number">1</span>,</span><br><span class="line">            <span class="attr">address</span>:<span class="string">&#x27;suzhou&#x27;</span> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="接口VS类型别名"><a href="#接口VS类型别名" class="headerlink" title="接口VS类型别名"></a>接口VS类型别名</h4><p>接口</p><ul><li><p>可以继承，可以多态。接口的实现需要implements</p></li><li><p>既是“抽象”也是“约束”</p></li><li><p>优先使用</p></li></ul><p>类型别名</p><ul><li><p>只是类型的别名，没有创建新类型。扩展可以使用&amp;实现</p></li><li><p>主要是约束作用，早期TypeScript主要用作函数、对象的约束</p></li></ul><h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><ul><li><p>typeScript 允许你覆盖它的推断，并且能以你任何你想要的方式分析它，这种机制被称为类型断言</p></li><li><p>通常用来手动指定一个值的类型</p></li><li><p>JSX不能使用<code>&lt;&gt;</code></p></li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line">值 <span class="keyword">as</span> 类型</span><br><span class="line">   or</span><br><span class="line">&lt;类型&gt;值</span><br><span class="line"><span class="keyword">interface</span> Hello &#123;</span><br><span class="line">    <span class="attr">sayHello</span>:<span class="function">()=&gt;</span><span class="built_in">void</span>,</span><br><span class="line">    <span class="attr">name</span>:<span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a=&#123;&#125; </span><br><span class="line">a.name =<span class="string">&#x27;zs&#x27;</span> <span class="comment">// 没有定义类型，会提示类型“&#123;&#125;”上不存在属性“name”</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用类型断言指定类型</span></span><br><span class="line"><span class="keyword">const</span> a =&#123;&#125; <span class="keyword">as</span> Hello</span><br><span class="line">  or</span><br><span class="line"><span class="keyword">const</span> a=&lt;Hello&gt;&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>类型断言是欺骗类型检测，所以最好在确定类型的情况下去用。</p><h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><p>泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 泛型接口</span></span><br><span class="line"><span class="keyword">interface</span> IGprops &#123;</span><br><span class="line">    <span class="attr">setName</span>:&lt;T&gt;<span class="function">(<span class="params">str:T</span>)=&gt;</span><span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> nameWrapper:IGprops=&#123;</span><br><span class="line">    <span class="attr">setName</span>:&lt;T&gt;<span class="function">(<span class="params">str:T</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> userNameArr2:T[]=[]</span><br><span class="line">        userNameArr2.push(str)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nameWrapper.setName(<span class="string">&#x27;zs&#x27;</span>)</span><br><span class="line">nameWrapper.setName(<span class="number">123</span>)</span><br></pre></td></tr></table></figure><h2 id="7-2-TypeScripts实战下"><a href="#7-2-TypeScripts实战下" class="headerlink" title="7.2 TypeScripts实战下"></a>7.2 TypeScripts实战下</h2><h3 id="7-2-1-TypeScript-amp-React实践"><a href="#7-2-1-TypeScript-amp-React实践" class="headerlink" title="7.2.1 TypeScript &amp; React实践"></a>7.2.1 TypeScript &amp; React实践</h3><h4 id="tsconfig-json"><a href="#tsconfig-json" class="headerlink" title="tsconfig.json"></a>tsconfig.json</h4><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;target&quot;</span>: <span class="string">&quot;ESNext&quot;</span>, <span class="comment">// 指定ECMA的版本，这里我们指定了最新版本</span></span><br><span class="line">    <span class="string">&quot;module&quot;</span>: <span class="string">&quot;ESNext&quot;</span>, <span class="comment">// 代码组织方式</span></span><br><span class="line">    <span class="string">&quot;lib&quot;</span>: [ <span class="comment">//工程中依赖的配置</span></span><br><span class="line">      <span class="string">&quot;DOM&quot;</span>,</span><br><span class="line">      <span class="string">&quot;DOM.Iterable&quot;</span>,</span><br><span class="line">      <span class="string">&quot;ESNext&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;moduleResolution&quot;</span>: <span class="string">&quot;node&quot;</span>, </span><br><span class="line">    <span class="string">&quot;experimentalDecorators&quot;</span>: <span class="literal">true</span>, <span class="comment">// 是否开启装饰器</span></span><br><span class="line">    <span class="string">&quot;allowSyntheticDefaultImports&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;outDir&quot;</span>: <span class="string">&quot;dist&quot;</span>, <span class="comment">//输出目录</span></span><br><span class="line">    <span class="string">&quot;strictNullChecks&quot;</span>: <span class="literal">true</span>, <span class="comment">// 对null严格检测</span></span><br><span class="line">    <span class="string">&quot;sourceMap&quot;</span>: <span class="literal">true</span>, <span class="comment">//开启开发者调试</span></span><br><span class="line">    <span class="string">&quot;baseUrl&quot;</span>: <span class="string">&quot;.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;rootDir&quot;</span>: <span class="string">&quot;.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;jsx&quot;</span>: <span class="string">&quot;react&quot;</span>,</span><br><span class="line">    <span class="string">&quot;allowJs&quot;</span>: <span class="literal">true</span>, <span class="comment">// 所有的js都需要编译</span></span><br><span class="line">    <span class="string">&quot;resolveJsonModule&quot;</span>: <span class="comment">// true,是否用json文件</span></span><br><span class="line">    <span class="string">&quot;typeRoots&quot;</span>: [ <span class="comment">// 第三方包和自己包的类型声明</span></span><br><span class="line">      <span class="string">&quot;node_modules/@types&quot;</span>,</span><br><span class="line">      <span class="string">&quot;src/types&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;paths&quot;</span>: &#123; <span class="comment">// alias配置</span></span><br><span class="line">      <span class="string">&quot;@/*&quot;</span>: [<span class="string">&quot;./src/*&quot;</span>],</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;exclude&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;node_modules&quot;</span>,</span><br><span class="line">    <span class="string">&quot;dist&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;compileOnSave&quot;</span>: <span class="literal">false</span> <span class="comment">//是否在保存的时候进行编译</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-2-扩展学习"><a href="#7-2-2-扩展学习" class="headerlink" title="7.2.2 扩展学习"></a>7.2.2 扩展学习</h3><p><a href="https://www.typescriptlang.org/docs/handbook/typescript-from-scratch.html">ts官方文档（最新文档）</a></p><p><a href="https://www.tslang.cn/docs/handbook/basic-types.html">中文文档</a></p><p><a href="https://ts.xcatliu.com/">入门教程</a></p><p><a href="https://medium.com/@rossbulat/typescript-generics-explained-15c6493b510f">更好的理解 TS 泛型</a></p><h2 id="7-3-React-性能优化"><a href="#7-3-React-性能优化" class="headerlink" title="7.3 React 性能优化"></a>7.3 React 性能优化</h2><h3 id="7-3-1-React-组件性能探寻"><a href="#7-3-1-React-组件性能探寻" class="headerlink" title="7.3.1 React 组件性能探寻"></a>7.3.1 React 组件性能探寻</h3><h4 id="React-Devtools-（react中的性能分析工具）推荐"><a href="#React-Devtools-（react中的性能分析工具）推荐" class="headerlink" title="React Devtools （react中的性能分析工具）推荐"></a>React Devtools （react中的性能分析工具）推荐</h4><ul><li>React v16.5.0+（开发模式）</li><li>React Developer Tools V3.3.2+</li></ul><p>追踪用户行为</p><ol><li><p>安装schedule包， yarn add schedule</p></li><li><p>在需要追踪的地方嵌入代码</p></li></ol><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; unstable_track <span class="keyword">as</span> track&#125; <span class="keyword">from</span> <span class="string">&#x27;schedule/track&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Home</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    handleSubmit =<span class="function"><span class="params">e</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> text = e.target.value.trim()</span><br><span class="line">        <span class="comment">// 用户点击了回车按钮就进行追踪</span></span><br><span class="line">        <span class="keyword">if</span>(e.which===<span class="number">13</span>)&#123;</span><br><span class="line">            track(<span class="string">&quot;Add TOdo&quot;</span>,performance,now,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                <span class="built_in">this</span>.props.onSave(text)</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">this</span>.props.newTodo)&#123;</span><br><span class="line">                    <span class="built_in">this</span>.setState(&#123;<span class="attr">text</span>:<span class="string">&#x27;&#x27;</span>&#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="React-Profiler-API（react中的性能分析工具）"><a href="#React-Profiler-API（react中的性能分析工具）" class="headerlink" title="React Profiler API（react中的性能分析工具）"></a>React Profiler API（react中的性能分析工具）</h4><ol><li>Profilter在“react”包中。</li><li>onRender回调函数，返回一系列信息。</li></ol><h3 id="7-3-2-组件性能优化"><a href="#7-3-2-组件性能优化" class="headerlink" title="7.3.2 组件性能优化"></a>7.3.2 组件性能优化</h3><h4 id="1-PureComponent"><a href="#1-PureComponent" class="headerlink" title="1. PureComponent"></a>1. PureComponent</h4><ul><li><p>class 组件优化工具</p></li><li><p>实质是shouldComponentUpdate 方法中进行浅比较</p></li></ul><p>父组件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React  <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;</span><br><span class="line">            <span class="attr">date</span> : <span class="keyword">new</span> <span class="built_in">Date</span>(),</span><br><span class="line">            <span class="attr">id</span>:<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">                <span class="attr">date</span>:<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Child</span> <span class="attr">seconds</span>=<span class="string">&#123;id&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.state.date.toString()&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从上面可以看出<code>date</code>变量的变化，整个组件都需要diff，我们看出child组件并不依赖<code>date</code>变量；所以date变化的时候，子组件完全没不要渲染，那么我们可以用<code>PureComponent</code>优化一下。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.seconds&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-memo"><a href="#2-memo" class="headerlink" title="2. memo"></a>2. memo</h4><ul><li><p>函数组件优化工具</p></li><li><p>是一个高阶函数，在其内部进行类似shouldComponentUpdate的比较</p></li><li><p>可以指定比较函数</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">&#123;seconds&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>I am update every &#123;seconds&#125; seconds<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.memo(Child)</span><br></pre></td></tr></table></figure><p>不要以为子组件用React.memo就万事大吉了</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">&#123;seconds&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     我们向子组件传递函数，但是函数组件里的函数在每次更新的情况下，函数是重新创建的</span></span><br><span class="line"><span class="comment">     那么子组件每次发现传递函数变化了，也会进行更新，那么你用React.memo进行优化就没有作用了</span></span><br><span class="line"><span class="comment">     怎么解决呢？可以用useCallback进行包裹</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//优化前</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优化后</span></span><br><span class="line">    <span class="keyword">const</span> change  = useCallback(<span class="function">()=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">change</span>=<span class="string">&#123;change&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">&#123;seconds&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>I am update every &#123;seconds&#125; seconds<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.memo(Child)</span><br></pre></td></tr></table></figure><p>::: warning<br>React.memo()可接受2个参数，第一个参数为纯函数的组件，第二个参数用于对比props控制是否刷新，与shouldComponentUpdate()功能类似。[2]</p><p> React.memo 等效于 PureComponent，但它只比较 props。（你也可以通过第二个参数指定一个自定义的比较函数来比较新旧 props。如果函数返回 true，就会跳过更新。）<br>:::</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">&#123;seconds&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>I am update every &#123;seconds&#125; seconds<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">areEqual</span>(<span class="params">prevProps, nextProps</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prevProps.seconds===nextProps.seconds)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.memo(Child,areEqual)</span><br></pre></td></tr></table></figure><h4 id="3-原生事件、定时器的销毁"><a href="#3-原生事件、定时器的销毁" class="headerlink" title="3 原生事件、定时器的销毁"></a>3 原生事件、定时器的销毁</h4><p><img src="~@/react/reactNature.png"></p><h4 id="4-使用不变的数据结构"><a href="#4-使用不变的数据结构" class="headerlink" title="4.使用不变的数据结构"></a>4.使用不变的数据结构</h4><p>数据不变性不是架构或设计模式，而是一种固执己见的代码编写方式。这迫使您考虑如何组织应用程序数据流。在我看来，数据不变性是围绕严格的单向数据流进行的实践。</p><p>优势：</p><ul><li>零副作用</li><li>不可变数据对象更易于创建、测试和使用</li><li>容易跟踪变化</li></ul><p>案例：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Imu</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">    state = &#123;</span><br><span class="line">       <span class="attr">users</span>: []</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   addNewUser = <span class="function">() =&gt;</span>&#123;</span><br><span class="line">       <span class="keyword">const</span> users = <span class="built_in">this</span>.state.users;</span><br><span class="line">       users.push(&#123;</span><br><span class="line">           <span class="attr">userName</span>: <span class="string">&quot;robin&quot;</span>,</span><br><span class="line">           <span class="attr">email</span>: <span class="string">&quot;email@email.com&quot;</span></span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="built_in">this</span>.setState(&#123;<span class="attr">users</span>: users&#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种情况，user和this.state.users是同一个引用，我们直接修改user，相当于直接修改了this.state.users；react状态应该是不可变的,因为setState()之后，能替换调你在之前所做的修改</p><p>直接修改state带来的问题：</p><p>我们利用shouldComponentUpdate来判断是否重新渲染组件，this.state.users和nextState.user是同一个引用，所以即使数组变化了,React也不会重新渲染UI</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">shouldComponentUpdate</span>(<span class="params">nextProps, nextState</span>)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.state.users !== nextState.users) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>如何避免此类问题</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">addNewUser = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">       <span class="attr">users</span>: state.users.concat(&#123;</span><br><span class="line">         <span class="attr">timeStamp</span>: <span class="keyword">new</span> <span class="built_in">Date</span>(),</span><br><span class="line">         <span class="attr">userName</span>: <span class="string">&quot;robin&quot;</span>,</span><br><span class="line">         <span class="attr">email</span>: <span class="string">&quot;email@email.com&quot;</span></span><br><span class="line">       &#125;)</span><br><span class="line">     &#125;));</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p>可以考虑以下不可变的方法：</p><p>数组：[].concat 或 […params]</p><p>对象：Object.assign({}, …)或 es6{…params}</p><p>可变数据结构的优化库:</p><ol><li><p>mmutable.js</p></li><li><p>react-copy-write</p></li></ol><h4 id="5-拆分文件"><a href="#5-拆分文件" class="headerlink" title="5. 拆分文件"></a>5. 拆分文件</h4><p>随着不断的添加新功能和依赖项，不只不觉你的项目变的巨大，我们可以考虑分离第三方包；把您的应用程序代码和第三方库分离，<br>通过拆分文件，您的浏览器可以并行下载资源，减少等待时间，<a href="https://webpack.js.org/plugins/split-chunks-plugin/">SplitChunksPlugin</a></p><h4 id="6-依赖优化"><a href="#6-依赖优化" class="headerlink" title="6. 依赖优化"></a>6. 依赖优化</h4><p>在优化应用程序代码的时候，有必要检查你在程序中使用了多少库的代码，例如你使用了Moment.js;这个库包含了许多你不需要的国家化语言包，那么您可以考虑使用moment-locales-webpack-plugin为您的最终包删除未使用的语言包。</p><p>lodash，你可以用lodash-webpack-plugin删除未使用的功能</p><h4 id="7-React-Fragments-用于避免多余HTML元素"><a href="#7-React-Fragments-用于避免多余HTML元素" class="headerlink" title="7. React.Fragments 用于避免多余HTML元素"></a>7. React.Fragments 用于避免多余HTML元素</h4><p>在react中我们必须用一个根元素包裹子元素，我们可以用React.Fragment进行包裹，在渲染的时候它并不会渲染成真的HTML元素</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Comments</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">PureComponent</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Comment Title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>comments<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>comment time<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Comments</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">PureComponent</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Comment Title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>comments<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>comment time<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-避免在渲染函数中使用内联函数定义"><a href="#8-避免在渲染函数中使用内联函数定义" class="headerlink" title="8. 避免在渲染函数中使用内联函数定义"></a>8. 避免在渲染函数中使用内联函数定义</h4><p>由于函数是 JavaScript ( {} !== {})中的对象，因此当 React 进行 diff 检查时，内联函数将始终diff失败。此外，如果在 JSX 属性中使用箭头函数，则会在每个渲染上创建该函数的新实例。这可能会为垃圾收集器带来大量工作。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">CommentList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        <span class="attr">comments</span>: [],</span><br><span class="line">        <span class="attr">selectedCommentId</span>: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; comments &#125; = <span class="built_in">this</span>.state;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">           comments.map(<span class="function">(<span class="params">comment</span>)=&gt;</span>&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Comment</span> <span class="attr">onClick</span>=<span class="string">&#123;(e)</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="xml">                    this.setState(&#123;selectedCommentId:comment.commentId&#125;)</span></span><br><span class="line"><span class="xml">               &#125;&#125; comment=&#123;comment&#125; key=&#123;comment.id&#125;/&gt;</span></span><br><span class="line">           &#125;) </span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>您可以定义箭头函数，而不是为 props 定义内联函数。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">CommentList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        <span class="attr">comments</span>: [],</span><br><span class="line">        <span class="attr">selectedCommentId</span>: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    onCommentClick = <span class="function">(<span class="params">commentId</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;<span class="attr">selectedCommentId</span>:commentId&#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; comments &#125; = <span class="built_in">this</span>.state;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">           comments.map(<span class="function">(<span class="params">comment</span>)=&gt;</span>&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Comment</span> <span class="attr">onClick</span>=<span class="string">&#123;this.onCommentClick&#125;</span> </span></span></span><br><span class="line"><span class="tag"><span class="xml">                <span class="attr">comment</span>=<span class="string">&#123;comment&#125;</span> <span class="attr">key</span>=<span class="string">&#123;comment.id&#125;/</span>&gt;</span></span></span><br><span class="line">           &#125;) </span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-使用防抖节流"><a href="#9-使用防抖节流" class="headerlink" title="9. 使用防抖节流"></a>9. 使用防抖节流</h4><p>节流：在规定时间内去触发一次，在这个时间内无论你做多少行为，我只触发一次行为</p><p>防抖：防止事件频繁触发，只在用户停止行为后，在延迟之后的时间触发</p><p>可以使用lodash</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> debouce <span class="keyword">from</span> <span class="string">&#x27;lodash.debounce&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SearchComments</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">   <span class="built_in">super</span>(props);</span><br><span class="line">   <span class="built_in">this</span>.state = &#123; <span class="attr">searchQuery</span>: “” &#125;;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> setSearchQuery = debounce(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">this</span>.setState(&#123; <span class="attr">searchQuery</span>: e.target.value &#125;);</span><br><span class="line"> &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> (</span><br><span class="line">     <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">       <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Search Comments<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">       <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.setSearchQuery&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">   );</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-避免使用-Index-作为-Map-的-Key"><a href="#10-避免使用-Index-作为-Map-的-Key" class="headerlink" title="10. 避免使用 Index 作为 Map 的 Key"></a>10. 避免使用 Index 作为 Map 的 Key</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    comments.map(<span class="function">(<span class="params">comment, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">Comment</span> </span></span></span><br><span class="line"><span class="tag"><span class="xml">            &#123;<span class="attr">..comment</span>&#125;</span></span></span><br><span class="line"><span class="tag"><span class="xml">            <span class="attr">key</span>=<span class="string">&#123;index&#125;</span> /&gt;</span></span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用index可能导致你的应用程序显示不正确，因为在diff的时候会使用到key；当你在删除、添加、移动列表的时候，key值相同的<br>元素已经不是同一个元素了。</p><p>在某些情况下可以使用index作为key</p><ul><li>列表和项目是静态的</li><li>列表中的项目没有 ID，列表永远不会被重新排序或过滤</li><li>列表是不可变的</li></ul><h4 id="11-避免用props初始组件的状态"><a href="#11-避免用props初始组件的状态" class="headerlink" title="11. 避免用props初始组件的状态"></a>11. 避免用props初始组件的状态</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EditPanelComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.state =&#123;</span><br><span class="line">            <span class="attr">isEditMode</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">applyCoupon</span>: props.applyCoupon</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    &#123;this.state.applyCoupon &amp;&amp; </span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;&gt;</span>Enter Coupon: <span class="tag">&lt;<span class="name">Input</span>/&gt;</span><span class="tag">&lt;/&gt;</span></span>&#125;</span><br><span class="line">               &lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在没有刷新组件的情况下更改了 props，则新的 props 值将永远不会分配给状态的applyCoupon,因为constructor只会在初始化的时候调用。</p><p>解决方法：可以componentWillReceiveProps，可以通过props来更新状态</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.state =&#123;</span><br><span class="line">            <span class="attr">isEditMode</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">applyCoupon</span>: props.applyCoupon</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">componentWillReceiveProps</span>(<span class="params">nextProps</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nextProps.applyCoupon !== <span class="built_in">this</span>.props.applyCoupon) &#123;</span><br><span class="line">            <span class="built_in">this</span>.setState(&#123; <span class="attr">applyCoupon</span>: nextProps.applyCoupon &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.applyCoupon &amp;&amp; </span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;&gt;</span>Enter Coupon: <span class="tag">&lt;<span class="name">Input</span>/&gt;</span><span class="tag">&lt;/&gt;</span></span>&#125;&lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="12-webpack-使用mode"><a href="#12-webpack-使用mode" class="headerlink" title="12. webpack 使用mode"></a>12. webpack 使用mode</h4><p>webpack4 ,mode设置为<code>production</code>,webpack会使用内置优化</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">     <span class="attr">mode</span>: <span class="string">&#x27;production&#x27;</span></span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure><h4 id="13-在-DOM-元素上传播-props"><a href="#13-在-DOM-元素上传播-props" class="headerlink" title="13. 在 DOM 元素上传播 props"></a>13. 在 DOM 元素上传播 props</h4><p>这样做会添加未知的html属性，这是没有必要的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CommentsText = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span> &#123;<span class="attr">...props</span>&#125;&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;props.text&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>可以设置特定属性</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CommentsText = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">specificAttr</span>=<span class="string">&#123;props.specificAttr&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;props.text&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="14-CSS-动画代替-JS-动画"><a href="#14-CSS-动画代替-JS-动画" class="headerlink" title="14. CSS 动画代替 JS 动画"></a>14. CSS 动画代替 JS 动画</h4><p>动画对于流畅和愉悦的用户体验来说是不可避免的。有很多方法可以实现网页动画。一般来说，我们可以通过三种方式创建动画：</p><p>CSS 过渡</p><p>CSS 动画</p><p>JavaScript</p><h4 id="15-CDN"><a href="#15-CDN" class="headerlink" title="15. CDN"></a>15. CDN</h4><p>CDN 可以将静态内容传输的更快，从您的网站或移动应用程序更快。</p><h4 id="16-Web-Workers-API-尝试"><a href="#16-Web-Workers-API-尝试" class="headerlink" title="16 Web Workers API 尝试"></a>16 Web Workers API 尝试</h4><ul><li><p>Web Workers 使用后，Web应用程序可以：</p><ul><li>在独立于主线程的后台线程中运行一个脚本；</li><li>在独立线程中执行费时的任务，避免一些耗时的任务阻断用户体验</li></ul></li><li><p>通信机制 Web Worker执行完耗时任务后与主线程的通信</p><ul><li>postMessage</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sort.worker.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>  <span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    self.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!e) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">let</span> posts = e.data;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>, len = posts.length - <span class="number">1</span>; index &lt; len; index++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> count = index+<span class="number">1</span>; count &lt; posts.length; count++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (posts[index].commentCount &gt; posts[count].commentCount) &#123;</span><br><span class="line">                    <span class="keyword">const</span> temp = posts[index];</span><br><span class="line">                    posts[index] = users[count];</span><br><span class="line">                    posts[count] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        postMessage(posts);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Posts <span class="keyword">extends</span> React.Component&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(posts);</span><br><span class="line">    &#125;</span><br><span class="line">    state = &#123;</span><br><span class="line">        <span class="attr">posts</span>: <span class="built_in">this</span>.props.posts</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.worker = <span class="keyword">new</span> Worker(<span class="string">&#x27;sort.worker.js&#x27;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">this</span>.worker.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> sortedPosts = event.data;</span><br><span class="line">            <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">                <span class="attr">posts</span>: sortedPosts</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    doSortingByComment = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.state.posts &amp;&amp; <span class="built_in">this</span>.state.posts.length)&#123;</span><br><span class="line">            <span class="built_in">this</span>.worker.postMessage(<span class="built_in">this</span>.state.posts);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> posts = <span class="built_in">this</span>.state.posts;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.doSortingByComment&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    Sort By Comments</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">PostList</span> <span class="attr">posts</span>=<span class="string">&#123;posts&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">PostList</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="17-虚拟化长列表"><a href="#17-虚拟化长列表" class="headerlink" title="17. 虚拟化长列表"></a>17. 虚拟化长列表</h4><p>列表虚拟化或窗口化是一种在呈现长数据列表时提高性能的技术。这种技术在任何给定时间只渲染一小部分行，并且可以显着减少重新渲染组件所需的时间，以及创建的 DOM 节点的数量。</p><p>有一些流行的 React 库，比如react-window和react-virtualized，它们提供了几个可重用的组件来显示列表、网格和表格数据。</p><h4 id="18-服务端渲染"><a href="#18-服务端渲染" class="headerlink" title="18. 服务端渲染"></a>18. 服务端渲染</h4><p>可以参考最后一章，项目实战，有服务端渲染代码</p><h4 id="19-在-Web-服务器上启用-Gzip-压缩"><a href="#19-在-Web-服务器上启用-Gzip-压缩" class="headerlink" title="19. 在 Web 服务器上启用 Gzip 压缩"></a>19. 在 Web 服务器上启用 Gzip 压缩</h4><h4 id="20-useMemo进行缓存大量计算数据，useCallback-进行缓存函数，避免重复创建"><a href="#20-useMemo进行缓存大量计算数据，useCallback-进行缓存函数，避免重复创建" class="headerlink" title="20. useMemo进行缓存大量计算数据，useCallback 进行缓存函数，避免重复创建"></a>20. useMemo进行缓存大量计算数据，useCallback 进行缓存函数，避免重复创建</h4><p>在hooks章节有讲解</p><h4 id="21-惰性初始化"><a href="#21-惰性初始化" class="headerlink" title="21. 惰性初始化"></a>21. 惰性初始化</h4><p>优化前：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">table</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [state,setState]=useState(createRows(props.count))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面这种写法，会导致，每次组件更新都要调用createRows，相当于下面的写法</span></span><br><span class="line"><span class="keyword">const</span> values = createRows(props.count)</span><br><span class="line"><span class="keyword">const</span> [state,setState]=useState(values)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>优化后：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">table</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [state,setState]=useState(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> createRows(props.count)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>建议先进行基准测试和测量性能。您可以考虑使用 Chrome 时间轴分析和可视化组件。可以查看哪些组件被卸载、安装、更新，以及它们相对于彼此所花费的时间。它将帮助您开始性能优化之旅。</p><h3 id="7-3-3-扩展资料"><a href="#7-3-3-扩展资料" class="headerlink" title="7.3.3 扩展资料"></a>7.3.3 扩展资料</h3><p><a href="https://reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html">React Profiler 博客</a></p><p><a href="http://www.brendangregg.com/flamegraphs.html">理解火焰图</a></p><p><a href="https://reactjs.org/docs/profiler.html#gatsby-focus-wrapper">React Profiler API</a></p><p><a href="https://www.codementor.io/blog/react-optimization-5wiwjnf9hj">React 优化手段</a></p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React hooks</title>
      <link href="/11559/"/>
      <url>/11559/</url>
      
        <content type="html"><![CDATA[<h2 id="8-1-React-hooks"><a href="#8-1-React-hooks" class="headerlink" title="8.1 React-hooks"></a>8.1 React-hooks</h2><h3 id="8-1-1-hooks使命"><a href="#8-1-1-hooks使命" class="headerlink" title="8.1.1 hooks使命"></a>8.1.1 hooks使命</h3><h4 id="逻辑组件复用"><a href="#逻辑组件复用" class="headerlink" title="逻辑组件复用"></a>逻辑组件复用</h4><ul><li><p>逻辑与UI组件分离</p><p>React 官方推荐在开发中将逻辑部分与视图部分结耦，便于定位问题和职责清晰</p></li><li><p>函数组件拥有state</p><p>在函数组件中如果要实现类似拥有state的状态，必须要将组件转成class组件</p></li><li><p>逻辑组件复用</p></li></ul><p> 社区一直致力于逻辑层面的复用，像 render props / HOC，不过它们都有对应的问题，Hooks是目前为止相对完美的解决方案</p><h4 id="hooks-解决的问题"><a href="#hooks-解决的问题" class="headerlink" title="hooks 解决的问题"></a>hooks 解决的问题</h4><p>render props</p><p>Avator 组件是一个渲染头像的组件，里面包含其中一些业务逻辑，User组件是纯ui组件，用于展示用户昵称</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> funtion <span class="function"><span class="title">APP</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Avatar</span>&gt;</span></span></span><br><span class="line"><span class="xml">               &#123;data=&gt; <span class="tag">&lt;<span class="name">User</span> <span class="attr">name</span>=<span class="string">&#123;data&#125;/</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">Avatar</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过渲染props来实现逻辑组件复用</li><li>render props 通过嵌套组件实现，在真实的业务中，会出现嵌套多层，以及梭理props不清晰的问题</li></ul><p>Hoc</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Avatar</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">funtion <span class="function"><span class="title">HocAvatar</span>(<span class="params">Component</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">()=&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">Component</span> <span class="attr">name</span>=<span class="string">&#x27;王艺瑾&#x27;</span>/&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过对现有组件进行扩展、增强的方式来实现复用，通常采用包裹方法来实现</li><li>高阶组件的实现会额外地增加元素层级，使得页面元素的数量更加臃肿</li></ul><p>Hooks</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;useState&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">HooksAvatar</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [name,setName]=useState(<span class="string">&#x27;王一瑾&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;&gt;</span>&#123;name&#125;<span class="tag">&lt;/&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>React 16.8引入的Hooks，使得实现相同功能而代码量更少成为现实</li><li>通过使用Hooks，不仅在编码层面减少代码的数量，同样在编译之后的代码也会更少</li></ul><h3 id="8-1-2-hooks实践"><a href="#8-1-2-hooks实践" class="headerlink" title="8.1.2 hooks实践"></a>8.1.2 hooks实践</h3><h4 id="Hook官方APi（大概率用到的）"><a href="#Hook官方APi（大概率用到的）" class="headerlink" title="Hook官方APi（大概率用到的）"></a>Hook官方APi（大概率用到的）</h4><ul><li>useState<br>函数组件中的state方法</li><li>useEffect<br>函数组件处理副作用的方法，什么是副作用？异步请求、订阅原生的dom实事件、setTimeoutd等</li><li>useContext<br>接受一个context对象（React.createContext的返回值）并返回该context的当前值，当前的context由上层组件中距离最近的<code>&lt;Mycontext.provider&gt;&lt;/Mycontext.provider&gt;</code>的<br>value prop决定</li><li>useReducer<br>另一种”useState”，跟redux有点类似</li><li>useRef<br>返回一个突变的ref对象，对象在函数的生命周期内一直存在</li><li>useMemo 缓存数值</li><li>useCallback 缓存函数</li><li>useCustom<br>自定义Hooks组件</li></ul><ol><li>useState </li></ol><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;useState&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">const</span> HooksTest = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 声明一个count的state变量，useState可以给一个默认值</span></span><br><span class="line">    <span class="keyword">const</span> [count,setCount]=useState(<span class="number">0</span>) </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        useState也可以传递一个函数，</span></span><br><span class="line"><span class="comment">            const [count,setCount]=useState(()=&gt;&#123;</span></span><br><span class="line"><span class="comment">            return 2</span></span><br><span class="line"><span class="comment">        &#125;)  </span></span><br><span class="line"><span class="comment">        setCount也可以传递一个函数</span></span><br><span class="line"><span class="comment">        这个函数第一个参数可以拿到上一次的值，</span></span><br><span class="line"><span class="comment">        在可以在函数里做一些操作</span></span><br><span class="line"><span class="comment">        setCount((preState)=&gt;&#123;</span></span><br><span class="line"><span class="comment">            return &#123;...preState,..updatedValues&#125;</span></span><br><span class="line"><span class="comment">        &#125;) </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &#123;<span class="comment">/*通过setCount来改变count的值*/</span>&#125;</span><br><span class="line">            &lt;button onClick=&#123;<span class="function">()=&gt;</span>&#123;</span><br><span class="line">               setCount(count+<span class="number">1</span>) </span><br><span class="line">            &#125;&#125;</span><br><span class="line">            &gt;Add&lt;/button&gt;</span><br><span class="line">            &#123;count&#125;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ol start="2"><li>useEffect</li></ol><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;useEffect&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="comment">// 我们可以把useEffect 看做componentDidmount、componentDidUpdate、componntWillUnmount</span></span><br><span class="line"><span class="keyword">const</span> HooksTest = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// useEffect可以让你在第一个参数的函数中执行副作用操作，就是请求数据，dom操作之类的</span></span><br><span class="line">    <span class="comment">// useEffect返回一个函数，函数里表示要清除的副作用，例如清除定时器,返回的函数会在卸载组件时执行</span></span><br><span class="line">    useEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">clearInterval</span>(timer)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      useEffect的第二个参数，通过在数组中传递值，例如只有count变化时才调用Effect，达到</span></span><br><span class="line"><span class="comment">      不用每次渲染后都执行清理或执行effect导致的性能问题</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    useEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">     <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">    &#125;,[count])</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    如果想执行只运行一次的effect（仅在组件挂载和卸载时执行），可以传递一个空数组，</span></span><br><span class="line"><span class="comment">    告诉React你的Effect不依赖与props或state中任何值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    useEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">     <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">    &#125;,[])</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">      可以使用多个Effect，将不相关的逻辑分离到不同的effect中</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   useEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">       axios.get(<span class="string">&#x27;login&#x27;</span>)</span><br><span class="line">   &#125;,[])</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">         <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>You clicked &#123;count&#125; times<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="xml">                Click me</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">         <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>useContext</li></ol><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 创建一个上下文管理组件context-manager.js，用于统一导出context实例</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ItemsContext = React.createContext(&#123; <span class="attr">name</span>: <span class="string">&#x27;&#x27;</span> &#125;) <span class="comment">//接受一个默认值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 父组件提供数据</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Child <span class="keyword">from</span> <span class="string">&#x27;./child&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; ItemsContext &#125; <span class="keyword">from</span> <span class="string">&#x27;./context-manager&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./index.scss&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> items = &#123; <span class="attr">name</span>: <span class="string">&#x27;测试&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">const</span> Father = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;father&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">ItemsContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;items&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Child</span>&gt;</span><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">ItemsContext.Provider</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Father</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.子组件用useContext解析上下文</span></span><br><span class="line"><span class="keyword">import</span> React ,&#123;useContext&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; ItemsContext &#125; <span class="keyword">from</span> <span class="string">&#x27;./context-manager&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./index.scss&#x27;</span></span><br><span class="line"><span class="keyword">const</span> Child = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> items=useContext(ItemsContext)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;child&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        子组件</span></span><br><span class="line"><span class="xml">        &#123;items.name&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Child</span><br></pre></td></tr></table></figure><ol start="4"><li>useReducer</li></ol><p>useReducer是useState的替代方案，它接受一个形如(state,action)=&gt;newState的reducer，并返回当前的state以及与其配套的dispatch方法</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;useReducer&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">const</span> initialState=&#123;<span class="attr">count</span>:<span class="number">0</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span> (<span class="params">state,action</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.type)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;increment&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">count</span>:state.count+<span class="number">1</span>&#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;decrement&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">count</span>:state.count-<span class="number">1</span>&#125;</span><br><span class="line">        <span class="attr">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> [state.dispatch]=useReducer(reducer,initialState)</span><br><span class="line"><span class="keyword">const</span> HooksTest = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &#123;state.count&#125;</span><br><span class="line">            &lt;button onClick=&#123;<span class="function">()=&gt;</span>&#123;</span><br><span class="line">             dispatch(&#123;<span class="attr">type</span>:<span class="string">&#x27;increment&#x27;</span>&#125;)</span><br><span class="line">            &#125;&#125;&gt;increment&lt;/button&gt;</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="xml">             dispatch(&#123;type:&#x27;decrement&#x27;&#125;)</span></span><br><span class="line"><span class="xml">            &#125;&#125;&gt;increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">        &lt;div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><ol start="5"><li>useRef</li></ol><ul><li>获取dom</li></ul><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;useRef&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">const</span> HooksTest = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> inputEl=useRef(<span class="literal">null</span>)</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">onButtion</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//  inputEl.current 就是我们获取的dom对象</span></span><br><span class="line">      inputEl.current.focus() </span><br><span class="line">   &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;input type=&#x27;text&#x27; ref=&#123;inputEl&#125;&gt;</span><br><span class="line">            &lt;button onClick=&#123;onButtion&#125;</span><br><span class="line">            &gt;Add&lt;/button&gt;</span><br><span class="line">            &#123;count&#125;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>存变量</li></ul><p>因为在函数式组件里没有this来存放一些实例的变量，所以React建议使用useRef来存放有一些会发生变化的值，useRef 不单是为了DOM的ref，同时也是为了存放实例属性</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> intervalRef=useRef()</span><br><span class="line">useEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    intervalRef.current=setInterVal(<span class="function">()=&gt;</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">clearInterval</span>(intervalRef.current)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="6"><li>useImperativeHandle</li></ol><p>可以让你在使用ref时自定义暴露给父组件的实例值,useImperativeHandle 应当与forwardRef 一起使用，这样可以父组件可以调用子组件的方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">const</span> modelRef = useRef(<span class="literal">null</span>);</span><br><span class="line"> <span class="comment">/* 确定 */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sureBtn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 调用子组件的方法</span></span><br><span class="line">    inputRef.current.model();</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">return</span> (</span><br><span class="line">     <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onClick</span>=<span class="string">&#123;sureBtn&#125;</span>&gt;</span>确定<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;<span class="name">Children</span> <span class="attr">ref</span>=<span class="string">&#123;modelRef&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Children</span>&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;/&gt;</span></span></span><br><span class="line"> )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="keyword">const</span> Children = React.forwardRef(<span class="function">(<span class="params">props,ref</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">const</span> [visible, setVisible] = useState(<span class="literal">false</span>);</span><br><span class="line">    useImperativeHandle(ref, <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">      <span class="attr">model</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        setVisible(<span class="literal">true</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="7"><li>useMemo</li></ol><p>useMemo的理念和memo差不多，都是根据判断是否满足当前的有限条件来决定是否执行useMemo的callback函数，第二个参数是一个deps数组，数组里的参数变化决定了useMemo是否更新回调函数。</p><p>useMemo和useCallback参数一样，区别是useMemo的返回的是缓存的值，useCallback返回的是函数。</p><ul><li>useMemo减少不必要的渲染<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用 useMemo包裹的list可以限定当且仅当list改变的时候才更新此list，这样就可以避免List重新循环 </span></span><br><span class="line"> &#123;useMemo(<span class="function">() =&gt;</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;</span></span><br><span class="line"><span class="xml">          list.map((i, v) =&gt; (</span></span><br><span class="line"><span class="xml">              <span class="tag">&lt;<span class="name">span</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                  <span class="attr">key</span>=<span class="string">&#123;v&#125;</span> &gt;</span></span></span><br><span class="line"><span class="xml">                  &#123;i.patentName&#125; </span></span><br><span class="line"><span class="xml">              <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">          ))&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">), [list])&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>useMemo减少子组件的渲染次数</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">useMemo(<span class="function">() =&gt;</span> (</span><br><span class="line">    &#123; <span class="comment">/* 减少了PatentTable组件的渲染 */</span> &#125;</span><br><span class="line">       &lt;PatentTable</span><br><span class="line">           getList=&#123;getList&#125;</span><br><span class="line">           selectList=&#123;selectList&#125;</span><br><span class="line">           cacheSelectList=&#123;cacheSelectList&#125;</span><br><span class="line">           setCacheSelectList=&#123;setCacheSelectList&#125; /&gt;</span><br><span class="line">), [listshow, cacheSelectList])</span><br></pre></td></tr></table></figure><ul><li>useMemo避免很多不必要的计算开销</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> Demo=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">/* 用useMemo 包裹之后的log函数可以避免了每次组件更新再重新声明 ，可以限制上下文的执行 */</span></span><br><span class="line">    <span class="keyword">const</span> newLog = useMemo(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">     <span class="keyword">const</span> log =<span class="function">()=&gt;</span>&#123;</span><br><span class="line">           <span class="comment">// 大量计算 </span></span><br><span class="line">           <span class="comment">// 在这里面不能获取实时的其他值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> log</span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="comment">// or</span></span><br><span class="line">   <span class="keyword">const</span> log2 = useMemo（()=&gt;&#123;</span><br><span class="line">           <span class="comment">// 大量计算 </span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="comment">// 计算后的值</span></span><br><span class="line">    &#125;,[list])</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>newLog()&#125; &gt;&#123;log2&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>useCallback</li></ol><p>useMemo和useCallback接收的参数都是一样，都是依赖项发生变化后才会执行；useMemo返回的是函数运行结果，useCallback返回的是函数；父组件传递一个函数<br>给子组件的时候，由于函数组件每一次都会生成新的props函数，这就使的每次一个传递给子组件的函数都发生的变化，这样就会触发子组件的更新，有些更新是没有必要的。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> Father=<span class="function">(<span class="params">&#123; id &#125;</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> getInfo  = useCallback(<span class="function">(<span class="params">sonName</span>)=&gt;</span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(sonName)</span><br><span class="line">    &#125;,[id])</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;/* 点击按钮触发父组件更新 ，但是子组件没有更新 */&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span>setNumber(number+1) &#125; &gt;增加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">DemoChildren</span> <span class="attr">getInfo</span>=<span class="string">&#123;getInfo&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用react.memo */</span></span><br><span class="line"><span class="keyword">const</span> Children = React.memo(<span class="function">(<span class="params">props</span>)=&gt;</span>&#123;</span><br><span class="line">   <span class="comment">/* 只有初始化的时候打印了 子组件更新 */</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;子组件更新&#x27;</span>,props.getInfo())</span><br><span class="line">   <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>子组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>useCallback必须配合 react.memo pureComponent，否则不但不会提升性能，还有可能降低性能。</p><p>react-hooks的诞生，也不是说它能够完全代替class声明的组件，对于业务比较复杂的组件，class组件还是首选，只不过我们可以把class组件内部拆解成funciton组件，根据业务需求，哪些负责逻辑交互，哪些需要动态渲染，然后配合usememo等api，让性能提升起来。react-hooks使用也有一些限制条件，比如说不能放在流程控制语句中，执行上下文也有一定的要求。</p><h3 id="8-1-5扩展资料"><a href="#8-1-5扩展资料" class="headerlink" title="8.1.5扩展资料"></a>8.1.5扩展资料</h3><p><a href="https://reactjs.org/docs/hooks-intro.html">React Hooks 官方文档</a></p><p><a href="https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/">useEffect 完整指南</a></p><h2 id="8-2-React-hooks原理解析"><a href="#8-2-React-hooks原理解析" class="headerlink" title="8.2 React-hooks原理解析"></a>8.2 React-hooks原理解析</h2><h3 id="8-2-1-前言"><a href="#8-2-1-前言" class="headerlink" title="8.2.1 前言"></a>8.2.1 前言</h3><p>::: warning<br>阅读以下内容之前先了解一下，<a href="https://zh-hans.reactjs.org/docs/hooks-intro.html#motivation">hooks出现的动机</a>,同时也要熟悉hooks的用法，可以参考上一篇文章；看完<code>useState</code>、<code>useEffect</code>源码，我相信你已经基本掌握了hooks；其它的很简单。<br>:::</p><p>废话不多说，我首先克隆一份代码下来</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --branch v17.0.2 https://github.com/facebook/react.git</span><br></pre></td></tr></table></figure><p>hooks导出部分在<code>react/packages/react/src/ReactHooks.js</code>，虽然在react导出，但是真正实现在<code>react-reconciler</code>这个包里面。</p><p>前置知识点:</p><ol><li>fiber</li></ol><p> Fiber是一种数据结构，React使用链表把VirtualDOM节点表示一个Fiber，Fiber是一个执行单元，每次执行完一个执行单元，React会检查现在还剩多少时间，如果没有时间就将控制权让出去，去执行一些高优先级的任务。</p><ol start="2"><li>循环链表</li></ol><p><img src="~@/react/hooksupdate.png"></p><ul><li>是一种链式存储结构，整个链表形成一个环</li><li>它的特点是最后一个节点的指针指向头节点</li></ul><p>读源码，我们逐个击破的方式:</p><ol><li><p>useState</p></li><li><p>useEffect</p></li><li><p>useRef</p></li><li><p>useCallback</p></li><li><p>useMemo</p></li></ol><p><code>hooks不是一个新api也不是一个黑魔法，就是单纯的一个数组，看下面的例子hooks api返回一个数组，一个是当前值，一个是设置当前值的函数。</code></p><h4 id="hooks中的useState"><a href="#hooks中的useState" class="headerlink" title="hooks中的useState"></a>hooks中的useState</h4><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React ,&#123;useState&#125;<span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [name,setName]=useState(<span class="string">&#x27;王艺瑾&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">             <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">             <span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span> setName(&#x27;张艺凡&#x27;)&#125;</span></span><br><span class="line"><span class="xml">               &gt;切换<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">           <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">       );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><ul><li><p>上边是一个非常简单的Hook API，创建了name和setName，在页面上展示name，按钮的点击事件修改name</p></li><li><p>那么在这个过程中setState是如何实现的呢？</p></li></ul><h4 id="react-包中导出的useState"><a href="#react-包中导出的useState" class="headerlink" title="react 包中导出的useState"></a>react 包中导出的useState</h4><p>源码出处：<code>react/packages/react/src/ReactHooks.js</code></p><p>react包中导出的usesate，其实没什么东西，大致看一下就能明白</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useState</span>&lt;<span class="title">S</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  initialState: (() =&gt; S) | S, <span class="comment">// flow类型注解</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dispatcher = resolveDispatcher();</span><br><span class="line">  <span class="keyword">return</span> dispatcher.useState(initialState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>ReactHooks.js</code>搜索到了useState，函数里先执行了<code>resolveDispatcher</code>,我们先看看resolveDispatcher函数做了写什么？<br><code>resolveDispatcher</code>函数的执行，获取了<code>ReactCurrentDispatcher</code>的current，那我们在看看<code>ReactCurrentDispatcher</code>是什么？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveDispatcher</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dispatcher = ReactCurrentDispatcher.current;</span><br><span class="line">  invariant(</span><br><span class="line">    dispatcher !== <span class="literal">null</span>,</span><br><span class="line">    <span class="string">&#x27;Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27; one of the following reasons:\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;1. You might have mismatching versions of React and the renderer (such as React DOM)\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;2. You might be breaking the Rules of Hooks\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;3. You might have more than one copy of React in the same app\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.&#x27;</span>,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> dispatcher;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码出处：<code>react/packages/react/src/ReactCurrentDispatcher.js</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Keeps track of the current dispatcher.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> ReactCurrentDispatcher = &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@internal</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@type <span class="type">&#123;ReactComponent&#125;</span></span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">current</span>: (<span class="literal">null</span>: <span class="literal">null</span> | Dispatcher),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ReactCurrentDispatcher;</span><br></pre></td></tr></table></figure><p><code>ReactCurrentDispatcher</code>现在是null，到这里我们线索好像中断了，因为current要有个hooks方法才行；我们可以断点的形式，去看看在mount阶段，react执行了什么？也就是在mount阶段ReactCurrentDispatcher.current挂载的hooks，蓝色部分就是react在初始化阶段执行的函数</p><p><img src="~@/react/Hooksprinciple.png"></p><p><font color="red">下面才是正文，千万不要放弃</font></p><p>源码出处：<code>react/packages/react-reconciler/src/ReactFiberHooks.new.js</code></p><p> renderWithHooks</p><ul><li>为什么从renderWithhooks讲起？</li></ul><p>因为<code>renderWithhooks</code>是调用函数组件的主要函数，所有的函数组件执行，都会执行这个方法。</p><p>下面我说的<code>hooks</code>代表组件中的hooks，例如：useState；<code>hook对象</code>是每次执行<code>hooks</code>所创建的对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 挂载和更新页面的时候，用的是不同的hooks，hooks在不同的阶段有不同的实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  举个例子，页面在初始化阶段我们在页面中调用的useSate实际调用的是mountState，</span></span><br><span class="line"><span class="comment">  在更新阶段调用的是updateState；其他的hooks也是同理</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> HooksDispatcherOnMount = &#123; <span class="comment">// 存储初次挂载的hook</span></span><br><span class="line">    <span class="attr">useState</span>: mountState,</span><br><span class="line">    <span class="attr">useEffect</span>:mountEffect</span><br><span class="line">     ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> HooksDispatcherOnUpdate = &#123; <span class="comment">// 存储更新时候的hook</span></span><br><span class="line">     <span class="attr">useState</span>: updateState,</span><br><span class="line">     <span class="attr">useEffect</span>:updateEffect</span><br><span class="line">     ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> currentlyRenderingFiber; <span class="comment">//当前正在使用的fiber</span></span><br><span class="line"><span class="keyword">let</span> workInProgressHook = <span class="literal">null</span> <span class="comment">// 存储当前最新的hook，跟链表有关系，往下看会明白</span></span><br><span class="line"><span class="keyword">let</span> currentHook=<span class="literal">null</span> <span class="comment">// 在组件更新阶段对应是老的hook</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>current 上一个fiber 初次挂载 的时候null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>workInProgress 这一次正在构建中的fiber树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>Component 当前组件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">renderWithHooks</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  current, </span></span></span><br><span class="line"><span class="params"><span class="function">  workInProgress, </span></span></span><br><span class="line"><span class="params"><span class="function">  Component,</span></span></span><br><span class="line"><span class="params"><span class="function">  props,</span></span></span><br><span class="line"><span class="params"><span class="function">  secondArg,</span></span></span><br><span class="line"><span class="params"><span class="function">  </span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// currentlyRenderingFiber指向本次要构建的fiber（workInProgress）</span></span><br><span class="line">   <span class="comment">// 要区分一下workInProgress和workInProgressHook，不要搞混了</span></span><br><span class="line">    currentlyRenderingFiber = workInProgress; </span><br><span class="line"></span><br><span class="line">   <span class="comment">//在执行组件方法之前，要清空hook链表 因为你肯定要创建新的hook链表，要把新的信息挂载到这2个属性上</span></span><br><span class="line">   <span class="comment">//在函数组件中 memoizedState以链表的形式存放hook信息，如果在class组件中，memoizedState存放state信息</span></span><br><span class="line">    workInProgress.memoizedState = <span class="literal">null</span>;</span><br><span class="line">   <span class="comment">// updateQueue存 effect对象，阅读完useEffect源码就会明白</span></span><br><span class="line">    workInProgress.updateQueue = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// current === null || current.memoizedState === null 说明是mount阶段，否则是update阶段</span></span><br><span class="line">    <span class="comment">// 我们就在这里给ReactCurrentDispatcher.current赋值了</span></span><br><span class="line">     ReactCurrentDispatcher.current =</span><br><span class="line">      current === <span class="literal">null</span> || current.memoizedState === <span class="literal">null</span></span><br><span class="line">        ? HooksDispatcherOnMount</span><br><span class="line">        : HooksDispatcherOnUpdate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用我们的组件函数，然后我们组件里的hooks才会被依次执行</span></span><br><span class="line">    <span class="keyword">let</span> children = Component(props,secondArg); </span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    我们的hooks必须写在组件函数的内部，当上面组件里的hooks执行完后，</span></span><br><span class="line"><span class="comment">    我们又给ReactCurrentDispatcher.current赋值了，ContextOnlyDispatcher会报错的形式提示，hooks不能函数外面；</span></span><br><span class="line"><span class="comment">    在不同的阶段赋值不同的hooks对象，判断hooks执行是否在函数组件内部</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    ReactCurrentDispatcher.current = ContextOnlyDispatcher;</span><br><span class="line"></span><br><span class="line">    currentlyRenderingFiber = <span class="literal">null</span>;<span class="comment">//渲染结束 后把currentlyRenderingFiber清空</span></span><br><span class="line">    workInProgressHook = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 指向当前调度的hooks节点,主要用于update阶段</span></span><br><span class="line">    currentHook = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> children;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不在函数内写的hooks指向的函数</span></span><br><span class="line"><span class="keyword">const</span> ContextOnlyDispatcher = &#123;</span><br><span class="line">    <span class="attr">useState</span>:throwInvalidHookError</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throwInvalidHookError</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  invariant(</span><br><span class="line">    <span class="literal">false</span>,</span><br><span class="line">    <span class="string">&#x27;Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27; one of the following reasons:\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;1. You might have mismatching versions of React and the renderer (such as React DOM)\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;2. You might be breaking the Rules of Hooks\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;3. You might have more than one copy of React in the same app\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;See https://fb.me/react-invalid-hook-call for tips about how to debug and fix this problem.&#x27;</span>,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>renderWithHooks主要做的事情：</p><ol><li>判断是mount阶段还是update阶段给ReactCurrentDispatcher.current赋值。</li><li>执行组件函数，执行hooks。</li><li>清空在执行hooks所赋值的全局对象，下一次更新函数需要再次用到。</li></ol><ul><li><p>有几个memoizedState，需要注意：</p><ol><li><code>currentlyRenderingFiber.memoizedState</code> 是存整个链表，就是每次执行hooks就会创建hook对象，多个hooks所形成的链表。</li><li><code>hook.memoizedState</code> 用于存当前执行的hooks的一些信息。</li></ol></li><li><p>workInProgress和workInProgressHook：</p><ol><li><code>workInProgress</code> 正在构建的fiber</li><li><code>workInProgressHook</code> 正在构建的hook对象</li></ol></li><li><p>currentHook和workInProgressHook</p><ol><li><code>currentHook</code>主要用于更新阶段，在mount阶段创建了hook对象，在更新阶段我们需要取出来，需要复用上一次存的信息，<code>currentHook</code>就是正在执行的这个hooks上一次存的信息。</li><li><code>workInProgressHook</code>正在创建的hook对象，在mount和update阶段都会创建。</li></ol></li></ul><ul><li><p>current：初始化阶段为null，当第一次渲染之后会产生一个fiber树，最终会换成真实的dom树</p></li><li><p>workInProgress：正在构建的fiber树，更新过程中会从current赋值给workInProgress，更新完毕后将当前的<br>workInProgress树赋值给current。</p></li></ul><h3 id="8-2-2-useState"><a href="#8-2-2-useState" class="headerlink" title="8.2.2 useState"></a>8.2.2 useState</h3><h4 id="tomato-mount阶段"><a href="#tomato-mount阶段" class="headerlink" title=":tomato: mount阶段 "></a>:tomato: mount阶段 <Badge text="重要" ></Badge></h4><h4 id="1-mountState"><a href="#1-mountState" class="headerlink" title="1. mountState"></a>1. mountState</h4><p>初次挂载的时候，useState对应的函数是mountState</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">basicStateReducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> action === <span class="string">&#x27;function&#x27;</span> ? action(state) : action;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountState</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  initialState</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 返回当前正在运行的hook对象,构建hook单项链表，下面会详细讲解</span></span><br><span class="line">  <span class="keyword">const</span> hook = mountWorkInProgressHook();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     初始值如果是函数，就执行函数拿到初始值</span></span><br><span class="line"><span class="comment">     useState((preState)=&gt; return &#x27;初始值&#x27;)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> initialState === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    initialState = initialState();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 把初始值赋值给 hook.baseState和hook.memoizedState</span></span><br><span class="line">  hook.memoizedState = hook.baseState = initialState;</span><br><span class="line"> <span class="comment">// 定义一个队列</span></span><br><span class="line">  <span class="keyword">const</span> queue = (hook.queue = &#123;</span><br><span class="line">    <span class="attr">pending</span>: <span class="literal">null</span>, <span class="comment">// 存放update对象</span></span><br><span class="line">    <span class="attr">dispatch</span>: <span class="literal">null</span>,  <span class="comment">// 放hooks更新函数</span></span><br><span class="line">    <span class="attr">lastRenderedReducer</span>: basicStateReducer, <span class="comment">//它是一个函数， 用于得到最新的 state</span></span><br><span class="line">    <span class="attr">lastRenderedState</span>: initialState,  <span class="comment">// 最后一次得到的 state</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">  dispatchAction 是负责更新的函数,就是代表下面的setState函数</span></span><br><span class="line"><span class="comment">  const [state,setState]=useState()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="keyword">const</span> dispatch = (queue.dispatch = (dispatchAction.bind(</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    currentlyRenderingFiber,</span><br><span class="line">    queue,</span><br><span class="line">  )));</span><br><span class="line"></span><br><span class="line"> <span class="comment">//  2个值以数值的形式返回</span></span><br><span class="line">  <span class="keyword">return</span> [hook.memoizedState, dispatch];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mountState主要做的事情：</p><ol><li>创建hook对象，在上面存上hooks信息，下次更新的时候可以从对象上获取。</li><li>返回一个数组，包括初始化的值和更新函数<h4 id="2-mountWorkInProgressHook"><a href="#2-mountWorkInProgressHook" class="headerlink" title="2. mountWorkInProgressHook"></a>2. mountWorkInProgressHook</h4></li></ol><p>构建hooks单向链表，将组件中的hooks函数以链表的形式串连起来，并赋值给workInProgress的memoizedState；</p><p>例子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">work</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [name,setName]=useState(<span class="string">&#x27;h&#x27;</span>) <span class="comment">// hooks1</span></span><br><span class="line">  <span class="keyword">const</span> age=useRef(<span class="number">20</span>) <span class="comment">// hooks2</span></span><br><span class="line">   useEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;,[]) <span class="comment">// hooks3</span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 构建单向链表</span></span><br><span class="line"> currentlyRenderingFiber.memoizedState=&#123;</span><br><span class="line">   <span class="attr">memoizedState</span>:<span class="string">&#x27;h&#x27;</span>,</span><br><span class="line">   <span class="attr">next</span>:&#123;</span><br><span class="line">      <span class="attr">memoizedState</span>:<span class="string">&#x27;20&#x27;</span>,</span><br><span class="line">      <span class="attr">next</span>:&#123;</span><br><span class="line">          <span class="attr">memoizedState</span>:effect,</span><br><span class="line">          <span class="attr">next</span>:<span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// hooks1的next指向hooks2，hooks2的next指向hooks3</span></span><br></pre></td></tr></table></figure><p><img src="~@/react/mountLinkedlist.png"></p><p>为什么构建一个单向链表？</p><p>因为我们在组件更新阶段，需要拿到上次的值，拿到上次的值与本次设置的值做对比来判断是否更新</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountWorkInProgressHook</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//创建一个hooks对象</span></span><br><span class="line">  <span class="keyword">const</span> hook  = &#123; </span><br><span class="line">    <span class="attr">memoizedState</span>: <span class="literal">null</span>, <span class="comment">// useState中保存state信息，useEffect中保存Effect对象，useMemo中保存缓存的值和依赖；useRef保存的是ref对象</span></span><br><span class="line">    <span class="attr">baseState</span>: <span class="literal">null</span>, <span class="comment">// useState和useReducer中保存最新的state</span></span><br><span class="line">    <span class="attr">baseQueue</span>: <span class="literal">null</span>,<span class="comment">// useState和useReducer中保存最新的更新队列</span></span><br><span class="line">    <span class="attr">queue</span>: <span class="literal">null</span>, <span class="comment">// 自己的更新队列，形成环状链表</span></span><br><span class="line">    <span class="attr">next</span>: <span class="literal">null</span>, <span class="comment">// 下一个更新，就是我们下的页面中下一个hooks</span></span><br><span class="line">  &#125;;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (workInProgressHook === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//说明这是我们的第一个hook</span></span><br><span class="line">        currentlyRenderingFiber.memoizedState = workInProgressHook = hook;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 说明函数组件中不止一个hooks</span></span><br><span class="line">        workInProgressHook = workInProgressHook.next = hook;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workInProgressHook;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上面构建hooks单向链表没有看懂，请看下面解析</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (workInProgressHook === <span class="literal">null</span>) &#123;</span><br><span class="line">   <span class="comment">//说明这是我们的第一个hook</span></span><br><span class="line">     currentlyRenderingFiber.memoizedState = workInProgressHook = hook;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// 说明函数组件中不止一个hooks</span></span><br><span class="line">     workInProgressHook = workInProgressHook.next = hook;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>第一次我们创建了hook对象，在堆内存中开辟了一块空间， <code>currentlyRenderingFiber.memoizedState</code>、<code>workInProgressHook</code>都指向了这个值，对象是引用类型值；我们称这个值为hooks1吧。</li></ol><p>currentlyRenderingFiber.memoizedState = hooks1</p><ol start="2"><li>第二次我们再次创建了hook对象，在堆内存中又开辟了一块空间，我们称这个值为hooks2吧，<code>workInProgressHook.next</code>指向了hooks2，也就是hooks1.next指向了hook2；因为当前的<code>workInProgressHook</code>和hooks1指向同一个地址，只要有一个修改内存里的值，其他变量只要引用该值了，也会随之发生变化；最后又把hooks2又赋值给<code>workInProgressHook</code>，那么<code>workInProgressHook</code>又指向了hooks2。</li></ol><p>hooks1.next= hooks2</p><p>workInProgressHook=hooks2</p><ol start="3"><li>第三次我们再次创建了hook对象，在堆内存中又开辟了一块空间，我们称这个值为hooks3吧，hooks3又赋值给了<code>workInProgressHook.next</code>，现在的workInProgressHook和hooks2指向是同一个地址，那么我改变<code>workInProgressHook.next</code>就是改变hooks2的next。</li></ol><p>hooks2.next= hooks3</p><p>workInProgressHook=hooks3</p><p>workInProgressHook始终和最新hook对象指向同一个地址，这样就方便修改上一个hook对象的next</p><h4 id="3-dispatchAction"><a href="#3-dispatchAction" class="headerlink" title="3. dispatchAction"></a>3. dispatchAction</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>fiber 当前正在使用的fiber</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>queue 队列的初始对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>action 更新函数或者要更新的值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchAction</span>(<span class="params">fiber, queue, action</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个update对象</span></span><br><span class="line"> <span class="keyword">const</span> update= &#123;</span><br><span class="line">    action,</span><br><span class="line">    <span class="attr">eagerReducer</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">eagerState</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">next</span>: <span class="literal">null</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> pending = queue.pending;</span><br><span class="line">  <span class="keyword">if</span> (pending === <span class="literal">null</span>) &#123;  <span class="comment">// 证明第一次更新</span></span><br><span class="line">    update.next = update;<span class="comment">//让自己和自己构建成一个环状链表</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不是第一次更新</span></span><br><span class="line">    update.next = pending.next;</span><br><span class="line">    pending.next = update;</span><br><span class="line">  &#125;</span><br><span class="line">  queue.pending = update;</span><br><span class="line"><span class="comment">// queue.pending`永远指向最后一个更新，pending.next 永远指向第一个更新</span></span><br><span class="line">  <span class="keyword">const</span> currentState = queue.lastRenderedState;<span class="comment">// 上一次的state</span></span><br><span class="line">  <span class="keyword">const</span> eagerState = lastRenderedReducer(currentState, action);<span class="comment">//获取最新的state</span></span><br><span class="line"></span><br><span class="line">  update.eagerState = eagerState; </span><br><span class="line">  <span class="comment">// 判断上一次的值和当前的值是否一样，是同一个值或同一个引用就return，不进行更新</span></span><br><span class="line">  <span class="keyword">if</span> (is(eagerState, currentState)) &#123; </span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调度渲染当前fiber，scheduleUpdateOnFiber是react渲染更新的主要函数。</span></span><br><span class="line">  scheduleUpdateOnFiber(fiber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类组件更新调用<code>setState</code>,函数组件hooks更新调用<code>dispatchAction</code>,都会产生一个update对象，里面记录此处更新的信息；<br>把update对象放在<code>queue.pending</code>上。</p><p>为什么创建update对象？</p><p>每次创建update对象，是希望形成一个环状链表。我们看下面一个例子，三次setCount的update对象会暂时放在<code>queue.pending</code>上，组件里的state不会立即更新，在下一次函数组件执行的时候，三次update会被合并到baseQueue上，我们要获取最新的状态，会一次执行update上的每一个action，得到最新的state。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">work</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count,setCount]=useState(<span class="number">0</span>) </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    setCount(<span class="number">1</span>)</span><br><span class="line">    setCount(<span class="number">2</span>)</span><br><span class="line">    setCount(<span class="number">3</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;add&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么不是直接执行最后一个setCount？</p><p>如果<code>setCount((state)=&gt;&#123;state+1&#125;)</code>参数是函数，那么需要依赖state，下一个要依赖上一个的state；所以需要都执行一遍才能<br>拿到准确的值。</p><h4 id="tomato-update阶段"><a href="#tomato-update阶段" class="headerlink" title=":tomato: update阶段 "></a>:tomato: update阶段 <Badge text="重要" ></Badge></h4><h4 id="1-updateState"><a href="#1-updateState" class="headerlink" title="1.updateState"></a>1.updateState</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">basicStateReducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// $FlowFixMe: Flow doesn&#x27;t like mixed types</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> action === <span class="string">&#x27;function&#x27;</span> ? action(state) : action;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以看出updateState其实调用的是updateReducer</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateState</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  initialState</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> updateReducer(basicStateReducer, initialState);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateReducer</span>(<span class="params">reducer, initialArg</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> hook = updateWorkInProgressHook(); <span class="comment">// 构建新的链表</span></span><br><span class="line">    <span class="keyword">const</span> queue = hook.queue;<span class="comment">//hooks自己的更新队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// lastRenderedReducer用于得到最新state，它是一个函数</span></span><br><span class="line">    queue.lastRenderedReducer = reducer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// currentHook记录了当前这个hooks上一次存在链表上的memoizedState、queue、next等信息</span></span><br><span class="line">    <span class="keyword">const</span> current = currentHook;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// pendingQueue就是更新队列的最后一个update对象</span></span><br><span class="line">    <span class="keyword">const</span> pendingQueue  = queue.pending;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pendingQueue!==<span class="literal">null</span>)&#123;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">let</span> first = pendingQueue.next;<span class="comment">//第一个更新对象</span></span><br><span class="line">        <span class="keyword">let</span> newState = current.memoizedState;<span class="comment">//拿到老状态</span></span><br><span class="line">        <span class="keyword">let</span> update = first;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> action = update.action;<span class="comment">//action：就是传的参数，例如setState(&#x27;参数&#x27;)</span></span><br><span class="line">            newState = reducer(newState,action);<span class="comment">//计算新状态，因为如果传的是函数，要依赖老状态</span></span><br><span class="line">            update = update.next;</span><br><span class="line">        &#125;<span class="keyword">while</span>(update !== <span class="literal">null</span> &amp;&amp; update !== first);</span><br><span class="line"></span><br><span class="line">        queue.pending = <span class="literal">null</span>;<span class="comment">//更新过了可以清空更新环形链表</span></span><br><span class="line">        hook.memoizedState =  newState;<span class="comment">//让新的hook对象的memoizedState等于计算的新状态    </span></span><br><span class="line">        queue.lastRenderedState = newState;<span class="comment">//把新状态也赋值给lastRenderedState一份</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> dispatch = dispatchAction.bind(<span class="literal">null</span>, currentlyRenderingFiber, queue);</span><br><span class="line">    <span class="keyword">return</span> [hook.memoizedState, dispatch];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-updateWorkInProgressHook"><a href="#2-updateWorkInProgressHook" class="headerlink" title="2. updateWorkInProgressHook"></a>2. updateWorkInProgressHook</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateWorkInProgressHook</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> nextCurrentHook;</span><br><span class="line">   <span class="comment">//currentHook为null，说明执行的是第一个hooks；currentHook就是老的hook对象</span></span><br><span class="line">    <span class="keyword">if</span>(currentHook === <span class="literal">null</span>)&#123;</span><br><span class="line">       <span class="comment">// current:老的fiber、workInProgress:正在构建的fiber</span></span><br><span class="line">      <span class="keyword">let</span> current = currentlyRenderingFiber.alternate;<span class="comment">//alternate属性 对应的是老的fiBer</span></span><br><span class="line">      <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 老的fiber的memoizedState对应的是链表的第一个节点</span></span><br><span class="line">        nextCurrentHook = current.memoizedState;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nextCurrentHook = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">// 不是第一个hooks，那么指向下一个 hooks</span></span><br><span class="line">        nextCurrentHook=currentHook.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    currentHook=nextCurrentHook;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建新的hook对象</span></span><br><span class="line">    <span class="keyword">const</span> newHook = &#123;</span><br><span class="line">        <span class="attr">memoizedState</span>:currentHook.memoizedState,</span><br><span class="line">        <span class="attr">queue</span>:currentHook.queue,</span><br><span class="line">        <span class="attr">next</span>:<span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新链表</span></span><br><span class="line">    <span class="keyword">if</span>(workInProgressHook === <span class="literal">null</span>)&#123;</span><br><span class="line">        currentlyRenderingFiber.memoizedState = workInProgressHook = newHook;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       workInProgressHook = workInProgressHook.next = newHook;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> workInProgressHook;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-3-useEffect"><a href="#8-2-3-useEffect" class="headerlink" title="8.2.3 useEffect"></a>8.2.3 useEffect</h3><h4 id="tomato-mount阶段-1"><a href="#tomato-mount阶段-1" class="headerlink" title=":tomato: mount阶段 "></a>:tomato: mount阶段 <Badge text="重要" ></Badge></h4><h4 id="1-mountEffect"><a href="#1-mountEffect" class="headerlink" title="1.  mountEffect"></a>1.  mountEffect</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;function&#125;</span> <span class="variable">create</span></span> - 回调函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> <span class="variable">deps</span></span> - 依赖数组</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> PassiveEffect = <span class="number">0b000000001000000000</span>; <span class="comment">// useEffect</span></span><br><span class="line"> <span class="keyword">const</span> PassiveStaticEffect = <span class="number">0b001000000000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountEffect</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  create,</span></span></span><br><span class="line"><span class="params"><span class="function">  deps,</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//  如果在代码中看见 __DEV__，可以不用关心，开发环境才会执行里面的代码，生产会tree shaking</span></span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;&#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mountEffectImpl(</span><br><span class="line">      PassiveEffect | PassiveStaticEffect, <span class="comment">// 按位操作</span></span><br><span class="line">      HookPassive,</span><br><span class="line">      create,</span><br><span class="line">      deps,</span><br><span class="line">    );</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-mountEffectImpl"><a href="#2-mountEffectImpl" class="headerlink" title="2. mountEffectImpl"></a>2. mountEffectImpl</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 位操作 ：| 、&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> HookHasEffect= <span class="number">0b001</span>;</span><br><span class="line"> hookFlags = <span class="number">0b100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountEffectImpl</span>(<span class="params">fiberFlags, hookFlags, create, deps</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = mountWorkInProgressHook(); <span class="comment">// 构建单向链表</span></span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  currentlyRenderingFiber.flags |= fiberFlags;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    每个hooks都会创建个hook对象，memoizedState在useState中保存的是state</span></span><br><span class="line"><span class="comment">    在useEffect中保存的effect对象</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  hook.memoizedState = pushEffect(</span><br><span class="line">    HookHasEffect | hookFlags,</span><br><span class="line">    create,</span><br><span class="line">    <span class="literal">undefined</span>,</span><br><span class="line">    nextDeps,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-pushEffect"><a href="#3-pushEffect" class="headerlink" title="3. pushEffect"></a>3. pushEffect</h4><p>pushEffect 创建effec对象，并形成环状链表存值与updateQueue上</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctionComponentUpdateQueue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">lastEffect</span>: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pushEffect</span>(<span class="params">tag, create, destroy, deps</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建effect对象</span></span><br><span class="line">  <span class="keyword">const</span> effect = &#123;</span><br><span class="line">    tag,</span><br><span class="line">    create,</span><br><span class="line">    destroy,</span><br><span class="line">    deps,</span><br><span class="line">    <span class="attr">next</span>:<span class="literal">null</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> componentUpdateQueue = currentlyRenderingFiber.updateQueue;</span><br><span class="line">  <span class="comment">// 第一个useEffect</span></span><br><span class="line">  <span class="keyword">if</span> (componentUpdateQueue === <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="comment">// componentUpdateQueue : &#123;lastEffect:null&#125;</span></span><br><span class="line">    componentUpdateQueue = createFunctionComponentUpdateQueue();</span><br><span class="line"></span><br><span class="line">    currentlyRenderingFiber.updateQueue =  componentUpdateQueue</span><br><span class="line">      <span class="comment">// effect 赋值给effect.next；它们指向了内存中同一个地址</span></span><br><span class="line">      <span class="comment">// componentUpdateQueue.lastEffect指向effect 也就是componentUpdateQueue.updateQueue.lastEffect指向了 Effect</span></span><br><span class="line">    componentUpdateQueue.lastEffect = effect.next = effect;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 存在多个useEffect</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// componentUpdateQueue.lastEffect 就是上一个Effect对象</span></span><br><span class="line">      <span class="keyword">const</span> lastEffect = componentUpdateQueue.lastEffect; </span><br><span class="line">      <span class="keyword">const</span> firstEffect = lastEffect.next; </span><br><span class="line">      lastEffect.next = effect;</span><br><span class="line">      effect.next = firstEffect;</span><br><span class="line">      componentUpdateQueue.lastEffect = effect;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> effect;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// componentUpdateQueue.lastEffect 永远指向最新的</span></span><br></pre></td></tr></table></figure><p><img src="~@/react/effect.png"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">useEffect(<span class="function">()=&gt;</span>&#123;consoe.log(<span class="number">1</span>)&#125;,[])</span><br><span class="line">useEffect(<span class="function">()=&gt;</span>&#123;consoe.log(<span class="number">2</span>)&#125;,[])</span><br><span class="line">useEffect(<span class="function">()=&gt;</span>&#123;consoe.log(<span class="number">3</span>)&#125;,[])</span><br><span class="line"><span class="comment">// 执行第一个effect</span></span><br><span class="line"><span class="keyword">const</span> effect1=&#123;</span><br><span class="line">  <span class="attr">create</span>:<span class="function">()=&gt;</span>&#123;consoe.log(<span class="number">1</span>)&#125;,</span><br><span class="line">  <span class="attr">deps</span>:[]</span><br><span class="line">  <span class="attr">next</span>:effect1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行第二个effect</span></span><br><span class="line"><span class="keyword">const</span> effect1=&#123;</span><br><span class="line">  <span class="attr">create</span>:<span class="function">()=&gt;</span>&#123;consoe.log(<span class="number">1</span>)&#125;,</span><br><span class="line">  <span class="attr">deps</span>:[]</span><br><span class="line">  <span class="attr">next</span>:effect2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> effect2=&#123;</span><br><span class="line">  <span class="attr">create</span>:<span class="function">()=&gt;</span>&#123;consoe.log(<span class="number">1</span>)&#125;,</span><br><span class="line">  <span class="attr">deps</span>:[]</span><br><span class="line">  <span class="attr">next</span>:effect1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行第三个effect</span></span><br><span class="line"><span class="keyword">const</span> effect2=&#123;</span><br><span class="line">  <span class="attr">create</span>:<span class="function">()=&gt;</span>&#123;consoe.log(<span class="number">1</span>),</span><br><span class="line">  <span class="attr">deps</span>:[]</span><br><span class="line">  <span class="attr">next</span>:effect3</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> effect3=&#123;</span><br><span class="line">  <span class="attr">create</span>:<span class="function">()=&gt;</span>&#123;consoe.log(<span class="number">1</span>),</span><br><span class="line">  <span class="attr">deps</span>:[]</span><br><span class="line">  <span class="attr">next</span>:effect1  <span class="comment">// effect1指向的是effect2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="tomato-update阶段-1"><a href="#tomato-update阶段-1" class="headerlink" title=":tomato: update阶段 "></a>:tomato: update阶段 <Badge text="重要" ></Badge></h4><h4 id="1-updateEffect"><a href="#1-updateEffect" class="headerlink" title="1. updateEffect"></a>1. updateEffect</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateEffect</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  create,</span></span></span><br><span class="line"><span class="params"><span class="function">  deps,</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> updateEffectImpl(PassiveEffect, HookPassive, create, deps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-updateEffectImpl"><a href="#2-updateEffectImpl" class="headerlink" title="2. updateEffectImpl"></a>2. updateEffectImpl</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">areHookInputsEqual</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  nextDeps,</span></span></span><br><span class="line"><span class="params"><span class="function">  prevDeps,</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; prevDeps.length &amp;&amp; i &lt; nextDeps.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is(nextDeps[i], prevDeps[i])) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateEffectImpl</span>(<span class="params">fiberFlags, hookFlags, create, deps</span>) </span>&#123;</span><br><span class="line"><span class="comment">// updateWorkInProgressHook可以往上看，就是创建新的hook对象，不过会复用上一次存的一些信息</span></span><br><span class="line">  <span class="keyword">const</span> hook = updateWorkInProgressHook();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="keyword">let</span> destroy = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// currentHook 可以说是老的hook</span></span><br><span class="line">  <span class="keyword">if</span> (currentHook !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 拿到上一次存的effect对象</span></span><br><span class="line">    <span class="keyword">const</span> prevEffect = currentHook.memoizedState;</span><br><span class="line">    destroy = prevEffect.destroy;</span><br><span class="line">    <span class="keyword">if</span> (nextDeps !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> prevDeps = prevEffect.deps;</span><br><span class="line">      <span class="comment">// 对比依赖对象，是否发生更新，没有更新就复用nextDeps</span></span><br><span class="line">      <span class="keyword">if</span> (areHookInputsEqual(nextDeps, prevDeps)) &#123;</span><br><span class="line">        pushEffect(hookFlags, create, destroy, nextDeps);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  currentlyRenderingFiber.flags |= fiberFlags;</span><br><span class="line"><span class="comment">// deps里发生更新，就创建新的effect对象</span></span><br><span class="line">  hook.memoizedState = pushEffect(</span><br><span class="line">    HookHasEffect | hookFlags,</span><br><span class="line">    create,</span><br><span class="line">    destroy,</span><br><span class="line">    nextDeps,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="8-2-3-useRef"><a href="#8-2-3-useRef" class="headerlink" title="8.2.3 useRef"></a>8.2.3 useRef</h3><h4 id="mountRef-mount阶段"><a href="#mountRef-mount阶段" class="headerlink" title="mountRef (mount阶段)"></a>mountRef (mount阶段)</h4><p>看起来很简单，就是把initialValue 赋值给hook.memoizedState，<br>所以说只要弄懂useState、useEffect ，其他的看一眼就明白</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;any&#125;</span> <span class="variable">initialValue</span></span> - 初始化值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountRef</span>(<span class="params">initialValue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = mountWorkInProgressHook();</span><br><span class="line">  <span class="keyword">const</span> ref =  initialValue;</span><br><span class="line">  hook.memoizedState = ref;</span><br><span class="line">  <span class="keyword">return</span> ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="updateRef-update阶段"><a href="#updateRef-update阶段" class="headerlink" title="updateRef (update阶段)"></a>updateRef (update阶段)</h4><p>拿到上一次的值并返回</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;any&#125;</span> <span class="variable">initialValue</span></span> - 初始化值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateRef</span>(<span class="params">initialValue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = mountWorkInProgressHook();</span><br><span class="line">  <span class="keyword">const</span> ref =  initialValue;</span><br><span class="line">  hook.memoizedState = ref;</span><br><span class="line">  <span class="keyword">return</span> ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-4-useCallback"><a href="#8-2-4-useCallback" class="headerlink" title="8.2.4 useCallback"></a>8.2.4 useCallback</h3><h4 id="mountCallback-mount阶段"><a href="#mountCallback-mount阶段" class="headerlink" title="mountCallback (mount阶段)"></a>mountCallback (mount阶段)</h4><p>把函数和依赖数组存到hook.memoizedState，并返回函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;function&#125;</span> <span class="variable">callback</span></span> - 函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> <span class="variable">deps</span></span> - 依赖数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;function&#125;</span> <span class="variable">callback</span></span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountCallback</span>(<span class="params">callback, deps</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = mountWorkInProgressHook();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  hook.memoizedState = [callback, nextDeps];</span><br><span class="line">  <span class="keyword">return</span> callback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="updateCallback-update阶段"><a href="#updateCallback-update阶段" class="headerlink" title="updateCallback  (update阶段)"></a>updateCallback  (update阶段)</h4><p>对比依赖是否变化，变化就返回最新的函数，没有变化就返回上一个函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;function&#125;</span> <span class="variable">callback</span></span> - 函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> <span class="variable">deps</span></span> - 依赖数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;function&#125;</span> <span class="variable">callback</span></span></span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateCallback</span>(<span class="params">callback, deps</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = updateWorkInProgressHook();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="comment">// prevState：[callback, nextDeps]</span></span><br><span class="line">  <span class="keyword">const</span> prevState = hook.memoizedState;</span><br><span class="line">  <span class="keyword">if</span> (prevState !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextDeps !== <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> prevDeps = prevState[<span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span> (areHookInputsEqual(nextDeps, prevDeps)) &#123;</span><br><span class="line">        <span class="keyword">return</span> prevState[<span class="number">0</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  hook.memoizedState = [callback, nextDeps];</span><br><span class="line">  <span class="keyword">return</span> callback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-5-useMemo"><a href="#8-2-5-useMemo" class="headerlink" title="8.2.5 useMemo"></a>8.2.5 useMemo</h3><h4 id="mountMemo-mount阶段"><a href="#mountMemo-mount阶段" class="headerlink" title="mountMemo (mount阶段)"></a>mountMemo (mount阶段)</h4><p> 调用传入函数拿到返回值，把值和依赖数组存到hook.memoizedState，并返回值</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;function&#125;</span> <span class="variable">nextCreate</span></span> - 函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> <span class="variable">deps</span></span> - 依赖数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;any&#125;</span> <span class="variable">nextValue</span></span></span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountMemo</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  nextCreate,</span></span></span><br><span class="line"><span class="params"><span class="function">  deps,</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = mountWorkInProgressHook();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="keyword">const</span> nextValue = nextCreate();</span><br><span class="line">  hook.memoizedState = [nextValue, nextDeps];</span><br><span class="line">  <span class="keyword">return</span> nextValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="updateMemo-update阶段"><a href="#updateMemo-update阶段" class="headerlink" title="updateMemo (update阶段)"></a>updateMemo (update阶段)</h4><p>对比依赖是否变化，变化就返回最新的值，没有变化就返回上一个值</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;function&#125;</span> <span class="variable">callback</span></span> - 函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> <span class="variable">deps</span></span> - 依赖数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;any&#125;</span> <span class="variable">nextValue</span></span></span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateMemo</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  nextCreate,</span></span></span><br><span class="line"><span class="params"><span class="function">  deps,</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = updateWorkInProgressHook();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="keyword">const</span> prevState = hook.memoizedState;</span><br><span class="line">  <span class="keyword">if</span> (prevState !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Assume these are defined. If they&#x27;re not, areHookInputsEqual will warn.</span></span><br><span class="line">    <span class="keyword">if</span> (nextDeps !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> prevDeps = prevState[<span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span> (areHookInputsEqual(nextDeps, prevDeps)) &#123;</span><br><span class="line">        <span class="keyword">return</span> prevState[<span class="number">0</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> nextValue = nextCreate();</span><br><span class="line">  hook.memoizedState = [nextValue, nextDeps];</span><br><span class="line">  <span class="keyword">return</span> nextValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-3-使用hooks会遇到的问题"><a href="#8-3-使用hooks会遇到的问题" class="headerlink" title="8.3 使用hooks会遇到的问题"></a>8.3 使用hooks会遇到的问题</h2><p><a href="https://zh-hans.reactjs.org/docs/hooks-faq.html">react hooks遇到的问题</a></p><p><a href="https://zhuanlan.zhihu.com/p/92211533">React Hooks完全上手指南</a></p><p>在工程中必须引入lint插件，并开启相应规则，避免踩坑。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;plugins&quot;</span>: [<span class="string">&quot;react-hooks&quot;</span>],</span><br><span class="line">  <span class="string">&quot;rules&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;react-hooks/rules-of-hooks&quot;</span>: <span class="string">&quot;error&quot;</span>,</span><br><span class="line">    <span class="string">&quot;react-hooks/exhaustive-deps&quot;</span>: <span class="string">&quot;warn&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这2条规则，对于新手，这个过程可能是比较痛苦的，如果你觉得这2个规则对你编写代码造成了困扰，说明你还未完全掌握hooks，对于某写特殊场景，确实不需要「exhaustive-deps」，可在代码处加eslint-disable-next-line react-hooks/exhaustive-deps；切记只能禁止本处代码，不能偷懒把整个文件都禁了。</p><h3 id="8-3-1-useEffect相关问题"><a href="#8-3-1-useEffect相关问题" class="headerlink" title="8.3.1 useEffect相关问题"></a>8.3.1 useEffect相关问题</h3><ol><li>依赖变量问题</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ErrorDemo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> dom = useRef(<span class="literal">null</span>);</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    dom.current.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> setCount(count + <span class="number">1</span>));</span><br><span class="line">  &#125;, [count]);</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;dom&#125;</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><p>像这种情况，每次count变化都会重新绑定一次事件，那我们怎么解决呢？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ErrorDemo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> dom = useRef(<span class="literal">null</span>);</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    dom.current.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> setCount(count + <span class="number">1</span>));</span><br><span class="line">  &#125;, []);</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;dom&#125;</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><p>把依赖count变量去掉吗?如果把依赖去掉的话，意味着hooks只在组件挂载的时候运行一次，count的值永远不会超过1；因为在effect<br>执行时，我们会创建一个闭包，并将count的值保存在闭包当中，且初始值为0</p><h4 id="思路1-消除依赖"><a href="#思路1-消除依赖" class="headerlink" title="思路1:消除依赖"></a>思路1:消除依赖</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">// 在这不依赖于外部的 `count` 变量</span></span><br><span class="line">  dom.current.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> setCount(<span class="function">(<span class="params">precount</span>)=&gt;</span>++precount); </span><br><span class="line">&#125;, []) <span class="comment">// 我们的 effect 不使用组件作用域中的任何变量</span></span><br></pre></td></tr></table></figure><p>setCount也可以接收一个函数，这样就不用依赖count了</p><h4 id="思路1-重新绑定事件"><a href="#思路1-重新绑定事件" class="headerlink" title="思路1: 重新绑定事件"></a>思路1: 重新绑定事件</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> $dom = dom.current;</span><br><span class="line">  <span class="keyword">const</span> event = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setCount(count);</span><br><span class="line">  &#125;;</span><br><span class="line">  $dom.addEventListener(<span class="string">&#x27;click&#x27;</span>, event);</span><br><span class="line">  <span class="keyword">return</span>  $dom.removeEventListener(<span class="string">&#x27;click&#x27;</span>, event);</span><br><span class="line">&#125;, [count]);</span><br></pre></td></tr></table></figure><h4 id="思路2-ref"><a href="#思路2-ref" class="headerlink" title="思路2:ref"></a>思路2:ref</h4><p>你可以 使用一个 ref 来保存一个可变的变量。然后你就可以对它进行读写了</p><p>当你实在找不到更好的办法的时候，才这么做，因为依赖的变更使组件变的难以预测</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> dom = useRef(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">const</span> countRef=useRef(count)</span><br><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  countRef.current=count</span><br><span class="line">&#125;);</span><br><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">// 在任何时候读取最新的 count</span></span><br><span class="line">  dom.current.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> setCount(countRef.current + <span class="number">1</span>));</span><br><span class="line">&#125;, []); <span class="comment">// 这个 effect 从不会重新执行</span></span><br></pre></td></tr></table></figure><ol><li>依赖函数问题</li></ol><p>只有 当函数（以及它所调用的函数）不引用 props、state 以及由它们衍生而来的值时，你才能放心地把它们从依赖列表中省略。下面这个案例有一个 Bug：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ProductPage</span>(<span class="params">&#123; productId &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [product, setProduct] = useState(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchProduct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;http://myapi/product/&#x27;</span> + productId); <span class="comment">// 使用了 productId prop</span></span><br><span class="line">    <span class="keyword">const</span> json = <span class="keyword">await</span> response.json();</span><br><span class="line">    setProduct(json);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    fetchProduct();</span><br><span class="line">  &#125;, []); <span class="comment">// 🔴 这样是无效的，因为 `fetchProduct` 使用了 `productId`</span></span><br><span class="line">  <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h4 id="思路1-推荐的修复方案是把那个函数移动到你的-effect-内部"><a href="#思路1-推荐的修复方案是把那个函数移动到你的-effect-内部" class="headerlink" title="思路1:推荐的修复方案是把那个函数移动到你的 effect 内部"></a>思路1:推荐的修复方案是把那个函数移动到你的 effect 内部</h4><p>这样就能很容易的看出来你的 effect 使用了哪些 props 和 state，并确保它们都被声明了：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ProductPage</span>(<span class="params">&#123; productId &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [product, setProduct] = useState(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 把这个函数移动到 effect 内部后，我们可以清楚地看到它用到的值。</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchProduct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;http://myapi/product/&#x27;</span> + productId);</span><br><span class="line">      <span class="keyword">const</span> json = <span class="keyword">await</span> response.json();</span><br><span class="line">      setProduct(json);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fetchProduct();</span><br><span class="line">  &#125;, [productId]); <span class="comment">// ✅ 有效，因为我们的 effect 只用到了 productId</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路2-useCallback"><a href="#思路2-useCallback" class="headerlink" title="思路2: useCallback"></a>思路2: useCallback</h4><p>把函数加入 effect 的依赖但 把它的定义包裹 进 useCallback Hook。这就确保了它不随渲染而改变，除非 它自身 的依赖发生了改变</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ProductPage</span>(<span class="params">&#123; productId &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [product, setProduct] = useState(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> fetchProduct = useCallback(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;http://myapi/product/&#x27;</span> + productId); <span class="comment">// 使用了 productId prop</span></span><br><span class="line">    <span class="keyword">const</span> json = <span class="keyword">await</span> response.json();</span><br><span class="line">    setProduct(json);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;, [productId]); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    fetchProduct();</span><br><span class="line">  &#125;, [fetchProduct]); </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React原理</title>
      <link href="/59622/"/>
      <url>/59622/</url>
      
        <content type="html"><![CDATA[<h2 id="5-1-React-Virtual-DOM原理"><a href="#5-1-React-Virtual-DOM原理" class="headerlink" title="5.1 React Virtual DOM原理"></a>5.1 React Virtual DOM原理</h2><h3 id="5-1-1-Virtual-DOM是什么？"><a href="#5-1-1-Virtual-DOM是什么？" class="headerlink" title="5.1.1 Virtual DOM是什么？"></a>5.1.1 Virtual DOM是什么？</h3><p>官方定义：virtual DOM是一种编程理念（数据驱动视图），将ui虚拟的保持到内存中，并且通过某些库渲染成真实的dom，这个过程又叫做协调。</p><p>总结：virtual dom是一种编程理念，将ui节点抽象成js对象。</p><h4 id="ui节点抽象"><a href="#ui节点抽象" class="headerlink" title="ui节点抽象"></a>ui节点抽象</h4><p>Learn Once，Write anywhere：因为提供了对HTML DOM的抽象，所以在web开发中，通常不需要去调用DOM API，也是因为抽象，所以React也可以开发Native（React Native）</p><h4 id="Virtual-dom-构建UI"><a href="#Virtual-dom-构建UI" class="headerlink" title="Virtual dom 构建UI"></a>Virtual dom 构建UI</h4><p>以我们经常见的web开发为例，来看下React是怎么通过Virtual DOM渲染成HTML元素的。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    state=&#123;</span><br><span class="line">        <span class="attr">text</span>:<span class="string">&#x27;Virtual DOM&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    render () &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;text&#125;=<span class="built_in">this</span>.state</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &#123;text&#125;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到React是通过render方法渲染Virtual DOM ，从而绘制出真实DOM。意味着每次修改state的值就会执行render方法</p><h3 id="5-1-2-Virtual-DOM-VS-原生DOM"><a href="#5-1-2-Virtual-DOM-VS-原生DOM" class="headerlink" title="5.1.2 Virtual DOM VS 原生DOM"></a>5.1.2 Virtual DOM VS 原生DOM</h3><ul><li>原生DOM更新</li></ul><p>DOM API 调用更新UI</p><ul><li>Virtual DOM更新</li></ul><ol><li>每次render都会产生一份新的’react dom‘</li><li>Virtual DOM要对新旧‘react dom’进行比较，从而确定在旧‘dom’的基础上进行多少变更</li><li>确定最优的变更策略之后调用DOM API更新</li></ol><p>Virtual DOM数据结构</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> globaldom=&#123;</span><br><span class="line">    <span class="attr">tagname</span>:<span class="string">&#x27;html&#x27;</span>,</span><br><span class="line">    <span class="attr">children</span>:[&#123;</span><br><span class="line">        <span class="attr">tagname</span>:<span class="string">&#x27;head&#x27;</span></span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        <span class="attr">tagname</span>:<span class="string">&#x27;body&#x27;</span>,</span><br><span class="line">        <span class="attr">children</span>:[</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">tagName</span>:<span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">              <span class="attr">attributes</span>:&#123;</span><br><span class="line">                  <span class="attr">className</span>:<span class="string">&#x27;test&#x27;</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">     &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对UI节点抽象</p><p>在Virtual DOM中，对HTML节点进行抽象，用js对象的形式表示HTML</p><p>改变了过去对HTML节点的理解</p><p>呈现在用户面前的页面就是一个复杂的递归对象</p><h3 id="5-1-3-Virtual-DOM-Diff"><a href="#5-1-3-Virtual-DOM-Diff" class="headerlink" title="5.1.3 Virtual DOM Diff"></a>5.1.3 Virtual DOM Diff</h3><ul><li>Virtual DOM如何提搞性能</li></ul><ol><li>我们将render产生的Virtual DOM简称 ‘Vdom’</li><li>通常调用setState方法触发Vdom更新</li><li>通过对比新旧‘Vdom’确定最优实现新的‘vdom’所需的操作</li></ol><ul><li>Virtual DOM Diff的层次</li></ul><ol><li>层级级别的比较</li><li>元素级别的比较</li></ol><h4 id="Component-Diff"><a href="#Component-Diff" class="headerlink" title="Component Diff"></a>Component Diff</h4><p><img src="~@/react/componentdiif.png"></p><p>假设将图中的D节点更换成G节点，会把D节点删掉，然后创建G节点；只会同层级比较，这样会降低diff的复杂度，大概率下面的层级不一样的。</p><h4 id="Element-Diff"><a href="#Element-Diff" class="headerlink" title="Element Diff"></a>Element Diff</h4><ol><li>createChild</li><li>moveChild</li><li>removeChild</li></ol><p>我们元素之间的对比中，会有3种情况：创建节点、删除节点、移动节点</p><ul><li>创建节点</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">createChild:<span class="function"><span class="keyword">function</span>(<span class="params">child,afterNode,mountImage</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> makeInserMarku(mountImage,afterNode,child._mountIndex)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>删除节点</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">removeChild:<span class="function"><span class="keyword">function</span>(<span class="params">child,node</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> makeRemove(child，node)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>移动节点</li></ul><p>假设我们把节点3移动到第一的位置</p><p><img src="~@/react/moveChild.png"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 老的节点和新的节点相同，说明需要移动节点</span></span><br><span class="line"><span class="keyword">if</span>(preChild===nextChild)&#123;</span><br><span class="line">    updates=enqueue(updates,<span class="built_in">this</span>.moveChild(preChild,lastPlaceNode,nextIndex,lastIndex))</span><br><span class="line">    lastIndex=<span class="built_in">Math</span>.max(preChild._mountIndex,lastIndex)</span><br><span class="line">    preChild._mountIndex=nextIndex</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 移动的方法</span></span><br><span class="line"><span class="attr">moveChild</span>:<span class="function"><span class="keyword">function</span> (<span class="params">child,afterNode,toIndex,lastIndex</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// _mountIndex是这个元素在原有节点的顺序，lastIndex是这次要更新的顺序</span></span><br><span class="line">    <span class="keyword">if</span>(child._mountIndex&lt;lastIndex)&#123;</span><br><span class="line">        <span class="keyword">return</span> makeMove(child,afterNode,toIndex)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际中最后一个节点移动到第一位置的时候，不是把最后一个节点直接移动到第一的位置，而是把这个节点前面的节点依次往后移动，直到最后一个节点成为第一的位置。</p><h3 id="5-1-3-扩展资料"><a href="#5-1-3-扩展资料" class="headerlink" title="5.1.3 扩展资料"></a>5.1.3 扩展资料</h3><p><a href="https://reactjs.org/docs/faq-internals.html#what-is-the-virtual-dom">Virtual DOM 定义</a></p><p><a href="https://mithril.js.org/vnodes.html">Virtual DOM Node</a></p><p><a href="https://reactkungfu.com/2015/10/the-difference-between-virtual-dom-and-dom/">VDom与 DOM 的区别</a></p><p><a href="https://juejin.im/entry/5af99e786fb9a07ac90d5664">React性能优化：Virtual Dom原理浅析</a></p><p><a href="https://juejin.im/post/5c504f736fb9a049ef26fcd3">[译] Virtual Dom 和 Diff 算法</a></p><h2 id="5-2-React-Reconciler（react协调的过程）"><a href="#5-2-React-Reconciler（react协调的过程）" class="headerlink" title="5.2 React Reconciler（react协调的过程）"></a>5.2 React Reconciler（react协调的过程）</h2><h3 id="5-2-1-React-Reconclier-15版本"><a href="#5-2-1-React-Reconclier-15版本" class="headerlink" title="5.2.1  React Reconclier(15版本)"></a>5.2.1  React Reconclier(15版本)</h3><h2 id="5-3-new-componentLifecyle（新生命周期）"><a href="#5-3-new-componentLifecyle（新生命周期）" class="headerlink" title="5.3 new componentLifecyle（新生命周期）"></a>5.3 new componentLifecyle（新生命周期）</h2><h3 id="5-3-1-React组件新生命周期详解"><a href="#5-3-1-React组件新生命周期详解" class="headerlink" title="5.3.1 React组件新生命周期详解"></a>5.3.1 React组件新生命周期详解</h3><p>老的生命周期</p><p><img src="~@/react/oldLIfeCycle.png"></p><p>react 16.3 增加了getDeriveStateFromProps和getSnapshotBeforeUpdate 2个静态方法</p><p><img src="~@/react/react16.3.png"></p><p>react 16.4中增加了在setState和forceUpdate()都会执行这个静态方法<code>getDeriveStateFromProps</code></p><p><img src="~@/react/newLifecycle.png"></p><h3 id="5-3-2-挂载阶段"><a href="#5-3-2-挂载阶段" class="headerlink" title="5.3.2 挂载阶段"></a>5.3.2 挂载阶段</h3><ol><li>挂载阶段的函数</li></ol><ul><li>constructor 构造函数，初始化state，以及为事件处理函数绑定实例</li><li>getDeriveStateFromProps 新增的静态方法，返回一个新的state，或者是null，静态方法里的，这里面的this是指向全局变量</li><li>render 渲染函数</li><li>componentDidMount 挂载成功后立即调用</li></ul><ol start="2"><li>更新阶段的函数</li></ol><ul><li>getDeriveStateFromProps props变化或者state方法触发</li><li>shouldComponentUpdate 判断是否进行更新</li><li>render 函数</li><li>getSnapshotBeforeUpdate 生命周期方法在更新之前（如：更新 DOM 之前）被调用。此生命周期的返回值将作为第三个参数传递给 componentDidUpdate。（通常不需要，但在重新渲染过程中手动保留滚动位置等情况下非常有用。）</li><li>componentDidUpdate 更新后会被立即调用</li></ul><ol start="3"><li>卸载阶段的函数</li></ol><ul><li>componentWillUnmount 卸载函数，组件卸载及销毁之前直接调用，主要用于清除一些在组件生命周期订阅，真实DOM事件以及setTimeout/setinterval的返回值</li></ul><h4 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h4><ul><li>componentDidCatch 生命周期方法在后代组件抛出错误后被调用，方法接受两个参数（err，info），分别是错误信息和错误组件的栈信息</li><li>getDerivedStateFromError 在后代组件抛出错误后调用，接受一个参数（error）表示具体的错误信息</li></ul><h3 id="5-3-3-新版组件升级"><a href="#5-3-3-新版组件升级" class="headerlink" title="5.3.3 新版组件升级"></a>5.3.3 新版组件升级</h3><ul><li><p>componetWillMount (17.0被移除)</p><ul><li>render 方法之前调用，在此调用setState并不会触发再次渲染</li><li>通常会在这个方法中进行页面标题的一些修改以及其他与再次render不相关的操作</li></ul></li><li><p>UNSAFE_componentWillMount （16.3 新增不安全的生命周期引入别名）</p><ul><li>与state相关的操作挪到constructor方法中执行</li><li>异步操作挪到componentDidMount中执行</li></ul></li><li><p>componentWillUpdate(17.0被移除)</p><ul><li>在组件收到新的props或state时，会在渲染之前调用</li><li>方法内不能调用setState，触发循环，内存泄漏</li></ul></li><li><p>UNSAFE_componentWillUpdate（16.3 新增不安全的生命周期引入别名）</p><ul><li>应该在shouldComponentUpdate</li></ul></li><li><p>componentWillReceiveProps(17.0被移除)</p><ul><li>接受父级传递过来最新的props，转化为组件内的state</li><li>判断是否进行更新或者执行异步请求数据</li></ul></li><li><p>UNSADFE_componentWillReceiveProps（16.3 新增不安全的生命周期引入别名）</p><ul><li>与渲染相关的props直接渲染，不需要处理为组件内的state</li><li>异步数据请求在componentDidUpdate中处理</li><li>getDerivedStateFromPropss方法替换，需要考虑生命周期的执行顺序</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React生态</title>
      <link href="/10279/"/>
      <url>/10279/</url>
      
        <content type="html"><![CDATA[<h2 id="4-1-React-Router-1"><a href="#4-1-React-Router-1" class="headerlink" title="4.1 React-Router(1)"></a>4.1 React-Router(1)</h2><h3 id="4-1-1-安装"><a href="#4-1-1-安装" class="headerlink" title="4.1.1 安装"></a>4.1.1 安装</h3><ul><li>react-router<br>路由核心功能</li><li>react-router-dom<br>基于React-router，加入了一些在浏览器运行下的一些功能</li></ul><p>React-router-dom依赖于react-router，所以我们不用主动安装React-router，只需安装React-router-dom即可</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add react-router-dom</span><br></pre></td></tr></table></figure><h3 id="4-1-2-编写路由"><a href="#4-1-2-编写路由" class="headerlink" title="4.1.2 编写路由"></a>4.1.2 编写路由</h3><h4 id="React-router-dom提供的路由组件"><a href="#React-router-dom提供的路由组件" class="headerlink" title="React-router-dom提供的路由组件"></a>React-router-dom提供的路由组件</h4><ul><li><p>BrowserRouter（history模式，这种模式需要后端配合）</p></li><li><p>hashRouter（hash模式）</p></li></ul><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p> 用BrowserRouter进行包裹，并通过组件树传递下去</p><p> Route（路由）路由的出口，对应不同url，检测不同的url去渲染不同的组件</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在app.js中导入BrowserRouter组件和Route组件</span></span><br><span class="line"><span class="keyword">import</span> React,&#123;Component&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; BrowserRouter,Route&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Products <span class="keyword">from</span> <span class="string">&#x27;./components/products&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Admin <span class="keyword">from</span> <span class="string">&#x27;./components/admin&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">&#x27;./components/home&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">BrowserRouter</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/products&#x27;</span> <span class="attr">component</span>=<span class="string">&#123;Products&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/admin&#x27;</span> <span class="attr">component</span>=<span class="string">&#123;Admin&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/&#x27;</span> <span class="attr">component</span>=<span class="string">&#123;Home&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">BrowserRouter</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的写法会有一个问题，就是我们跳转到products或admin路由下都会显示home这个组件的内容，其实这个路由匹配带来的问题，home组件的路由<code>/</code>会被多次匹配到</p><p>解决方法1</p><p>用exact标记，表示完全匹配，也就是说只有Link（Link下面会介绍）中to属性的值和path的值完全相同，那么才算匹配成功</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">BrowserRouter</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/products&#x27;</span> <span class="attr">component</span>=<span class="string">&#123;Products&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/admin&#x27;</span> <span class="attr">component</span>=<span class="string">&#123;Admin&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/&#x27;</span> <span class="attr">exact</span> <span class="attr">component</span>=<span class="string">&#123;Home&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">BrowserRouter</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方法2</p><p>用<code>Switch组件</code>包裹<code>router组件</code>，表示只匹配一个路由，匹配成功后就不在进行匹配</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;Component&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; BrowserRouter,Route,Switch&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Products <span class="keyword">from</span> <span class="string">&#x27;./components/products&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Admin <span class="keyword">from</span> <span class="string">&#x27;./components/admin&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">&#x27;./components/home&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">BrowserRouter</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/products&#x27;</span> <span class="attr">component</span>=<span class="string">&#123;Products&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/admin&#x27;</span> <span class="attr">component</span>=<span class="string">&#123;Admin&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/&#x27;</span> <span class="attr">component</span>=<span class="string">&#123;Home&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">BrowserRouter</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="用Link组件跳转不同的路由"><a href="#用Link组件跳转不同的路由" class="headerlink" title="用Link组件跳转不同的路由"></a>用Link组件跳转不同的路由</h4><p>Link路由的入口，通过to属性来指定跳转的路由，这个值与route的path相对应</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Link &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> NavBar=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">            &#123;/* 渲染后是a标签，但用Link组件会阻止默认行为*/&#125;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#x27;/&#x27;</span>&gt;</span>home<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#x27;/products&#x27;</span>&gt;</span>products<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#x27;/admin&#x27;</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> NavBar</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-1-3-Route匹配"><a href="#4-1-3-Route匹配" class="headerlink" title="4.1.3 Route匹配"></a>4.1.3 Route匹配</h3><ul><li>Route</li></ul><p>比较path属性和当前地址的pathName，当一个<code>&lt;Route&gt;</code>匹配成功，它将渲染其内容；当它不匹配时就会渲染null。</p><ul><li>Switch</li></ul><p>一个<code>&lt;Switch&gt;</code>会遍历其所有的子<code>&lt;Route&gt;</code>元素，并仅渲染与当前地址匹配的第一个元素</p><ul><li>Link</li></ul><p>使用<code>&lt;Link&gt;</code>作为url的导航，让整个应用不刷新页面在不同网址之间切换</p><h2 id="4-2-React-Router-2"><a href="#4-2-React-Router-2" class="headerlink" title="4.2 React-Router(2)"></a>4.2 React-Router(2)</h2><h3 id="4-2-1-route的props属性"><a href="#4-2-1-route的props属性" class="headerlink" title="4.2.1 route的props属性"></a>4.2.1 route的props属性</h3><p>路由组件会被默认注入三个属性<code>history</code>、<code>location</code>、<code>match</code></p><ul><li>history</li></ul><p>路由导航，提供了<code>go</code>、<code>goBack</code>、<code>goForward</code>、<code>push</code>、<code>replace</code>等方法</p><ul><li>location</li></ul><p>代表当前的地址，可以在这个对象获取query参数</p><ul><li>match</li></ul><p>包含如何匹配路由信息，可以获取Params</p><p><img src="~@/react/routerProps.png"></p><h3 id="4-2-2-路由页面之间传参"><a href="#4-2-2-路由页面之间传参" class="headerlink" title="4.2.2 路由页面之间传参"></a>4.2.2 路由页面之间传参</h3><h4 id="1-动态路由的方式"><a href="#1-动态路由的方式" class="headerlink" title="1.动态路由的方式"></a>1.动态路由的方式</h4><p>设置动态路由</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;Component&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; BrowserRouter,Route,Switch&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Products <span class="keyword">from</span> <span class="string">&#x27;./components/products&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Admin <span class="keyword">from</span> <span class="string">&#x27;./components/admin&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">&#x27;./components/home&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">BrowserRouter</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="xml">                 &#123;/* 示例1，设置单个动态路由 */&#125;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/products/:id&#x27;</span> <span class="attr">component</span>=<span class="string">&#123;Products&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">                  &#123;/* 示例2，设置多个动态路由 */&#125;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/products/:id/:year&#x27;</span> <span class="attr">component</span>=<span class="string">&#123;Products&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">                 &#123;/* 示例3，?表示year这个路由路径可选 */&#125;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/products/:id/:year?&#x27;</span> <span class="attr">component</span>=<span class="string">&#123;Products&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">BrowserRouter</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跳转到Products页面</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> NavBar=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">                  &#123;/* 示例1 */&#125;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;</span>`/<span class="attr">products</span>/$&#123;<span class="attr">1</span>&#125;`&#125;&gt;</span>products<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml">                  &#123;/* 示例2 */&#125;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;</span>`/<span class="attr">products</span>/$&#123;<span class="attr">1</span>&#125;/$&#123;<span class="attr">2020</span>&#125;`&#125;&gt;</span>products<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml">                 &#123;/* 示例3 ，第二参数可以有也可以没有*/&#125;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;</span>`/<span class="attr">products</span>/$&#123;<span class="attr">1</span>&#125;/$&#123;<span class="attr">2020</span>&#125;`&#125;&gt;</span>products<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Products页面获取route参数</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;Component&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Products</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            &#123;/* 拿到params对象，this.props.match.params*/&#125;</span></span><br><span class="line"><span class="xml">             &#123;/* 示例1 */&#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;this.props.match.params.id&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">             &#123;/* 示例2 */&#125;</span></span><br><span class="line"><span class="xml">             <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;this.props.match.params.year&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// or 函数示组件</span></span><br><span class="line"><span class="keyword">const</span> Products=<span class="function">(<span class="params">&#123;match&#125;</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            &#123;/* 拿到params对象，this.props.match.params*/&#125;s</span></span><br><span class="line"><span class="xml">             &#123;/* 示例1 */&#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;match.params.id&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">             &#123;/* 示例2 */&#125;</span></span><br><span class="line"><span class="xml">             <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;match.params.year&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-queryString的方式"><a href="#2-queryString的方式" class="headerlink" title="2.queryString的方式"></a>2.queryString的方式</h4><p>跳转到Products页面</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> NavBar=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">                  &#123;/* 示例1 */&#125;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;</span>`/<span class="attr">products</span>?<span class="attr">id</span>=<span class="string">1</span>`&#125;&gt;</span>products<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Products页面获取?后的参数</p><p>可以在props.location.serach中获取参数，不过这个参数需要我们自己序列化出来，默认是<code>?id=1</code>这样的形式，我们可以自己写方法解析出来，也可以用第三方库<code>query-string</code>，下面我们用这个库去序列化。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> React,&#123;Component&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> queryString <span class="keyword">from</span> <span class="string">&#x27;query-string&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Products</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">const</span> parsed=queryString(<span class="built_in">this</span>.props.location.search)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">             &#123;/* 示例1 */&#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;parsed.id&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// or 函数示组件</span></span><br><span class="line"><span class="keyword">const</span> Products=<span class="function">(<span class="params">&#123;location&#125;</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">const</span> parsed=queryString(location)</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">             &#123;/* 示例1 */&#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;parsed.id&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-2-3-重定向功能"><a href="#4-2-3-重定向功能" class="headerlink" title="4.2.3 重定向功能"></a>4.2.3 重定向功能</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;Component&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; BrowserRouter,Route,Switch,Redirect&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Products <span class="keyword">from</span> <span class="string">&#x27;./components/products&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Admin <span class="keyword">from</span> <span class="string">&#x27;./components/admin&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">&#x27;./components/home&#x27;</span></span><br><span class="line"><span class="keyword">import</span> NotFound <span class="keyword">from</span> <span class="string">&#x27;./components/NotFound&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">BrowserRouter</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/products:id&#x27;</span> <span class="attr">component</span>=<span class="string">&#123;Products&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/admin&#x27;</span> <span class="attr">component</span>=<span class="string">&#123;Admin&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">                  &#123;/* 如果用户在地址栏输入login，就重定向到NotFound页面*/&#125;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">from</span>=<span class="string">&#x27;/login&#x27;</span> <span class="attr">to</span>=<span class="string">&#x27;/not-found&#x27;</span>/&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/not-found&#x27;</span> <span class="attr">component</span>=<span class="string">&#123;NotFound&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">                 &#123;/* exact表示精准匹配*/&#125;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/&#x27;</span> <span class="attr">exact</span> <span class="attr">component</span>=<span class="string">&#123;Home&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">                &#123;/*如果都没有匹配到就跳转到NotFound页面*/&#125;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">to</span>=<span class="string">&#x27;/not-found&#x27;</span>/&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">BrowserRouter</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-4-导航处理"><a href="#4-2-4-导航处理" class="headerlink" title="4.2.4 导航处理"></a>4.2.4 导航处理</h3><p>导航实现跳转</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;Component&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NavBar</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    handleSale=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// push方法会向浏览器中历史记录中添加一条记录</span></span><br><span class="line">        <span class="built_in">this</span>.props.history.push(<span class="string">&#x27;/products?id=1&#x27;</span>)</span><br><span class="line">        <span class="comment">// or</span></span><br><span class="line">        <span class="comment">// repalce将当前的记录指定我们的一个路径</span></span><br><span class="line">        <span class="built_in">this</span>.props.history.replace(<span class="string">&#x27;/products?id=1&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleSale&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">     )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-5-回顾"><a href="#4-2-5-回顾" class="headerlink" title="4.2.5 回顾"></a>4.2.5 回顾</h3><ul><li>Route</li></ul><p>定义一个匹配，在匹配时渲染相应的组件</p><ul><li>Switch</li></ul><p>仅渲染与当前地址匹配的第一个元素</p><ul><li>Route Props</li></ul><p>使用render props方案传递路由参数</p><ul><li>Route参数</li></ul><p>在path中定义参数格式，在props match对象中获取参数</p><ul><li>Query string</li></ul><p>使用第三方插件获取url中的参数</p><ul><li>导航处理</li></ul><p>通过puch或replace方法来处理浏览器历史记录</p><h3 id="4-2-6-扩展"><a href="#4-2-6-扩展" class="headerlink" title="4.2.6 扩展"></a>4.2.6 扩展</h3><p><a href="https://react-router.docschina.org/web/guides/philosophy">react router组件文档</a></p><p><a href="https://juejin.im/post/5d6352116fb9a06ae8361932#heading-34">路由鉴权</a></p><h2 id="4-3-Ant-Design"><a href="#4-3-Ant-Design" class="headerlink" title="4.3 Ant Design"></a>4.3 Ant Design</h2><h3 id="4-3-1-安装与使用"><a href="#4-3-1-安装与使用" class="headerlink" title="4.3.1 安装与使用"></a>4.3.1 安装与使用</h3><p>安装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn  add antd</span><br></pre></td></tr></table></figure><p>在项目中使用</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;antd/dist/antd.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;Button&#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span></span><br><span class="line"><span class="keyword">const</span> MyAntd = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ( <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Button</span> <span class="attr">type</span>=<span class="string">&#x27;primary&#x27;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> MyAntd;</span><br></pre></td></tr></table></figure><p>按需加载</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">安装 babel-plugin-import插件</span><br><span class="line">yarn  add babel-plugin-import --dev</span><br><span class="line"></span><br><span class="line">在.babelrc配置以下</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;presets&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;react-app&quot;</span></span><br><span class="line">      ],</span><br><span class="line">    <span class="string">&quot;plugins&quot;</span>:[</span><br><span class="line">        [<span class="string">&quot;import&quot;</span>, &#123; <span class="string">&quot;libraryName&quot;</span>: <span class="string">&quot;antd&quot;</span>, <span class="string">&quot;libraryDirectory&quot;</span>: <span class="string">&quot;es&quot;</span>, <span class="string">&quot;style&quot;</span>: <span class="string">&quot;css&quot;</span> &#125;]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">或者在package.json配置以下（与上面配置二选其一）</span><br><span class="line">  <span class="string">&quot;babel&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;presets&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;react-app&quot;</span></span><br><span class="line">    ],</span><br><span class="line">     <span class="string">&quot;plugins&quot;</span>:[</span><br><span class="line">        [<span class="string">&quot;import&quot;</span>, &#123; <span class="string">&quot;libraryName&quot;</span>: <span class="string">&quot;antd&quot;</span>, <span class="string">&quot;libraryDirectory&quot;</span>: <span class="string">&quot;es&quot;</span>, <span class="string">&quot;style&quot;</span>: <span class="string">&quot;css&quot;</span> &#125;]</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-2-Ant生态"><a href="#4-3-2-Ant生态" class="headerlink" title="4.3.2 Ant生态"></a>4.3.2 Ant生态</h3><ol><li>AvaJS</li></ol><p>基于redux轻量数据流</p><ol start="2"><li>UmiJs</li></ol><p>可插拔企业级应用级插件，进阶版create-react-app</p><ol start="3"><li>ant design pro</li></ol><p>进阶版ant design，提供一整套ui方法</p><ol><li>ant motion </li></ol><p>动画库</p><ol start="5"><li>Antv</li></ol><p>数据可视化</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React正篇</title>
      <link href="/60006/"/>
      <url>/60006/</url>
      
        <content type="html"><![CDATA[<h2 id="3-1-事件处理"><a href="#3-1-事件处理" class="headerlink" title="3.1 事件处理"></a>3.1 事件处理</h2><h3 id="3-1-1-react事件和DOM事件"><a href="#3-1-1-react事件和DOM事件" class="headerlink" title="3.1.1 react事件和DOM事件"></a>3.1.1 react事件和DOM事件</h3><table><thead><tr><th align="center">react事件</th><th align="center">原生事件</th></tr></thead><tbody><tr><td align="center">onClick</td><td align="center">onclick</td></tr><tr><td align="center">onClick={eventListener}</td><td align="center">onclick=”eventListener()”</td></tr><tr><td align="center">e.preventDefalut</td><td align="center">onclick=”javascript”</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ListItem extends Component &#123;</span><br><span class="line">     constructor(props)&#123;</span><br><span class="line">     super(props) //子类中调用父类构造函数</span><br><span class="line">   &#125;</span><br><span class="line">   doSomethind()&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">    handleClick(e)&#123;</span><br><span class="line">        console.log(e)</span><br><span class="line">        this.doSomethind() //报错，会说找不到这个方法</span><br><span class="line">    &#125;</span><br><span class="line">   render()&#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&#x27;listItem&#x27;&gt;</span><br><span class="line">        &lt;span onclick=&#123;this.handleClick&#125;&gt;header&lt;span&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">    )</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在面向对象的编程中，this的使用方法会随着引用对象的差别而不同，当被对象引用时指向的是对象，单独函数引用指向的是window，严格模式是<code>undefined</code>，那我们在react中怎么解决这个问题呢？</p><h3 id="3-1-2-this关键词的处理"><a href="#3-1-2-this关键词的处理" class="headerlink" title="3.1.2 this关键词的处理"></a>3.1.2 this关键词的处理</h3><ul><li>在jsx中使用bind方法</li><li>在构造函数中使用bind方法</li><li>使用箭头函数</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ListItem extends Component &#123;</span><br><span class="line">     constructor(props)&#123;</span><br><span class="line">     super(props) //子类中调用父类构造函数</span><br><span class="line">     // 方法2</span><br><span class="line">     this.handleClick=this.handleClick.bind(this)</span><br><span class="line">   &#125;</span><br><span class="line">   doSomethind()&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">    // 方法3，推荐使用，箭头函数的this总是指向定义时的对象，而不是运行时</span><br><span class="line">    handleClick=(e)=&gt;&#123;</span><br><span class="line">        console.log(e)</span><br><span class="line">        this.doSomethind() //报错，会说找不到这个方法</span><br><span class="line">    &#125;</span><br><span class="line">   render()&#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&#x27;listItem&#x27;&gt;</span><br><span class="line">        &#123;/*方法1*/&#125;</span><br><span class="line">        &lt;span onclick=&#123;this.handleClick.bind(this)&#125;&gt;header&lt;span&gt;   </span><br><span class="line">      &lt;div&gt;</span><br><span class="line">    )</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-3-向事件处理程序传递参数"><a href="#3-1-3-向事件处理程序传递参数" class="headerlink" title="3.1.3 向事件处理程序传递参数"></a>3.1.3 向事件处理程序传递参数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ListItem extends Component &#123;</span><br><span class="line">     constructor(props)&#123;</span><br><span class="line">     super(props) //子类中调用父类构造函数)</span><br><span class="line">     this.state=&#123;</span><br><span class="line">         conunt:1</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    handleClick(id)&#123;</span><br><span class="line">        console.log(id)</span><br><span class="line">    &#125;</span><br><span class="line">   render()&#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&#x27;listItem&#x27;&gt;</span><br><span class="line">       &#123;/* 方法1*/&#125;</span><br><span class="line">        &lt;span onclick=&#123;this.handleClick.bind(this,1)&#125;&gt;header&lt;span&gt; </span><br><span class="line">         &#123;/* 方法2*/&#125;</span><br><span class="line">        &lt;span onclick=&#123;()=&gt;this.handleClick(1)&#125;&gt;header&lt;span&gt;  </span><br><span class="line">          &#123;/* 传递事件对象event*/&#125;</span><br><span class="line">        &lt;span onclick=&#123;(e)=&gt;this.handleClick(1,e)&#125;&gt;header&lt;span&gt;  </span><br><span class="line">      &lt;div&gt;</span><br><span class="line">    )</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-4-向父组件传递参数"><a href="#3-1-4-向父组件传递参数" class="headerlink" title="3.1.4 向父组件传递参数"></a>3.1.4 向父组件传递参数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">class App extends Component &#123;</span><br><span class="line">    handDelete(id)&#123;</span><br><span class="line">        console.log(id)</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        &lt;ListItem onDelete=&#123;this.handDelete&#125;/&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 子组件</span><br><span class="line">class ListItem extends Component &#123;</span><br><span class="line">     constructor(props)&#123;</span><br><span class="line">     super(props)</span><br><span class="line">     this.state=&#123;</span><br><span class="line">         conunt:1</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   render()&#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&#x27;listItem&#x27;&gt;</span><br><span class="line">        &lt;span onclick=&#123;()=&gt;this.props.onDelete(this.state.conunt)&#125;&gt;header&lt;span&gt;  </span><br><span class="line">      &lt;div&gt;</span><br><span class="line">    )</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-5-React事件机制"><a href="#3-1-5-React事件机制" class="headerlink" title="3.1.5 React事件机制"></a>3.1.5 React事件机制</h3><h4 id="DOM事件"><a href="#DOM事件" class="headerlink" title="DOM事件"></a>DOM事件</h4><p><img src="~@/react/domhandle.png"></p><p>在js的事件触发经过3个阶段，事件的捕获-&gt;目标对象事件的处理-&gt;事件冒泡，假设在<code>text</code>中触发了事件，会经过一个捕获的阶段，父级元素将事件一直传递到本身发生的元素上，在经过本身的事件处理之后，会经历冒泡饿阶段，事件从子元素向父元素冒泡；就因为这样，事件委托成为了可能，就是将子元素的事件处理委托给父元素。</p><h4 id="react事件"><a href="#react事件" class="headerlink" title="react事件"></a>react事件</h4><p><img src="~@/react/reacthandle.png"></p><p>react会将所有的事件都绑定到document上，而不是某个元素上面，统一的使用事件监听，并在冒泡阶段处理事件，当挂载和卸载组件的时候<br>只需在统一的事件监听位置，增加或删除对象，因此极大的提高效率；当事件触发的时候，我们的组件会生成一个合成事件，然后传递到<code>documennt</code>中，doucument会通过<code>DispatchEvent</code>回调函数依次执行<code>DispatchEvent</code>中同类型的事件监听函数，事件注册是在组件生成的时候，我们将vDom中所有的事件的原生事件<code>documennt</code>中的一个监听器当中，也就是所有的事件处理函数都存在<code>ListenerBank</code>中<br>并以<code>key</code>作为索引，这样的好处是将可能要触发的事件分门别类。</p><p>react事件要素</p><ul><li>react事件是合成事件，不是DOM原生事件</li><li>在document监听所有支持的事件</li><li>使用统一的分发函数dispatchEvent</li></ul><h3 id="3-1-6-扩展学习"><a href="#3-1-6-扩展学习" class="headerlink" title="3.1.6 扩展学习"></a>3.1.6 扩展学习</h3><p><a href="https://zhuanlan.zhihu.com/p/25883536">源码分析事件</a></p><p><a href="http://react.html.cn/docs/events.html">合成事件</a></p><h2 id="3-2-认识State"><a href="#3-2-认识State" class="headerlink" title="3.2 认识State"></a>3.2 认识State</h2><p>安装<code>react-devtools</code>调试工具</p><p>方法1:有条件的可以在谷歌商店安装</p><p>方法2:没有条件的看地址安装<a href="https://www.npmjs.com/package/react-devtools">点击我</a></p><h3 id="3-2-1-如何定义State"><a href="#3-2-1-如何定义State" class="headerlink" title="3.2.1 如何定义State"></a>3.2.1 如何定义State</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">ListItem</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">   <span class="built_in">super</span>(props)</span><br><span class="line">   <span class="built_in">this</span>.state=&#123; <span class="comment">//定义一个state</span></span><br><span class="line">       <span class="attr">conunt</span>:<span class="number">1</span> </span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=&#x27;listItem&#x27;&gt;</span><br><span class="line">      &lt;span&gt;&#123;this.state.count&#125;&lt;span&gt;  </span><br><span class="line">    &lt;div&gt;</span><br><span class="line">  )</span><br><span class="line"> &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="3-2-2-修改State"><a href="#3-2-2-修改State" class="headerlink" title="3.2.2 修改State"></a>3.2.2 修改State</h3><ul><li>使用setState</li><li>setState是异步的</li><li>State的更新是一个浅合并（shalllow merge）的过程</li></ul><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">ListItem</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">   <span class="built_in">super</span>(props)</span><br><span class="line">   <span class="built_in">this</span>.state=&#123;</span><br><span class="line">       <span class="attr">conunt</span>:<span class="number">1</span> </span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="title">addCunt</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&#x27;step1&#x27;</span>,<span class="built_in">this</span>.state.count)</span><br><span class="line">     <span class="built_in">this</span>.setState(&#123; <span class="comment">//修改一个state</span></span><br><span class="line">         <span class="attr">count</span>:<span class="built_in">this</span>.state.count+<span class="number">1</span></span><br><span class="line">     &#125;)</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&#x27;step2&#x27;</span>,<span class="built_in">this</span>.state.count)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=&#x27;listItem&#x27;&gt;</span><br><span class="line">      &lt;span onclick=&#123;()=&gt;this.addCount()&#125;&gt;&#123;this.state.count&#125;&lt;span&gt;  </span><br><span class="line">    &lt;div&gt;</span><br><span class="line">  )</span><br><span class="line"> &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>addCount函数中打印的2次<code>conut</code>的值是一样的，说明setState的处理过程是异步的而不是同步的,react在执行setState时候，优化执行的时机，多个setState合并在一起去执行，如果非要在state变化话后做一些操作的话，其实setState会接收第二个参数。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">ListItem</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">   <span class="built_in">super</span>(props)</span><br><span class="line">   <span class="built_in">this</span>.state=&#123;</span><br><span class="line">       <span class="attr">conunt</span>:<span class="number">1</span> </span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="title">addCunt</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="built_in">this</span>.setState(&#123; <span class="comment">//修改一个state</span></span><br><span class="line">         <span class="attr">count</span>:<span class="built_in">this</span>.state.count+<span class="number">1</span></span><br><span class="line">     &#125;,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">&#x27;step3&#x27;</span>,<span class="built_in">this</span>.state.count) <span class="comment">// 可以拿到修改后的值</span></span><br><span class="line">     &#125;)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=&#x27;listItem&#x27;&gt;</span><br><span class="line">      &lt;span onclick=&#123;()=&gt;this.addCount()&#125;&gt;&#123;this.state.count&#125;&lt;span&gt;  </span><br><span class="line">    &lt;div&gt;</span><br><span class="line">  )</span><br><span class="line"> &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="3-2-3-创建新的状态"><a href="#3-2-3-创建新的状态" class="headerlink" title="3.2.3 创建新的状态"></a>3.2.3 创建新的状态</h3><p>修改state我们都要遵循状态都应该是不可变数据</p><h4 id="什么是不可变数据"><a href="#什么是不可变数据" class="headerlink" title="什么是不可变数据"></a>什么是不可变数据</h4><p>不可变数据是函数式编程的重要概念，就是我们对已经初始化的数据不进行更改，每次更改都是创建新的对象来承载新的数据状态</p><p>状态类型</p><ul><li>值类型：string、number、boolean、null、undefined</li><li>数组类型</li><li>对象</li></ul><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.状态的类型是值类型</span></span><br><span class="line"><span class="built_in">this</span>.setState(&#123;</span><br><span class="line">    <span class="attr">count</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">    <span class="attr">show</span>:<span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 2.状态的类型是数组</span></span><br><span class="line"><span class="keyword">const</span> _books=<span class="built_in">this</span>.state.books.concat(<span class="string">&#x27;new book&#x27;</span>)</span><br><span class="line">   <span class="comment">// 或</span></span><br><span class="line"><span class="keyword">const</span> _books=[...this.state.books,<span class="string">&#x27;new book&#x27;</span>)]</span><br><span class="line"><span class="built_in">this</span>.setState(&#123;</span><br><span class="line">    <span class="attr">books</span>:_books</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 2.状态的类型是对象</span></span><br><span class="line"><span class="keyword">const</span> _item=<span class="built_in">Object</span>.assign(&#123;&#125;,<span class="built_in">this</span>.state.item,&#123;<span class="attr">id</span>:<span class="number">1</span>,<span class="attr">ame</span>:<span class="string">&#x27;zs&#x27;</span>&#125;)</span><br><span class="line">    <span class="comment">// 或</span></span><br><span class="line"><span class="keyword">const</span> _item=&#123;...this.state.item,<span class="attr">id</span>:<span class="number">1</span>,<span class="attr">ame</span>:<span class="string">&#x27;zs&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">this</span>.setState(&#123;</span><br><span class="line">    <span class="attr">item</span>:_item</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面创建新的对象都是浅拷贝，如果要深拷贝可以用immutable.js类库 来处理不可变数据。</p><h3 id="3-2-4-扩展资料"><a href="#3-2-4-扩展资料" class="headerlink" title="3.2.4 扩展资料"></a>3.2.4 扩展资料</h3><p><a href="https://www.npmjs.com/package/react-devtools">React Dev Tools</a></p><p><a href="https://juejin.im/entry/59a980306fb9a02485103d0b">状态组件和无状态组件</a></p><p><a href="https://juejin.im/post/5bf1444cf265da614a3a1660">setState异步的理解</a></p><h2 id="3-3-State进阶"><a href="#3-3-State进阶" class="headerlink" title="3.3 State进阶"></a>3.3 State进阶</h2><h3 id="3-3-1-通过条件判断优化渲染"><a href="#3-3-1-通过条件判断优化渲染" class="headerlink" title="3.3.1 通过条件判断优化渲染"></a>3.3.1 通过条件判断优化渲染</h3><p>下面代码是我们渲染一个列表，当我们删除第一行列表的时候，其它2个列表其实没有任何变化，但是它们的render方法还是执行了，执行了render方法其实也要diff对比，当一个大型的项目，这显然也是很耗时的，所以我们要优化它，优化有2种方法：</p><ol><li><p>sholudComponentUpdate(利用这个钩子阻止，如果子组件没有变化就不进行渲染)</p></li><li><p>PureComponent（利用react提供的组件）</p></li></ol><p><img src="~@/react/shouldUpdate.png"></p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="keyword">import</span> React,&#123;Component&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ListItem <span class="keyword">from</span> <span class="string">&#x27;./listItem&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stated</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    state = &#123; </span><br><span class="line">        <span class="attr">listData</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">              <span class="attr">name</span>: <span class="string">&quot;Sony 65寸高清液晶电视&quot;</span>,</span><br><span class="line">              <span class="attr">price</span>: <span class="number">7000</span>,</span><br><span class="line">              <span class="attr">stock</span>: <span class="number">1</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">              <span class="attr">name</span>: <span class="string">&quot;华为 Meta30&quot;</span>,</span><br><span class="line">              <span class="attr">price</span>: <span class="number">6000</span>,</span><br><span class="line">              <span class="attr">stock</span>: <span class="number">2</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">id</span>: <span class="number">3</span>,</span><br><span class="line">              <span class="attr">name</span>: <span class="string">&quot;华硕画家国度笔记本电脑&quot;</span>,</span><br><span class="line">              <span class="attr">price</span>: <span class="number">10000</span>,</span><br><span class="line">              <span class="attr">stock</span>: <span class="number">3</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="title">renderList</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span>  <span class="built_in">this</span>.state.listData.map(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ListItem</span> <span class="attr">key</span>=<span class="string">&#123;item.id&#125;</span> <span class="attr">data</span>=<span class="string">&#123;item&#125;</span> <span class="attr">onDelete</span>=<span class="string">&#123;this.handDelete&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">ListItem</span>&gt;</span></span></span><br><span class="line">        &#125;)</span><br><span class="line">     &#125;</span><br><span class="line">     handDelete=<span class="function">(<span class="params">id</span>)=&gt;</span>&#123;</span><br><span class="line">         <span class="keyword">const</span> listData=<span class="built_in">this</span>.state.listData.filter(<span class="function"><span class="params">item</span>=&gt;</span>item.id!==id)</span><br><span class="line">         <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">            listData</span><br><span class="line">         &#125;)       </span><br><span class="line">     &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> (  </span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">                &#123;this.state.listData.length&lt;=0 &amp;&amp; <span class="tag">&lt;<span class="name">div</span>&gt;</span>购物车为空<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="xml">                &#123;this.renderList()&#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Stated;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListItem</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    state = &#123;  &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;item render--虚拟dom&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> (  </span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;this.props.data.name&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="xml">                    this.props.onDelete(this.props.data.id)</span></span><br><span class="line"><span class="xml">                &#125;&#125;&gt;删除<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ListItem;</span><br></pre></td></tr></table></figure><h4 id="sholudComponentUpdate"><a href="#sholudComponentUpdate" class="headerlink" title="sholudComponentUpdate"></a>sholudComponentUpdate</h4><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListItem</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    state = &#123;  &#125;</span><br><span class="line">    <span class="function"><span class="title">shouldComponentUpdate</span>(<span class="params">nextProps,nextState</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nextProps.data.id===<span class="built_in">this</span>.props.data.id) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ListItem;</span><br></pre></td></tr></table></figure><h4 id="PureComponent"><a href="#PureComponent" class="headerlink" title="PureComponent"></a>PureComponent</h4><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="keyword">import</span> React,&#123;PrueComponent&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ListItem <span class="keyword">from</span> <span class="string">&#x27;./listItem&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stated</span> <span class="keyword">extends</span> <span class="title">PrueComponent</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-2-单一数据源"><a href="#3-3-2-单一数据源" class="headerlink" title="3.3.2 单一数据源"></a>3.3.2 单一数据源</h3><p>尊崇单一数据源，相同的子组件的数据应该由父组件通过<code>props</code>传递子组件，由父组件统一管理，避免造成数据的混乱，使用这个原则的时候，当父组件任何一个<br>状态的改变，会自动更新子组件这一部分，从上而下传达到子组件的，是同步的方法，子组件想操作数据，由父组件提供更新函数。</p><h3 id="3-3-3-状态提升"><a href="#3-3-3-状态提升" class="headerlink" title="3.3.3 状态提升"></a>3.3.3 状态提升</h3><p>当我们的子组件都要控制同一个数据源的时候，我们需要将数据提升到它们共同的父组件当中，然后父组件通过props传递给子组件，并由父组件进行统一管理和存储。</p><h3 id="3-3-4-为什么使用不可变数据"><a href="#3-3-4-为什么使用不可变数据" class="headerlink" title="3.3.4 为什么使用不可变数据"></a>3.3.4 为什么使用不可变数据</h3><ol><li>可回溯</li></ol><p> 不直接在数据上修改，方便我们追溯以前的历史记录。</p><ol start="2"><li>跟踪数据改变</li></ol><p>直接修改数据，跟踪数据的改变需要把当前数据和以前数据的版本进行对比，这样整个对象树都要遍历一次<br>如果使用不可变数据，创建新的对象，这样我们发现是一个新的对象，那我们不需要对象树对比就知道数据发生了变化，因为对象不是同一个引用了</p><ol start="3"><li>确定在react中何时重新渲染</li></ol><p>不可变性最主要优势在于它可以帮助我们在react中创建Pure components，我们可以轻松确定不可变数据是否发生了改变，从而确实何时对组件进行重新渲染</p><h3 id="3-3-5-有状态组件和无状态组件"><a href="#3-3-5-有状态组件和无状态组件" class="headerlink" title="3.3.5 有状态组件和无状态组件"></a>3.3.5 有状态组件和无状态组件</h3><h4 id="Stateful"><a href="#Stateful" class="headerlink" title="Stateful"></a>Stateful</h4><ul><li>类组件</li><li>有状态组件</li><li>容器组件</li></ul><h4 id="Stateless"><a href="#Stateless" class="headerlink" title="Stateless"></a>Stateless</h4><ul><li>函数组件</li><li>无状态组件</li><li>展示组件</li></ul><p>无状态组件，所有数据源都来自于父组件，它只做展示的作用</p><p>尽可能通过状态提升原则，将需要的状态提取到父组件中，而其他的组件使用无状态组件编写</p><h3 id="3-3-6-扩展资料"><a href="#3-3-6-扩展资料" class="headerlink" title="3.3.6 扩展资料"></a>3.3.6 扩展资料</h3><p><a href="https://github.com/immutable-js/immutable-js">不可变数据</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management">JS内存管理</a></p><p><a href="http://huziketang.mangojuice.top/books/react/lesson17">状态提升</a></p><p><a href="http://react.html.cn/docs/context.html">context管理状态</a></p><p><a href="https://juejin.im/post/5a90e0545188257a63112977">context管理状态</a>  </p><h2 id="3-4-生命周期"><a href="#3-4-生命周期" class="headerlink" title="3.4 生命周期"></a>3.4 生命周期</h2><h3 id="3-4-1-三个阶段的生命周期函数"><a href="#3-4-1-三个阶段的生命周期函数" class="headerlink" title="3.4.1 三个阶段的生命周期函数"></a>3.4.1 三个阶段的生命周期函数</h3><h4 id="三个阶段生命周期"><a href="#三个阶段生命周期" class="headerlink" title="三个阶段生命周期"></a>三个阶段生命周期</h4><p>创建阶段-&gt;更新阶段-&gt;卸载阶段</p><p><img src="~@/react/lifeCycle.png"></p><h3 id="3-4-2-创建阶段"><a href="#3-4-2-创建阶段" class="headerlink" title="3.4.2 创建阶段"></a>3.4.2 创建阶段</h3><h4 id="1-创建阶段constructor"><a href="#1-创建阶段constructor" class="headerlink" title="1. 创建阶段constructor"></a>1. 创建阶段constructor</h4><ul><li><p>初始化内部状态，显性设置和隐性设置</p><p> 一个类必须有<code>constructor</code>方法，如果这个方法没有显示定义，一个默认的<code>constructor</code>方法会被添加</p></li><li><p>需要使用super()调用基类的构造函数</p><p>将父类的props注入给子组件</p></li><li><p>可以直接修改state</p><h4 id="2-创建阶段componentWillMount-16-3移除"><a href="#2-创建阶段componentWillMount-16-3移除" class="headerlink" title="2. 创建阶段componentWillMount(16.3移除)"></a>2. 创建阶段componentWillMount(16.3移除)</h4></li><li><p>UI渲染完成前调用</p></li><li><p>只执行一次</p></li><li><p>这里调用setState不会触发render</p></li></ul><p> 更多的时候我们把组件里面的内容，会提前到<code>constructor</code>中，所以这个生命周期函数在项目中我们很少使用</p><h4 id="3-创建阶段render"><a href="#3-创建阶段render" class="headerlink" title="3. 创建阶段render"></a>3. 创建阶段render</h4><ul><li>一个组件必须有的方法（我们的类组件）</li><li>返回一个顶级的react元素<br>只能有一个根元素，不能返回并列元素</li><li>渲染的是Dom Tree的一个React对象</li></ul><h4 id="4-创建阶段componentDidMount"><a href="#4-创建阶段componentDidMount" class="headerlink" title="4. 创建阶段componentDidMount"></a>4. 创建阶段componentDidMount</h4><ul><li>UI渲染完成后调用</li><li>只执行一次</li><li>获取一些外部数据资源</li></ul><p>需要注意的是当父组件执行render的时候，当所有子组件都完成了创建，那么父组件才能最终的完成渲染，然后父组件执行componentDidMount</p><h3 id="3-4-3-更新阶段"><a href="#3-4-3-更新阶段" class="headerlink" title="3.4.3 更新阶段"></a>3.4.3 更新阶段</h3><p>当state和props发生变化时，进入更新阶段</p><h4 id="1-更新阶段componentWillReceiveProps-16-3移除"><a href="#1-更新阶段componentWillReceiveProps-16-3移除" class="headerlink" title="1.更新阶段componentWillReceiveProps(16.3移除)"></a>1.更新阶段componentWillReceiveProps(16.3移除)</h4><p>只接收props</p><ul><li>组件接收到新props的时候触发</li><li>在此对比新props和原来的props</li><li>不推荐使用</li></ul><h4 id="2-更新阶段shouldComponentUpdate"><a href="#2-更新阶段shouldComponentUpdate" class="headerlink" title="2.更新阶段shouldComponentUpdate"></a>2.更新阶段shouldComponentUpdate</h4><p>接收state和props</p><ul><li>是否要继续执行render方法</li><li>可以由PureComponent自动实现</li></ul><h4 id="3-更新阶段componentDidUpdate"><a href="#3-更新阶段componentDidUpdate" class="headerlink" title="3.更新阶段componentDidUpdate"></a>3.更新阶段componentDidUpdate</h4><ul><li>每次UI更新时调用</li><li>更新一些外部数据资源</li></ul><h3 id="3-4-4-卸载阶段-componentWillUnmount"><a href="#3-4-4-卸载阶段-componentWillUnmount" class="headerlink" title="3.4.4 卸载阶段 componentWillUnmount"></a>3.4.4 卸载阶段 componentWillUnmount</h3><ul><li>组件移除时调用</li><li>可以用来做资源的释放</li></ul><h3 id="3-4-5-图解生命周期"><a href="#3-4-5-图解生命周期" class="headerlink" title="3.4.5 图解生命周期"></a>3.4.5 图解生命周期</h3><h4 id="旧的生命周期"><a href="#旧的生命周期" class="headerlink" title="旧的生命周期"></a>旧的生命周期</h4><p><img src="~@/react/usedLifecycle.png"></p><h4 id="新的生命周期"><a href="#新的生命周期" class="headerlink" title="新的生命周期"></a>新的生命周期</h4><p>16.3以后移除了 componentWillmount、componentWillReceiveProps、componentWillUpdate</p><p><img src="~@/react/newLifecycle.png"></p><h3 id="3-4-6-扩展资料"><a href="#3-4-6-扩展资料" class="headerlink" title="3.4.6 扩展资料"></a>3.4.6 扩展资料</h3><p><a href="https://www.jianshu.com/p/514fe21b9914">React新生命周期1</a></p><p><a href="https://zhuanlan.zhihu.com/p/38030418">React新生命周期2</a></p><h2 id="3-5-React组件设计模式"><a href="#3-5-React组件设计模式" class="headerlink" title="3.5 React组件设计模式"></a>3.5 React组件设计模式</h2><h3 id="3-5-1-高阶组件"><a href="#3-5-1-高阶组件" class="headerlink" title="3.5.1 高阶组件"></a>3.5.1 高阶组件</h3><p>在业务中可能碰到许多要复用业务逻辑的情况，我们为了避免每个组件都写一段相同逻辑的代码，我们就用高阶组件。</p><p>高阶组件是对已有组件的封装，形成新的组件后，有自己的状态和逻辑；并可以传递已有的组件</p><p>高阶组件就是接收组件作为参数，并返回新的组件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> NewComponent=higherOrderComponent(OldComponent)</span><br></pre></td></tr></table></figure><p><img src="~@/react/higherOrder.png"></p><h4 id="案例：假如多个组件需要鼠标滑入时给个提示，滑出时清空提示，那么可以把这个公共提示抽离出来复用"><a href="#案例：假如多个组件需要鼠标滑入时给个提示，滑出时清空提示，那么可以把这个公共提示抽离出来复用" class="headerlink" title="案例：假如多个组件需要鼠标滑入时给个提示，滑出时清空提示，那么可以把这个公共提示抽离出来复用"></a>案例：假如多个组件需要鼠标滑入时给个提示，滑出时清空提示，那么可以把这个公共提示抽离出来复用</h4><p>目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">src/  </span><br><span class="line">    components/</span><br><span class="line">       Item/</span><br><span class="line">         index.jsx</span><br><span class="line">         withTooltip.js</span><br></pre></td></tr></table></figure><p>封装Hoc组件（withTooltip.js）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> withTooltip=<span class="function">(<span class="params">Component</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Hoc</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">        state=&#123;</span><br><span class="line">            <span class="attr">showToolTip</span>:<span class="literal">false</span>,</span><br><span class="line">            <span class="attr">content</span>:<span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        handleOver=<span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.setState(&#123;<span class="attr">showToolTip</span>:<span class="literal">true</span>,<span class="attr">content</span>:e.target.innerText&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        handleOut=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.setState(&#123;<span class="attr">showToolTip</span>:<span class="literal">true</span>,<span class="attr">content</span>:<span class="string">&#x27;&#x27;</span>&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span>(</span><br><span class="line">                <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onMouseOver</span>=<span class="string">&#123;this.handleOver&#125;</span> <span class="attr">onMouseOut</span>=<span class="string">&#123;this.handleOut&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">Component</span> <span class="attr">action</span>=<span class="string">&#123;this.state&#125;</span> &#123;<span class="attr">...props</span>&#125;&gt;</span><span class="tag">&lt;/<span class="name">Component</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Hoc</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withTooltip</span><br></pre></td></tr></table></figure><p>在需要的组件引入并调用（index.jsx）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import withTooltip from &#x27;./withTooltip&#x27;</span><br><span class="line">const ItemA = (props) =&gt; &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div className=&quot;container&quot;&gt;</span><br><span class="line">            &lt;button&gt;Tooltip&lt;/button&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                props.action.showToolTip &amp;&amp; &lt;div&gt;&#123;props.action.content&#125;&lt;/div&gt;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br><span class="line">export default withTooltip(ItemA)</span><br></pre></td></tr></table></figure><p><img src="~@/react/higherOrder2.png"></p><h4 id="高阶组件特性"><a href="#高阶组件特性" class="headerlink" title="高阶组件特性"></a>高阶组件特性</h4><ul><li>一个函数，传入一个组件，返回一个新组件</li><li>一般不会有ui展现</li><li>提供一些可复用的功能</li></ul><h3 id="3-5-2-函数作为子组件（renderProps）"><a href="#3-5-2-函数作为子组件（renderProps）" class="headerlink" title="3.5.2 函数作为子组件（renderProps）"></a>3.5.2 函数作为子组件（renderProps）</h3><p>解决复用业务逻辑的问题，是指一种在组件之间使用一个值为函数的props，来共享代码的的设计模式</p><p><img src="~@/react/renderProps.png"></p><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.定义子组件</span></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">                &#123;this.props.render(this.state)&#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 2.使用函数作为Props</span></span><br><span class="line">&lt;RenderPropComponent render=&#123;</span><br><span class="line">    <span class="function">(<span class="params">state</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            content</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;/&gt;</span><br></pre></td></tr></table></figure><h4 id="改写上面的案例"><a href="#改写上面的案例" class="headerlink" title="改写上面的案例"></a>改写上面的案例</h4><p>目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">src/  </span><br><span class="line">    components/</span><br><span class="line">       Rp/</span><br><span class="line">         index.jsx</span><br><span class="line">         withTooltip.js</span><br></pre></td></tr></table></figure><p>定义子组件（withTooltip.js）</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WithTooltip</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">        state=&#123;</span><br><span class="line">            <span class="attr">showToolTip</span>:<span class="literal">false</span>,</span><br><span class="line">            <span class="attr">content</span>:<span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        handleOver=<span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.setState(&#123;<span class="attr">showToolTip</span>:<span class="literal">true</span>,<span class="attr">content</span>:e.target.innerText&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        handleOut=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.setState(&#123;<span class="attr">showToolTip</span>:<span class="literal">true</span>,<span class="attr">content</span>:<span class="string">&#x27;&#x27;</span>&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span>(</span><br><span class="line">                <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onMouseOver</span>=<span class="string">&#123;this.handleOver&#125;</span> <span class="attr">onMouseOut</span>=<span class="string">&#123;this.handleOut&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    &#123;this.props.render(this.state)&#125;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> WithTooltip</span><br></pre></td></tr></table></figure><p>定义父组件（index.jsx)</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> WithTooltip <span class="keyword">from</span> <span class="string">&#x27;./withTooltip&#x27;</span></span><br><span class="line"><span class="keyword">const</span> ItemA = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">              <span class="tag">&lt;<span class="name">WithTooltip</span> </span></span></span><br><span class="line"><span class="tag"><span class="xml">                  <span class="attr">render</span>=<span class="string">&#123;(&#123;showToolTip,content&#125;)</span>=&gt;</span>(</span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">                      <span class="tag">&lt;<span class="name">button</span>&gt;</span>Tooltip<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">                        &#123;</span></span><br><span class="line"><span class="xml">                        showToolTip &amp;&amp; <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;content&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">                        &#125;</span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">                )&#125;&gt;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">WithTooltip</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ItemA</span><br></pre></td></tr></table></figure><h3 id="3-5-3-函数作为子组件（Children）"><a href="#3-5-3-函数作为子组件（Children）" class="headerlink" title="3.5.3 函数作为子组件（Children）"></a>3.5.3 函数作为子组件（Children）</h3><p>改写成函数作为子组件（更加直观）推荐</p><p>定义子组件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">    class WithTooltip extends React.Component &#123;</span><br><span class="line">        state=&#123;</span><br><span class="line">            showToolTip:false,</span><br><span class="line">            content:&#x27;&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">        handleOver=(e)=&gt;&#123;</span><br><span class="line">            this.setState(&#123;showToolTip:true,content:e.target.innerText&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        handleOut=()=&gt;&#123;</span><br><span class="line">            this.setState(&#123;showToolTip:true,content:&#x27;&#x27;&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        render()&#123;</span><br><span class="line">            return(</span><br><span class="line">                &lt;div onMouseOver=&#123;this.handleOver&#125; onMouseOut=&#123;this.handleOut&#125;&gt;</span><br><span class="line">                    &#123;this.props.children(this.state)&#125;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">export default WithTooltip</span><br></pre></td></tr></table></figure><p>定义父组件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import WithTooltip from &#x27;./withTooltip&#x27;</span><br><span class="line">const ItemB = (props) =&gt; &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div className=&quot;container&quot;&gt;</span><br><span class="line">              &lt;WithTooltip&gt;</span><br><span class="line">                &#123;(&#123;showToolTip,content&#125;)=&gt;(</span><br><span class="line">                    &lt;div&gt;</span><br><span class="line">                      &lt;button&gt;Tooltip&lt;/button&gt;</span><br><span class="line">                        &#123;</span><br><span class="line">                        showToolTip &amp;&amp; &lt;div&gt;&#123;content&#125;&lt;/div&gt;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">                )&#125;</span><br><span class="line">            &lt;/WithTooltip&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br><span class="line">export default ItemB</span><br></pre></td></tr></table></figure><h3 id="3-5-4-扩展阅读"><a href="#3-5-4-扩展阅读" class="headerlink" title="3.5.4 扩展阅读"></a>3.5.4 扩展阅读</h3><p><a href="https://www.jianshu.com/p/ff6b3008820a">扩展阅读1</a></p><p><a href="https://zhuanlan.zhihu.com/p/62791765">扩展阅读2</a></p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>步入React</title>
      <link href="/10919/"/>
      <url>/10919/</url>
      
        <content type="html"><![CDATA[<h2 id="2-1-搭建React环境"><a href="#2-1-搭建React环境" class="headerlink" title="2.1 搭建React环境"></a>2.1 搭建React环境</h2><p>安装nodejs+vscode，用nvm去管理node版本</p><h3 id="2-1-1-create-react-app"><a href="#2-1-1-create-react-app" class="headerlink" title="2.1.1 create-react-app"></a>2.1.1 create-react-app</h3><p>文档地址：<a href="https://www.html.cn/create-react-app/docs/getting-started/">create-react-app</a></p><p>创建一个项目：npx create-react-app my-app</p><p>建一个ts项目：npx create-react-app my-app –typescript</p><p>终端输入：<code>yarn eject</code> （慎用，会把潜藏的react-script弹射到应用层，此操作不可逆）</p><p>文档目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">my-app/</span><br><span class="line">  README.md</span><br><span class="line">  node_modules/</span><br><span class="line">  package.json</span><br><span class="line">  public/</span><br><span class="line">    index.html    <span class="comment"># 入口</span></span><br><span class="line">    favicon.ico</span><br><span class="line">    robots.txt    <span class="comment"># 搜索引擎爬取配置信息</span></span><br><span class="line">    manifest.json <span class="comment"># 配置页面需要的meta信息</span></span><br><span class="line">  src/            <span class="comment"># 项目主目录</span></span><br><span class="line">    App.css</span><br><span class="line">    App.js</span><br><span class="line">    App.test.js</span><br><span class="line">    index.css</span><br><span class="line">    index.js</span><br><span class="line">    logo.svg</span><br></pre></td></tr></table></figure><h3 id="2-1-2-开始前的配置"><a href="#2-1-2-开始前的配置" class="headerlink" title="2.1.2 开始前的配置"></a>2.1.2 开始前的配置</h3><h4 id="安装第三方插件"><a href="#安装第三方插件" class="headerlink" title="安装第三方插件"></a>安装第三方插件</h4><p>在vscode商店里下载</p><ul><li><p>simple react  快速生成react模版，可以看插件具体文档</p><p>编辑器中输入<code>cc</code>生成类组件，<code>sfc</code>生成函数示组件</p></li><li><p>prettier     格式化代码</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 一行最多 100 字符</span></span><br><span class="line">  <span class="attr">printWidth</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="comment">// 使用 2 个空格缩进</span></span><br><span class="line">  <span class="attr">tabWidth</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="comment">// 不使用缩进符，而使用空格</span></span><br><span class="line">  <span class="attr">useTabs</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// 行尾需不要有分号</span></span><br><span class="line">  <span class="attr">semi</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// 使用单引号</span></span><br><span class="line">  <span class="attr">singleQuote</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// 对象的 key 仅在必要时用引号</span></span><br><span class="line">  <span class="attr">quoteProps</span>: <span class="string">&#x27;as-needed&#x27;</span>,</span><br><span class="line">  <span class="comment">// jsx 不使用单引号，而使用双引号</span></span><br><span class="line">  <span class="attr">jsxSingleQuote</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// 末尾不需要逗号</span></span><br><span class="line">  <span class="attr">trailingComma</span>: <span class="string">&#x27;none&#x27;</span>,</span><br><span class="line">  <span class="comment">// 大括号内的首尾需要空格</span></span><br><span class="line">  <span class="attr">bracketSpacing</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// jsx 标签的反尖括号需要换行</span></span><br><span class="line">  <span class="attr">jsxBracketSameLine</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// 箭头函数，只有一个参数的时候，也需要括号</span></span><br><span class="line">  <span class="attr">arrowParens</span>: <span class="string">&#x27;always&#x27;</span>,</span><br><span class="line">  <span class="comment">// 每个文件格式化的范围是文件的全部内容</span></span><br><span class="line">  <span class="attr">rangeStart</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">rangeEnd</span>: <span class="literal">Infinity</span>,</span><br><span class="line">  <span class="comment">// 不需要写文件开头的 @prettier</span></span><br><span class="line">  <span class="attr">requirePragma</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// 不需要自动在文件开头插入 @prettier</span></span><br><span class="line">  <span class="attr">insertPragma</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// 使用默认的折行标准</span></span><br><span class="line">  <span class="attr">proseWrap</span>: <span class="string">&#x27;preserve&#x27;</span>,</span><br><span class="line">  <span class="comment">// 根据显示样式决定 html 要不要折行</span></span><br><span class="line">  <span class="attr">htmlWhitespaceSensitivity</span>: <span class="string">&#x27;css&#x27;</span>,</span><br><span class="line">  <span class="comment">// 换行符使用 lf</span></span><br><span class="line">  <span class="comment">// endOfLine: &#x27;lf&#x27;,</span></span><br><span class="line">  <span class="comment">// 在对象，数组括号与文字之间加空格 &quot;&#123; foo: bar &#125;&quot;</span></span><br><span class="line">  <span class="attr">bracketSpacing</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>配置vscode编辑配置文件</li></ul><p>可以配置针对该项目的配置文件，在根目录创建.vscode/settings.json</p><p>settings.json配置信息</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;eslint.autoFixOnSave&quot;</span>: <span class="literal">true</span>, <span class="comment">//eslint保存格式化</span></span><br><span class="line">  <span class="string">&quot;prettier.eslintIntegration&quot;</span>: <span class="literal">true</span>, <span class="comment">// 让prettier遵循eslint格式美化</span></span><br><span class="line">  <span class="string">&quot;eslint.enable&quot;</span>: <span class="literal">true</span>, <span class="comment">//是否开启vscode的eslint</span></span><br><span class="line">  <span class="string">&quot;files.eol&quot;</span>: <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">  <span class="string">&quot;editor.tabSize&quot;</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="string">&quot;editor.formatOnSave&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;editor.defaultFormatter&quot;</span>: <span class="string">&quot;esbenp.prettier-vscode&quot;</span>,</span><br><span class="line">  <span class="string">&quot;eslint.validate&quot;</span>: [<span class="string">&quot;javascript&quot;</span>, <span class="string">&quot;javascriptreact&quot;</span>, <span class="string">&quot;html&quot;</span>, <span class="string">&quot;typescript&quot;</span>, <span class="string">&quot;typescriptreact&quot;</span>], <span class="comment">//确定校验准则</span></span><br><span class="line">  <span class="string">&quot;files.associations&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;*.jsx&quot;</span>: <span class="string">&quot;javascriptreact&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;typescript.tsdk&quot;</span>: <span class="string">&quot;node_modules/typescript/lib&quot;</span>,</span><br><span class="line">  <span class="string">&quot;editor.codeActionsOnSave&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;source.fixAll.eslint&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-1-3-线上项目编辑器"><a href="#2-1-3-线上项目编辑器" class="headerlink" title="2.1.3 线上项目编辑器"></a>2.1.3 线上项目编辑器</h3><p><a href="https://codesandbox.io/">codesandbox</a></p><h2 id="2-2-组件和JSX"><a href="#2-2-组件和JSX" class="headerlink" title="2.2 组件和JSX"></a>2.2 组件和JSX</h2><h3 id="2-2-1-编写react元素"><a href="#2-2-1-编写react元素" class="headerlink" title="2.2.1 编写react元素"></a>2.2.1 编写react元素</h3><p>react 元素就是一个javascript对象</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const element=&lt;h1&gt;hello react&lt;/h1&gt;</span><br><span class="line">console.log(element);</span><br><span class="line">// render方法将react元素渲染到页面上</span><br><span class="line">ReactDOM.render(element, document.getElementById(&#x27;root&#x27;));</span><br><span class="line"></span><br><span class="line">// 打印结果</span><br><span class="line">&#123;</span><br><span class="line">$$typeof: Symbol(react.element)</span><br><span class="line">key: null</span><br><span class="line">props:&#123;children: &quot;hello react&quot;&#125;</span><br><span class="line">ref: null</span><br><span class="line">type: &quot;h1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-2-jsx"><a href="#2-2-2-jsx" class="headerlink" title="2.2.2 jsx"></a>2.2.2 jsx</h3><p>jsx是javascript的语法扩展，使用xml标记的方式直接声明界面</p><h4 id="jsx是什么"><a href="#jsx是什么" class="headerlink" title="jsx是什么"></a>jsx是什么</h4><ul><li>不是模版引擎语言</li></ul><p>模版引擎语言Angular和vue中template的语法，js模版的作用就是输入模版的字符串+数据，经过渲染得到渲染过的字符串；jsx不是这样的模版引擎，它是带语法糖的ATX，其实是抽象的语法树，语法糖放到了构建阶段，所以运行的时候不需要解析。</p><ul><li><p>声明示方式创建UI，处理UI逻辑</p></li><li><p>遵循javascript语法，无学习门槛</p></li></ul><h4 id="react通过babel将jsx转换浏览器识别的语言"><a href="#react通过babel将jsx转换浏览器识别的语言" class="headerlink" title="react通过babel将jsx转换浏览器识别的语言"></a>react通过babel将jsx转换浏览器识别的语言</h4><p><a href="https://www.babeljs.cn/repl">bable</a></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ele=<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">         <span class="tag">&lt;<span class="name">p</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 转换后</span></span><br><span class="line"><span class="keyword">var</span> ele = <span class="comment">/*#__PURE__*/</span>React.createElement(<span class="string">&quot;div&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">className</span>: <span class="string">&quot;root&quot;</span></span><br><span class="line">&#125;, <span class="comment">/*#__PURE__*/</span>React.createElement(<span class="string">&quot;p&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;hello&quot;</span>));</span><br><span class="line"><span class="comment">// 通过createElement创建元素</span></span><br></pre></td></tr></table></figure><p>react通过层层嵌套的方法，把我们输入的语句转换成浏览器识别的代码，这就是<code>jsx</code>背后的原理</p><h4 id="jsx-规则"><a href="#jsx-规则" class="headerlink" title="jsx 规则"></a>jsx 规则</h4><ul><li>在jsx中潜入表达式，用<code>&#123;&#125;</code>包裹</li><li>大写开头作为定义组件，小写tag作为原生的dom节点</li><li>jsx标签可以有特定属性和子元素</li><li>jsx只能有一个根元素</li></ul><h4 id="jsx-实践"><a href="#jsx-实践" class="headerlink" title="jsx 实践"></a>jsx 实践</h4><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">main</span> <span class="keyword">extends</span> <span class="title">Components</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>(props)</span><br><span class="line">     <span class="built_in">this</span>.state=&#123;</span><br><span class="line">      <span class="attr">name</span>:<span class="string">&quot;zs&quot;</span>,</span><br><span class="line">      <span class="attr">age</span>:<span class="number">12</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">addage</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.state.age+<span class="number">12</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> flag=<span class="literal">true</span></span><br><span class="line">    <span class="keyword">const</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="comment">// jsx需要一个根元素</span></span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;this.state.name&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;this.state.age&gt;18?&#x27;成年&#x27;:&#x27;未成年&#x27;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;this.addage.call(this)&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">          &#123;/* 三元表达式判断显示元素 */&#125;</span></span><br><span class="line"><span class="xml">        &#123;</span></span><br><span class="line"><span class="xml">          flag?</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>元素1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">           :</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>元素1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">        &#123;/* 只能用map循环 */&#125;</span></span><br><span class="line"><span class="xml">        &#123;list.map((item) =&gt; &#123;</span></span><br><span class="line"><span class="xml">          return <span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&#x27;item&#x27;</span>&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#125;)&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jsx需要一个根元素包裹，因为jsx是通过babel进行转译，其实就是通过<code>React.createElement()</code>，它的第一个参数需要一个元素，如果出现2个就无法识别了</p><h4 id="Fragments"><a href="#Fragments" class="headerlink" title="Fragments"></a>Fragments</h4><p>用Fragments替换根元素，而且此标签不渲染到页面中</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">main</span> <span class="keyword">extends</span> <span class="title">Components</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;this.state.name&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;this.state.age&gt;18?&#x27;成年&#x27;:&#x27;未成年&#x27;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;this.addage()&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者用react提供的简洁方法</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">main</span> <span class="keyword">extends</span> <span class="title">Components</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;this.state.name&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;this.state.age&gt;18?&#x27;成年&#x27;:&#x27;未成年&#x27;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;this.addage()&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么使用Fragments</p><ul><li>可以包含并列的子元素</li><li>编写表格组件，包裹子元素让html生效</li></ul><h3 id="2-2-3-拓展学习资料"><a href="#2-2-3-拓展学习资料" class="headerlink" title="2.2.3 拓展学习资料"></a>2.2.3 拓展学习资料</h3><p><a href="https://juejin.im/post/5ab9f2f3f265da239b4174f0">Babel和ATS 抽象语法树1</a></p><p><a href="https://github.com/barretlee/babel-plugin-ast">Babel和ATS 抽象语法树2</a></p><h2 id="2-3-props、列表渲染、条件渲染"><a href="#2-3-props、列表渲染、条件渲染" class="headerlink" title="2.3 props、列表渲染、条件渲染"></a>2.3 props、列表渲染、条件渲染</h2><p>什么是props？</p><p>当react元素作为自定义组件，将jsx所接受的属性转换成单个对象传递给组件，这个对象被称为“props”（就是父组件传递给子组件的对象）</p><ul><li>props是组件的固有属性</li><li>不可在组件内部对props进行修改</li><li>更新props：需要通过父组件重新传入新的props，更新子组件（单向数据流）</li></ul><h3 id="2-3-1-示例"><a href="#2-3-1-示例" class="headerlink" title="2.3.1 示例"></a>2.3.1 示例</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> listData=&#123;<span class="attr">name</span>:<span class="string">&#x27;react&#x27;</span>&#125;</span><br><span class="line">  <span class="comment">// 父组件</span></span><br><span class="line">  funtion App ()&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="comment">/* 传递数据listData*/</span>&#125;</span><br><span class="line">        &lt;ListItem data=&#123;listData&#125;&gt;&lt;/ListItem&gt; </span><br><span class="line">      &lt;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 子组件</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ListItem</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">     <span class="built_in">super</span>(props) <span class="comment">//子类中调用父类构造函数</span></span><br><span class="line">   &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> ( </span><br><span class="line">            &lt;div&gt;</span><br><span class="line">             &lt;div&gt;</span><br><span class="line">             &#123;<span class="comment">/* 通过props拿到值 */</span>&#125;</span><br><span class="line">              &#123;<span class="built_in">this</span>.props.data.name&#125;  </span><br><span class="line">            &lt;div&gt;</span><br><span class="line">          &lt;div&gt;</span><br><span class="line">         );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数示组件"><a href="#函数示组件" class="headerlink" title="函数示组件"></a>函数示组件</h4><ul><li>函数组件也叫无状态组件</li><li>组件内部没有this</li><li>没有声明周期</li></ul><p>改写如下</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子组件</span></span><br><span class="line">funtion ListItem (props)&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="comment">/* 通过props拿到值 */</span>&#125;</span><br><span class="line">       &#123;props.data.name&#125;  </span><br><span class="line">      &lt;div&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前组件如果是纯展示组件，可以用函数组件，函数组件是一个纯函数，用函数组件可以得到性能的提升</p><h3 id="2-3-2-列表渲染"><a href="#2-3-2-列表渲染" class="headerlink" title="2.3.2 列表渲染"></a>2.3.2 列表渲染</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> listData=[&#123;<span class="attr">name</span>:<span class="string">&#x27;react&#x27;</span>,<span class="attr">id</span>:<span class="number">1</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">&#x27;vue&#x27;</span>,<span class="attr">id</span>:<span class="number">2</span>&#125;]</span><br><span class="line">  <span class="comment">// 父组件</span></span><br><span class="line">  funtion App ()&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="comment">/* 传递数据listData*/</span>&#125;</span><br><span class="line">       &#123;</span><br><span class="line">         listData.map(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ListItem</span> <span class="attr">data</span>=<span class="string">&#123;item&#125;</span> <span class="attr">key</span>=<span class="string">&#123;item.id&#125;/</span>&gt;</span></span></span><br><span class="line">         &#125;)</span><br><span class="line">       &#125;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-3-条件渲染"><a href="#2-3-3-条件渲染" class="headerlink" title="2.3.3 条件渲染"></a>2.3.3 条件渲染</h3><p>条件渲染的主要方法</p><ul><li>使用三目运算符</li><li>使用函数做条件判断</li><li>使用与运算符 &amp;&amp; 判断</li></ul><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListItem</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">   <span class="built_in">super</span>(props) <span class="comment">//子类中调用父类构造函数</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="title">renderList</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(<span class="built_in">this</span>.props.data.name===<span class="string">&#x27;react&#x27;</span>)&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>jsx<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">   &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>template<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;s</span><br><span class="line"> <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=&#x27;listItem&#x27;&gt;</span><br><span class="line">      &#123;/* 使用三目运算符*/&#125;</span><br><span class="line">      &lt;div className=&#123;`thend-grid`$&#123;this.props.data.name===&#x27;react&#x27;?&#x27;-blue&#x27;:&#x27;-green&#x27;&#125;&#125;&gt;</span><br><span class="line">       &#123;this.props.data.name===&#x27;react&#x27;?&#x27;jsx&#x27;:&#x27;template&#x27;&#125;  </span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;/*使用函数做条件判断*/&#125;</span><br><span class="line">      &#123;this.renderList.call(this)&#125;</span><br><span class="line">        &#123;/*使用与运算符 &amp;&amp; 判断*/&#125;</span><br><span class="line">      &#123;this.props.data.name===&#x27;react&#x27; &amp;&amp; &lt;div&gt;jsx&lt;/div&gt;&#125;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">  )</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-3-4-拓展学习资料"><a href="#2-3-4-拓展学习资料" class="headerlink" title="2.3.4 拓展学习资料"></a>2.3.4 拓展学习资料</h3><p><a href="https://zhuanlan.zhihu.com/p/41237949">列表渲染进阶知识</a></p><p><a href="https://juejin.im/post/5ab0bff06fb9a028d444696b">更多的条件渲染的方式</a></p><h2 id="2-4-CSS-in-React"><a href="#2-4-CSS-in-React" class="headerlink" title="2.4 CSS in React"></a>2.4 CSS in React</h2><h3 id="2-4-1-行内样式"><a href="#2-4-1-行内样式" class="headerlink" title="2.4.1 行内样式"></a>2.4.1 行内样式</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;div style=&#123;&#123;<span class="attr">fontSize</span>:<span class="number">18</span>;color:red&#125;&#125;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="2-4-2-引入css样式表"><a href="#2-4-2-引入css样式表" class="headerlink" title="2.4.2 引入css样式表"></a>2.4.2 引入css样式表</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">    src/   </span><br><span class="line">       components/</span><br><span class="line">         ListItem/</span><br><span class="line">           index.jsx</span><br><span class="line">           index.css <span class="comment">//也可以用scss，文件命名index.css</span></span><br><span class="line"> <span class="comment">// 我们在index.css 定义样式</span></span><br><span class="line">   .title&#123;</span><br><span class="line">     <span class="attr">color</span>:red;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在ListItem导入</span></span><br><span class="line">   <span class="keyword">import</span> <span class="string">&#x27;./index.css&#x27;</span> </span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">ListItem</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>(props) <span class="comment">//子类中调用父类构造函数</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> (</span><br><span class="line">     &lt;div className=&#x27;listItem&#x27;&gt;</span><br><span class="line">       &lt;span className=&#x27;title&#x27;&gt;header&lt;span&gt;</span><br><span class="line">     &lt;div&gt;</span><br><span class="line">   )</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>上面的在index.css写法，里面的样式是全局样式，会造成全局污染，可以用css module解决</p><h4 id="css-module"><a href="#css-module" class="headerlink" title="css module"></a>css module</h4><ul><li>不使用选择器，使用class名定义样式</li><li>不层叠class，使用一个class定义样式</li><li>用过compose来组合</li></ul><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">      src/   </span><br><span class="line">       components/</span><br><span class="line">         ListItem/</span><br><span class="line">           index.jsx</span><br><span class="line">           index.module.css <span class="comment">//命名方式加入module</span></span><br><span class="line"> <span class="comment">// 我们在index.css 定义样式</span></span><br><span class="line">   .title&#123;</span><br><span class="line">     <span class="attr">color</span>:red;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在ListItem导入对象</span></span><br><span class="line">   <span class="keyword">import</span> style <span class="keyword">from</span> <span class="string">&#x27;index.module.css&#x27;</span> </span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">ListItem</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>(props) <span class="comment">//子类中调用父类构造函数</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> (</span><br><span class="line">     &lt;div className=&#x27;listItem&#x27;&gt;</span><br><span class="line">       &lt;span className=&#123;style.title&#125;&gt;header&lt;span&gt;</span><br><span class="line">     &lt;div&gt;</span><br><span class="line">   )</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-3-css管理进阶"><a href="#2-4-3-css管理进阶" class="headerlink" title="2.4.3 css管理进阶"></a>2.4.3 css管理进阶</h3><p>css管理工具</p><ul><li>Styled-component</li><li>Classnames</li></ul><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">      src/   </span><br><span class="line">       components/</span><br><span class="line">         ListItem/</span><br><span class="line">           index.jsx</span><br><span class="line">           index.module.css <span class="comment">//命名方式加入module</span></span><br><span class="line"> <span class="comment">// 我们在index.css 定义样式</span></span><br><span class="line">   .title&#123;</span><br><span class="line">     <span class="attr">color</span>:red;</span><br><span class="line">   &#125;</span><br><span class="line">   .themd &#123;</span><br><span class="line">     <span class="attr">background</span>:<span class="string">&#x27;red&#x27;</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在ListItem导入对象</span></span><br><span class="line">   <span class="keyword">import</span> style <span class="keyword">from</span> <span class="string">&#x27;index.module.css&#x27;</span> </span><br><span class="line">   <span class="keyword">import</span> classnames <span class="keyword">from</span> <span class="string">&#x27;classnames/bind&#x27;</span></span><br><span class="line">   <span class="keyword">const</span> cls=classnames.bind(style)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">import</span> cn <span class="keyword">from</span> <span class="string">&#x27;classnames&#x27;</span></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">ListItem</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>(props) <span class="comment">//子类中调用父类构造函数</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> flag=<span class="literal">true</span></span><br><span class="line">    <span class="keyword">const</span> _cn=cn(&#123;</span><br><span class="line">      <span class="string">&#x27;themd&#x27;</span>:flag</span><br><span class="line">    &#125;)</span><br><span class="line">   <span class="keyword">return</span> (</span><br><span class="line">     &lt;div className=&#x27;listItem&#x27;&gt;</span><br><span class="line">       &#123;/* css Module+classnames/bind */&#125;</span><br><span class="line">       &#123;/* css module 结合 classnames 可以添加2个类名 */&#125;</span><br><span class="line">       &lt;span className=&#123;cls(&#x27;title&#x27;,&#x27;themd&#x27;)&#125;&gt;header&lt;span&gt;</span><br><span class="line">       &#123;&#123;/* classnames */&#125;</span><br><span class="line">       &lt;span className=&#123;_cn&#125;&gt;&lt;/span&gt;</span><br><span class="line">     &lt;div&gt;</span><br><span class="line">   )</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-4-扩展"><a href="#2-4-4-扩展" class="headerlink" title="2.4.4 扩展"></a>2.4.4 扩展</h3><p><a href="http://www.ruanyifeng.com/blog/2016/06/css_modules.html">css module</a></p><p><a href="https://www.styled-components.com/">styled   component</a></p><p><a href="https://juejin.im/post/5c3d67066fb9a049f06a8323">在React中使用css预编译</a></p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>入门介绍</title>
      <link href="/11239/"/>
      <url>/11239/</url>
      
        <content type="html"><![CDATA[<h2 id="1-1-什么是React"><a href="#1-1-什么是React" class="headerlink" title="1.1 什么是React"></a>1.1 什么是React</h2><p>用于构建用户界面（组件components）的javascript库</p><h2 id="1-2-React生态"><a href="#1-2-React生态" class="headerlink" title="1.2 React生态"></a>1.2 React生态</h2><ul><li>react-Redux</li><li>React Router</li><li>dva</li><li>AntDesign</li><li>Styled-Component</li><li>React Native</li><li>Taro</li></ul><p>……</p><h2 id="1-3-为什么选择React"><a href="#1-3-为什么选择React" class="headerlink" title="1.3 为什么选择React"></a>1.3 为什么选择React</h2><ul><li>组件化的开发构思，项目便于维护</li><li>只需关注业务逻辑，高效快速更新DOM</li><li>海量的周边生态，友好的开发环境</li></ul>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js高频手写题-目录</title>
      <link href="/51568/"/>
      <url>/51568/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="/49497/#1.%E6%89%8B%E5%86%99instanceof"> 1. 手写instanceof</a></li><li><a href="/49177/#2.%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E7%9A%84map%E6%96%B9%E6%B3%95"> 2. 实现数组的map方法</a></li><li><a href="/216/#3.reduce%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E7%9A%84map%E6%96%B9%E6%B3%95"> 3. reduce实现数组的map方法</a></li><li><a href="/1176/#4.%E6%89%8B%E5%86%99%E6%95%B0%E7%BB%84%E7%9A%84reduce%E6%96%B9%E6%B3%95"> 4. 手写数组的reduce方法</a></li><li><a href="/50265/#5.%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96"> 5. 数组扁平化</a></li><li><a href="/60931/#6.%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96"> 6. 函数柯里化</a></li><li><a href="/11970/#%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%AE%9E%E7%8E%B0"> 7. 浅拷贝实现</a></li><li><a href="/12162/#8.%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%AE%9E%E7%8E%B0"> 8.深拷贝实现</a></li><li><a href="/61251/#9.%E6%89%8B%E5%86%99call/apply/bind"> 9. 手写call/apply/bind</a></li><li><a href="/11522/#10.%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0new"> 10. 手动实现new</a></li><li><a href="/60867/#11.%E6%89%8B%E5%86%99promise/promise.all/promise.race"> 11. 手写promise(常考promise.all, promise.race)</a>)</li><li><a href="/60547/#12.%E6%89%8B%E5%86%99%E5%8E%9F%E7%94%9FAJAX"> 12. 手写原生AJAX</a></li><li><a href="/11330/#13.%E6%89%8B%E5%86%99%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96%E5%87%BD%E6%95%B0"> 13. 手写节流防抖函数</a></li><li><a href="/10242/#14.%E6%89%8B%E5%86%99Promise%E5%8A%A0%E8%BD%BD%E5%9B%BE%E7%89%87"> 14. 手写Promise加载图片</a></li><li><a href="/59587/#16.%E5%AE%9E%E7%8E%B0%E4%BA%8B%E4%BB%B6%E8%AE%A2%E9%98%85%E5%8F%91%E5%B8%83(eventBus)"> 16.  实现事件订阅发布(eventBus)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端面试 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js-hand-19</title>
      <link href="/59587/"/>
      <url>/59587/</url>
      
        <content type="html"><![CDATA[<h2 id="19-实现事件订阅发布-eventBus"><a href="#19-实现事件订阅发布-eventBus" class="headerlink" title="19.实现事件订阅发布(eventBus)"></a>19.实现事件订阅发布(eventBus)</h2><blockquote><p>实现EventBus类，有 on off once trigger功能，分别对应绑定事件监听器，解绑，执行一次后解除事件绑定，触发事件监听器。 </p></blockquote><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>查看答案</span></div>    <div class="hide-content"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventBus</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">on</span>(<span class="params">eventName, listener</span>)</span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="title">off</span>(<span class="params">eventName, listener</span>)</span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="title">once</span>(<span class="params">eventName, listener</span>)</span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="title">trigger</span>(<span class="params">eventName</span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> e = <span class="keyword">new</span> EventBus();</span><br><span class="line"><span class="comment">// fn1 fn2</span></span><br><span class="line">e.on(<span class="string">&#x27;e1&#x27;</span>, fn1)</span><br><span class="line">e.once(<span class="string">&#x27;e1&#x27;</span>, fn2)</span><br><span class="line">e.trigger(<span class="string">&#x27;e1&#x27;</span>) <span class="comment">// fn1() fn2()</span></span><br><span class="line">e.trigger(<span class="string">&#x27;e1&#x27;</span>) <span class="comment">// fn1()</span></span><br><span class="line">e.off(<span class="string">&#x27;e1&#x27;</span>, fn1)</span><br><span class="line">e.trigger(<span class="string">&#x27;e1&#x27;</span>) <span class="comment">// null</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventBus</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.eventList = &#123;&#125; <span class="comment">//创建对象收集事件</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//发布事件</span></span><br><span class="line">  $on(eventName, fn) &#123;</span><br><span class="line">    <span class="comment">//判断是否发布过事件名称? 添加发布 : 创建并添加发布</span></span><br><span class="line">    <span class="built_in">this</span>.eventList[eventName]</span><br><span class="line">      ? <span class="built_in">this</span>.eventList[eventName].push(fn)</span><br><span class="line">      : (<span class="built_in">this</span>.eventList[eventName] = [fn])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//订阅事件</span></span><br><span class="line">  $emit(eventName) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!eventName) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;请传入事件名&#x27;</span>)</span><br><span class="line">    <span class="comment">//获取订阅传参</span></span><br><span class="line">    <span class="keyword">const</span> data = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.eventList[eventName]) &#123;</span><br><span class="line">      <span class="built_in">this</span>.eventList[eventName].forEach(<span class="function">(<span class="params">i</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          i(...data) <span class="comment">//轮询事件</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          <span class="built_in">console</span>.error(e + <span class="string">&#x27;eventName:&#x27;</span> + eventName) <span class="comment">//收集执行时的报错</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//执行一次</span></span><br><span class="line">  $once(eventName, fn) &#123;</span><br><span class="line">    <span class="keyword">const</span> _this = <span class="built_in">this</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onceHandle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      fn.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>)</span><br><span class="line">      _this.$off(eventName, onceHandle) <span class="comment">//执行成功后取消监听</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.$on(eventName, onceHandle)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//取消订阅</span></span><br><span class="line">  $off(eventName, fn) &#123;</span><br><span class="line">    <span class="comment">//不传入参数时取消全部订阅</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">arguments</span>.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="built_in">this</span>.eventList = &#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//eventName传入的是数组时,取消多个订阅</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(eventName)) &#123;</span><br><span class="line">      <span class="keyword">return</span> eventName.forEach(<span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.$off(event, fn)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不传入fn时取消事件名下的所有队列</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">1</span> || !fn) &#123;</span><br><span class="line">      <span class="built_in">this</span>.eventList[eventName] = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取消事件名下的fn</span></span><br><span class="line">    <span class="built_in">this</span>.eventList[eventName] = <span class="built_in">this</span>.eventList[eventName].filter(</span><br><span class="line">      <span class="function">(<span class="params">f</span>) =&gt;</span> f !== fn</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> event = <span class="keyword">new</span> EventBus()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="function"><span class="keyword">function</span> (<span class="params">v1, v2, v3</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;b&#x27;</span>, v1, v2, v3)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">event.$once(<span class="string">&#x27;test&#x27;</span>, a)</span><br><span class="line">event.$on(<span class="string">&#x27;test&#x27;</span>, b)</span><br><span class="line">event.$emit(<span class="string">&#x27;test&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">123</span>)</span><br><span class="line"></span><br><span class="line">event.$off([<span class="string">&#x27;test&#x27;</span>], b)</span><br><span class="line"></span><br><span class="line">event.$emit(<span class="string">&#x27;test&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">123</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div>]]></content>
      
      
      <categories>
          
          <category> Js手写题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js-hand-18</title>
      <link href="/10242/"/>
      <url>/10242/</url>
      
        <content type="html"><![CDATA[<h2 id="18-手写Promise加载图片"><a href="#18-手写Promise加载图片" class="headerlink" title="18.手写Promise加载图片"></a>18.手写Promise加载图片</h2><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>查看答案</span></div>    <div class="hide-content"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">      url,</span><br><span class="line">      <span class="function"><span class="title">success</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">        resolve(data)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="title">error</span>(<span class="params">err</span>)</span> &#123;</span><br><span class="line">        reject(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> url1 = <span class="string">&#x27;./data1.json&#x27;</span></span><br><span class="line"><span class="keyword">const</span> url2 = <span class="string">&#x27;./data2.json&#x27;</span></span><br><span class="line"><span class="keyword">const</span> url3 = <span class="string">&#x27;./data3.json&#x27;</span></span><br><span class="line">getData(url1).then(<span class="function"><span class="params">data1</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data1)</span><br><span class="line">  <span class="keyword">return</span> getData(url2)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data2</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data2)</span><br><span class="line">  <span class="keyword">return</span> getData(url3)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data3</span> =&gt;</span></span><br><span class="line">  <span class="built_in">console</span>.log(data3)</span><br><span class="line">).catch(<span class="function"><span class="params">err</span> =&gt;</span></span><br><span class="line">  <span class="built_in">console</span>.error(err)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div></div>]]></content>
      
      
      <categories>
          
          <category> Js手写题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js-hand-17</title>
      <link href="/11330/"/>
      <url>/11330/</url>
      
        <content type="html"><![CDATA[<h2 id="17-手写节流防抖函数"><a href="#17-手写节流防抖函数" class="headerlink" title="17. 手写节流防抖函数"></a>17. 手写节流防抖函数</h2><blockquote><p>函数节流与函数防抖都是为了限制函数的执行频次，是一种性能优化的方案，比如应用于window对象的resize、scroll事件，拖拽时的mousemove事件，文字输入、自动完成的keyup事件。</p></blockquote><blockquote><p><strong>节流</strong>：连续触发事件但是在 n 秒中只执行一次函数</p></blockquote><p>例:（连续不断动都需要调用时用，设一时间间隔），像dom的拖拽，如果用消抖的话，就会出现卡顿的感觉，因为只在停止的时候执行了一次，这个时候就应该用节流，在一定时间内多次执行，会流畅很多。</p><blockquote><p><strong>防抖</strong>：指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。</p></blockquote><p>例:（连续不断触发时不调用，触发完后过一段时间调用），像仿百度搜索，就应该用防抖，当我连续不断输入时，不会发送请求；当我一段时间内不输入了，才会发送一次请求；如果小于这段时间继续输入的话，时间会重新计算，也不会发送请求。</p><p>防抖的实现：</p><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>查看答案</span></div>    <div class="hide-content"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(<span class="keyword">typeof</span> fn!==<span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;fn不是函数&#x27;</span>)</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">let</span> timer; <span class="comment">// 维护一个 timer</span></span><br><span class="line">     <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">         <span class="keyword">var</span> _this = <span class="built_in">this</span>; <span class="comment">// 取debounce执行作用域的this(原函数挂载到的对象)</span></span><br><span class="line">         <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">         <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">         &#125;</span><br><span class="line">         timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            fn.apply(_this, args); <span class="comment">// 用apply指向调用debounce的对象，相当于_this.fn(args);</span></span><br><span class="line">         &#125;, delay);</span><br><span class="line">     &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用​</span></span><br><span class="line">input1.addEventListener(<span class="string">&#x27;keyup&#x27;</span>, debounce(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(input1.value)</span><br><span class="line">&#125;), <span class="number">600</span>)</span><br></pre></td></tr></table></figure></div></div><p>节流的实现：</p><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>查看答案</span></div>    <div class="hide-content"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      fn.apply(_this, args); <span class="comment">// 这里args接收的是外边返回的函数的参数，不能用arguments</span></span><br><span class="line">      <span class="comment">// fn.apply(_this, arguments); 需要注意：Chrome 14 以及 Internet Explorer 9 仍然不接受类数组对象。如果传入类数组对象，它们会抛出异常。</span></span><br><span class="line">      timer = <span class="literal">null</span>; <span class="comment">// 在delay后执行完fn之后清空timer，此时timer为假，throttle触发可以进入计时器</span></span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div1.addEventListener(<span class="string">&#x27;drag&#x27;</span>, throttle(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.offsetX, e.offsetY)</span><br><span class="line">&#125;, <span class="number">100</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div>]]></content>
      
      
      <categories>
          
          <category> Js手写题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js-hand-16</title>
      <link href="/60547/"/>
      <url>/60547/</url>
      
        <content type="html"><![CDATA[<h2 id="16-手写原生AJAX"><a href="#16-手写原生AJAX" class="headerlink" title="16. 手写原生AJAX"></a>16. 手写原生AJAX</h2><blockquote><p><strong>步骤</strong></p></blockquote><ol><li> 创建 XMLHttpRequest 实例</li><li> 发出 HTTP 请求</li><li> 服务器返回 XML 格式的字符串</li><li>JS 解析 XML，并更新局部页面<blockquote><blockquote><p>了解了属性和方法之后，根据 AJAX 的步骤，手写最简单的 GET 请求。</p></blockquote></blockquote></li></ol><ul><li>version 1.0：</li></ul><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>查看答案</span></div>    <div class="hide-content"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">myButton.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  ajax()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest() <span class="comment">//实例化，以调用方法</span></span><br><span class="line">  xhr.open(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;https://www.google.com&#x27;</span>)  <span class="comment">//参数2，url。参数三：异步</span></span><br><span class="line">  xhr.onreadystatechange = <span class="function">() =&gt;</span> &#123;  <span class="comment">//每当 readyState 属性改变时，就会调用该函数。</span></span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;  <span class="comment">//XMLHttpRequest 代理当前所处状态。</span></span><br><span class="line">      <span class="keyword">if</span> (xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) &#123;  <span class="comment">//200300请求成功</span></span><br><span class="line">        <span class="keyword">let</span> string = request.responseText</span><br><span class="line">        <span class="comment">//JSON.parse() 方法用来解析JSON字符串，构造由字符串描述的JavaScript值或对象</span></span><br><span class="line">        <span class="keyword">let</span> object = <span class="built_in">JSON</span>.parse(string)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  request.send() <span class="comment">//用于实际发出 HTTP 请求。不带参数为GET请求</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><ul><li>promise版本实现<div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>查看答案</span></div>    <div class="hide-content"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">    xhr.open(<span class="string">&#x27;get&#x27;</span>, url)</span><br><span class="line">    xhr.onreadystatechange = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt;= <span class="number">300</span>) &#123;</span><br><span class="line">          resolve(<span class="built_in">JSON</span>.parse(xhr.responseText))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          reject(<span class="string">&#x27;请求出错&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.send()  <span class="comment">//发送hppt请求</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> url = <span class="string">&#x27;/data.json&#x27;</span></span><br><span class="line">ajax(url).then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">  .catch(<span class="function"><span class="params">reason</span> =&gt;</span> <span class="built_in">console</span>.log(reason))</span><br></pre></td></tr></table></figure></div></div></li></ul>]]></content>
      
      
      <categories>
          
          <category> Js手写题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js-hand-15</title>
      <link href="/60867/"/>
      <url>/60867/</url>
      
        <content type="html"><![CDATA[<h2 id="15-手写promise-常考promise-all-promise-race"><a href="#15-手写promise-常考promise-all-promise-race" class="headerlink" title="15. 手写promise(常考promise.all, promise.race)"></a>15. 手写promise(常考promise.all, promise.race)</h2><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>查看答案</span></div>    <div class="hide-content"><pre><code class="js">// Promise/A+ 规范规定的三种状态const STATUS = { PENDING: &#39;pending&#39;, FULFILLED: &#39;fulfilled&#39;, REJECTED: &#39;rejected&#39;}​class MyPromise { // 构造函数接收一个执行回调 constructor(executor) {     this._status = STATUS.PENDING // Promise初始状态     this._value = undefined // then回调的值     this._resolveQueue = [] // resolve时触发的成功队列     this._rejectQueue = [] // reject时触发的失败队列    ​ // 使用箭头函数固定this（resolve函数在executor中触发，不然找不到this） const resolve = value =&gt; {     const run = () =&gt; {         // Promise/A+ 规范规定的Promise状态只能从pending触发，变成fulfilled         if (this._status === STATUS.PENDING) {             this._status = STATUS.FULFILLED // 更改状态             this._value = value // 储存当前值，用于then回调            ​             // 执行resolve回调             while (this._resolveQueue.length) {                 const callback = this._resolveQueue.shift()                 callback(value)             }         }     }     //把resolve执行回调的操作封装成一个函数,放进setTimeout里,以实现promise异步调用的特性（规范上是微任务，这里是宏任务）     setTimeout(run) }​ // 同 resolve const reject = value =&gt; {     const run = () =&gt; {         if (this._status === STATUS.PENDING) {         this._status = STATUS.REJECTED         this._value = value        ​         while (this._rejectQueue.length) {             const callback = this._rejectQueue.shift()             callback(value)         }     } }     setTimeout(run) }     // new Promise()时立即执行executor,并传入resolve和reject     executor(resolve, reject) }​ // then方法,接收一个成功的回调和一个失败的回调 function then(onFulfilled, onRejected) {  // 根据规范，如果then的参数不是function，则忽略它, 让值继续往下传递，链式调用继续往下执行  typeof onFulfilled !== &#39;function&#39; ? onFulfilled = value =&gt; value : null  typeof onRejected !== &#39;function&#39; ? onRejected = error =&gt; error : null  // then 返回一个新的promise  return new MyPromise((resolve, reject) =&gt; {    const resolveFn = value =&gt; {      try {        const x = onFulfilled(value)        // 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve        x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)      } catch (error) {        reject(error)      }    }  }}​  const rejectFn = error =&gt; {      try {        const x = onRejected(error)        x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)      } catch (error) {        reject(error)      }    }    switch (this._status) {      case STATUS.PENDING:        this._resolveQueue.push(resolveFn)        this._rejectQueue.push(rejectFn)        break;      case STATUS.FULFILLED:        resolveFn(this._value)        break;      case STATUS.REJECTED:        rejectFn(this._value)        break;    } }) } catch (rejectFn) {  return this.then(undefined, rejectFn)}// promise.finally方法finally(callback) {  return this.then(value =&gt; MyPromise.resolve(callback()).then(() =&gt; value), error =&gt; {    MyPromise.resolve(callback()).then(() =&gt; error)  })} // 静态resolve方法 static resolve(value) {      return value instanceof MyPromise ? value : new MyPromise(resolve =&gt; resolve(value))  } // 静态reject方法 static reject(error) {      return new MyPromise((resolve, reject) =&gt; reject(error))    } // 静态all方法 static all(promiseArr) {      let count = 0      let result = []      return new MyPromise((resolve, reject) =&gt;       {        if (!promiseArr.length) {          return resolve(result)        }        promiseArr.forEach((p, i) =&gt; {          MyPromise.resolve(p).then(value =&gt; {            count++            result[i] = value            if (count === promiseArr.length) {              resolve(result)            }          }, error =&gt; {            reject(error)          })        })      })    } // 静态race方法 static race(promiseArr) {      return new MyPromise((resolve, reject) =&gt; {        promiseArr.forEach(p =&gt; {          MyPromise.resolve(p).then(value =&gt; {            resolve(value)          }, error =&gt; {            reject(error)          })        })      })    }}</code></pre></div></div>]]></content>
      
      
      <categories>
          
          <category> Js手写题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js-hand-14</title>
      <link href="/11522/"/>
      <url>/11522/</url>
      
        <content type="html"><![CDATA[<h2 id="14-手动实现new"><a href="#14-手动实现new" class="headerlink" title="14.手动实现new"></a>14.手动实现new</h2><blockquote><p>new的过程文字描述：</p></blockquote><ol><li> 创建一个空对象 obj;</li><li> 将空对象的隐式原型（<strong>proto</strong>）指向构造函数的prototype。</li><li> 使用 call 改变 this 的指向</li><li> 如果无返回值或者返回一个非对象值，则将 obj 返回作为新对象；如果返回值是一个新对象的话那么直接直接返回该对象。</li></ol><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>查看答案</span></div>    <div class="hide-content"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.name=name</span><br><span class="line"> <span class="built_in">this</span>.age=age</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayHi=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;Hi！我是&#x27;</span>+<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1=<span class="keyword">new</span> Person(<span class="string">&#x27;张三&#x27;</span>,<span class="number">18</span>)</span><br><span class="line">​</span><br><span class="line"><span class="comment">////手动实现new</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="keyword">let</span> obj=&#123;&#125;</span><br><span class="line"> <span class="comment">//获取构造函数</span></span><br><span class="line"> <span class="keyword">let</span> fn=[].shift.call(<span class="built_in">arguments</span>)  <span class="comment">//将arguments对象提出来转化为数组，arguments并不是数组而是对象    ！！！这种方法删除了arguments数组的第一个元素，！！这里的空数组里面填不填元素都没关系，不影响arguments的结果      或者let arg = [].slice.call(arguments,1)</span></span><br><span class="line"> obj.__proto__=fn.prototype</span><br><span class="line"> <span class="keyword">let</span> res=fn.apply(obj,<span class="built_in">arguments</span>)    <span class="comment">//改变this指向，为实例添加方法和属性</span></span><br><span class="line"> <span class="comment">//确保返回的是一个对象(万一fn不是构造函数)</span></span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">typeof</span> res===<span class="string">&#x27;object&#x27;</span>?res:obj</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">let</span> p2=create(Person,<span class="string">&#x27;李四&#x27;</span>,<span class="number">19</span>)</span><br><span class="line">p2.sayHi()</span><br></pre></td></tr></table></figure><p>细节：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[].shift.call(<span class="built_in">arguments</span>)  也可写成：</span><br><span class="line"> <span class="keyword">let</span> arg=[...arguments]</span><br><span class="line"> <span class="keyword">let</span> fn=arg.shift()  <span class="comment">//使得arguments能调用数组方法,第一个参数为构造函数</span></span><br><span class="line"> obj.__proto__=fn.prototype</span><br><span class="line"> <span class="comment">//改变this指向，为实例添加方法和属性</span></span><br><span class="line"> <span class="keyword">let</span> res=fn.apply(obj,arg)</span><br></pre></td></tr></table></figure></div></div>]]></content>
      
      
      <categories>
          
          <category> Js手写题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js-hand-13</title>
      <link href="/61251/"/>
      <url>/61251/</url>
      
        <content type="html"><![CDATA[<h2 id="13-手写call-apply-bind"><a href="#13-手写call-apply-bind" class="headerlink" title="13. 手写call, apply, bind"></a>13. 手写call, apply, bind</h2><p><strong>手写call</strong></p><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>查看答案</span></div>    <div class="hide-content"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall=<span class="function"><span class="keyword">function</span>(<span class="params">context=<span class="built_in">window</span></span>)</span>&#123;  <span class="comment">// 函数的方法，所以写在Fuction原型对象上</span></span><br><span class="line"> <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">this</span> !==<span class="string">&quot;function&quot;</span>)&#123;   <span class="comment">// 这里if其实没必要，会自动抛出错误</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;不是函数&quot;</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">const</span> obj=context||<span class="built_in">window</span>   <span class="comment">//这里可用ES6方法，为参数添加默认值，js严格模式全局作用域this为undefined</span></span><br><span class="line"> obj.fn=<span class="built_in">this</span>      <span class="comment">//this为调用的上下文,this此处为函数，将这个函数作为obj的方法</span></span><br><span class="line"> <span class="keyword">const</span> arg=[...arguments].slice(<span class="number">1</span>)   <span class="comment">//第一个为obj所以删除,伪数组转为数组</span></span><br><span class="line"> res=obj.fn(...arg)</span><br><span class="line"> <span class="keyword">delete</span> obj.fn   <span class="comment">// 不删除会导致context属性越来越多</span></span><br><span class="line"> <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用法：f.call(obj,arg1)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(a+b)</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj=&#123;</span><br><span class="line"> <span class="attr">name</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">f.myCall(obj,<span class="number">1</span>,<span class="number">2</span>) <span class="comment">//否则this指向window</span></span><br><span class="line"></span><br><span class="line">obj.greet.call(&#123;<span class="attr">name</span>: <span class="string">&#x27;Spike&#x27;</span>&#125;) <span class="comment">//打出来的是 Spike</span></span><br></pre></td></tr></table></figure></div></div><p><strong>手写apply</strong>(arguments[this, [参数1，参数2…..] ])</p><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>查看答案</span></div>    <div class="hide-content"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply=<span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;  <span class="comment">// 箭头函数从不具有参数对象！！！！！这里不能写成箭头函数</span></span><br><span class="line"> <span class="keyword">let</span> obj=context||<span class="built_in">window</span></span><br><span class="line"> obj.fn=<span class="built_in">this</span></span><br><span class="line"> <span class="keyword">const</span> arg=<span class="built_in">arguments</span>[<span class="number">1</span>]||[]    <span class="comment">//若有参数，得到的是数组</span></span><br><span class="line"> <span class="keyword">let</span> res=obj.fn(...arg)</span><br><span class="line"> <span class="keyword">delete</span> obj.fn</span><br><span class="line"> <span class="keyword">return</span> res</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(a,b)</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj=&#123;</span><br><span class="line"> <span class="attr">name</span>:<span class="string">&#x27;张三&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">f.myApply(obj,[<span class="number">1</span>,<span class="number">2</span>])  <span class="comment">//arguments[1]</span></span><br></pre></td></tr></table></figure></div></div><p><strong>手写bind</strong></p><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>查看答案</span></div>    <div class="hide-content"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.value = <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params">name, age, school</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name) <span class="comment">// &#x27;An&#x27;</span></span><br><span class="line">  <span class="built_in">console</span>.log(age) <span class="comment">// 22</span></span><br><span class="line">  <span class="built_in">console</span>.log(school) <span class="comment">// &#x27;家里蹲大学&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = bar.bind(foo, <span class="string">&#x27;An&#x27;</span>) <span class="comment">//预置了部分参数&#x27;An&#x27;</span></span><br><span class="line">result(<span class="number">22</span>, <span class="string">&#x27;家里蹲大学&#x27;</span>) <span class="comment">//这个参数会和预置的参数合并到一起放入bar中</span></span><br><span class="line"><span class="comment">// 简单版本</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">context, ...outerArgs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fn = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...innerArgs</span>) </span>&#123;   <span class="comment">//返回了一个函数，...rest为实际调用时传入的参数</span></span><br><span class="line">  <span class="keyword">return</span> fn.apply(context,[...outerArgs, ...innerArgs]);  <span class="comment">//返回改变了this的函数，</span></span><br><span class="line">  <span class="comment">//参数合并</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div>]]></content>
      
      
      <categories>
          
          <category> Js手写题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js-hand-12</title>
      <link href="/12162/"/>
      <url>/12162/</url>
      
        <content type="html"><![CDATA[<h2 id="12-深拷贝实现："><a href="#12-深拷贝实现：" class="headerlink" title="12.深拷贝实现："></a>12.深拷贝实现：</h2><p><strong>方法一：</strong></p><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>查看答案</span></div>    <div class="hide-content"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(b))</span><br></pre></td></tr></table></figure></div></div><p><strong>方法二：</strong></p><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>查看答案</span></div>    <div class="hide-content"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现深拷贝  递归</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">newObj,oldObj</span>)</span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> oldObj)&#123;</span><br><span class="line">         <span class="keyword">let</span> item=oldObj[k]</span><br><span class="line">         <span class="comment">// 判断是数组、对象、简单类型？</span></span><br><span class="line">         <span class="keyword">if</span>(item <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line">             newObj[k]=[]</span><br><span class="line">             deepCopy(newObj[k],item)</span><br><span class="line">         &#125;<span class="keyword">else</span> <span class="keyword">if</span>(item <span class="keyword">instanceof</span> <span class="built_in">Object</span>)&#123;</span><br><span class="line">             newObj[k]=&#123;&#125;</span><br><span class="line">             deepCopy(newObj[k],item)</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;  <span class="comment">//简单数据类型，直接赋值</span></span><br><span class="line">             newObj[k]=item</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div>]]></content>
      
      
      <categories>
          
          <category> Js手写题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js-hand-11</title>
      <link href="/11970/"/>
      <url>/11970/</url>
      
        <content type="html"><![CDATA[<h2 id="11-浅拷贝的实现"><a href="#11-浅拷贝的实现" class="headerlink" title="11. 浅拷贝的实现"></a>11. 浅拷贝的实现</h2><blockquote><p>深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型的。<br><strong>浅拷贝和深拷贝的区别：</strong><br>浅拷贝：创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址，如果其中一个对象改变了引用类型的属性，就会影响到另一个对象。<br>深拷贝：将一个对象从内存中完整的复制一份出来,从堆内存中开辟一个新区域存放。这样更改拷贝值就不影响旧的对象</p></blockquote><ul><li>浅拷贝实现：<div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>查看答案</span></div>    <div class="hide-content"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowCopy</span>(<span class="params">target, origin</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">in</span> origin) target[item] = origin[item];</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他方法(内置api)：</p><ol><li> Object.assign<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=&#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="attr">c</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">&#x27;i am c&#x27;</span>)&#125;&#125;</span><br><span class="line"><span class="keyword">var</span> tar=&#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(tar,obj);</span><br></pre></td></tr></table></figure></li></ol><p>当然这个方法只适合于对象类型，如果是数组可以使用slice和concat方法</p><ol start="2"><li>Array.prototype.slice</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,[<span class="number">3</span>,<span class="number">4</span>]];</span><br><span class="line"><span class="keyword">var</span> newArr=arr.slice(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><ol start="3"><li> Array.prototype.concat</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,[<span class="number">3</span>,<span class="number">4</span>]];</span><br><span class="line"><span class="keyword">var</span> newArr=arr.concat();</span><br></pre></td></tr></table></figure><p>测试同上(assign用对象测试、slice concat用数组测试)，结合浅拷贝深拷贝的概念来理解效果更佳</p></div></div></li></ul>]]></content>
      
      
      <categories>
          
          <category> Js手写题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js-hand-10</title>
      <link href="/60931/"/>
      <url>/60931/</url>
      
        <content type="html"><![CDATA[<h2 id="10-函数柯里化"><a href="#10-函数柯里化" class="headerlink" title="10. 函数柯里化"></a>10. 函数柯里化</h2><blockquote><p>柯里化的定义：接收一部分参数，返回一个函数接收剩余参数，接收足够参数后，执行原函数。当柯里化函数接收到足够参数后，就会执行原函数，如何去确定何时达到足够的参数呢？<br>  有两种思路：</p></blockquote><ol><li> 通过函数的 length 属性，获取函数的形参个数，形参的个数就是所需的参数个数</li><li>在调用柯里化工具函数时，手动指定所需的参数个数<br>将这两点结合一下，实现一个简单 curry 函数：</li></ol><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>查看答案</span></div>    <div class="hide-content"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将函数柯里化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>fn    待柯里化的原函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>len   所需的参数个数，默认为原函数的形参个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn,len = fn.length</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> _curry.call(<span class="built_in">this</span>,fn,len)</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中转函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>fn    待柯里化的原函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>len   所需的参数个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>args  已接收的参数列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_curry</span>(<span class="params">fn,len,...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...params</span>) </span>&#123;</span><br><span class="line">         <span class="keyword">let</span> _args = [...args,...params];</span><br><span class="line">         <span class="keyword">if</span>(_args.length &gt;= len)&#123;</span><br><span class="line">             <span class="keyword">return</span> fn.apply(<span class="built_in">this</span>,_args);</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> _curry.call(<span class="built_in">this</span>,fn,len,..._args)</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 我们来验证一下：</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> _fn = curry(<span class="function"><span class="keyword">function</span>(<span class="params">a,b,c,d,e</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a,b,c,d,e)</span><br><span class="line">  &#125;);</span><br><span class="line">  ​</span><br><span class="line">  _fn(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);     <span class="comment">// print: 1,2,3,4,5</span></span><br><span class="line">  _fn(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);   <span class="comment">// print: 1,2,3,4,5</span></span><br><span class="line">  _fn(<span class="number">1</span>,<span class="number">2</span>)(<span class="number">3</span>,<span class="number">4</span>)(<span class="number">5</span>);   <span class="comment">// print: 1,2,3,4,5</span></span><br><span class="line">  _fn(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>); <span class="comment">// print: 1,2,3,4,5</span></span><br></pre></td></tr></table></figure></div></div>]]></content>
      
      
      <categories>
          
          <category> Js手写题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js-hand-9</title>
      <link href="/50265/"/>
      <url>/50265/</url>
      
        <content type="html"><![CDATA[<h2 id="9-数组扁平化"><a href="#9-数组扁平化" class="headerlink" title="9. 数组扁平化"></a>9. 数组扁平化</h2><p>数组扁平化就是把多维数组转化成一维数组</p><p><strong>1. es6提供的新方法 flat(depth)</strong></p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>]]; </span><br><span class="line">a.flat(); <span class="comment">// [1,2,3] </span></span><br><span class="line">a.flat(<span class="number">1</span>); <span class="comment">//[1,2,3]</span></span><br><span class="line"><span class="comment">// depth的值设置为Infinity。</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,[<span class="number">5</span>]]]]; </span><br><span class="line">a.flat(<span class="literal">Infinity</span>); <span class="comment">// [1,2,3,4,5]  a是4维数组</span></span><br></pre></td></tr></table></figure><p><strong>2. 利用cancat</strong></p><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>查看答案</span></div>    <div class="hide-content"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> res = [];</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, length = arr.length; i &lt; length; i++) &#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(arr[i])) &#123;</span><br><span class="line">     res = res.concat(flatten(arr[i])); <span class="comment">//concat 并不会改变原数组</span></span><br><span class="line">     <span class="comment">//res.push(...flatten(arr[i])); //或者用扩展运算符 </span></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         res.push(arr[i]);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>,[<span class="number">3</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]]]</span><br><span class="line">flatten(arr1); <span class="comment">//[1, 2, 3, 1, 2, 3, 4, 2, 3, 4]</span></span><br></pre></td></tr></table></figure></div></div><ol start="3"><li>指定deep的flat</li></ol><p>只需每次递归时将当前deep1，若大于0，则可以继续展开</p><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>查看答案</span></div>    <div class="hide-content"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">flat</span>(<span class="params">arr, deep</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = []</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(arr[i])&amp;&amp;deep) &#123;</span><br><span class="line">            res = res.concat(flat(arr[i],deep1))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(flat([<span class="number">12</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="number">3</span>,[<span class="number">2</span>,<span class="number">4</span>,[<span class="number">4</span>,[<span class="number">3</span>,<span class="number">4</span>],<span class="number">2</span>]]],<span class="number">1</span>));</span><br></pre></td></tr></table></figure></div></div>]]></content>
      
      
      <categories>
          
          <category> Js手写题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js-hand-8</title>
      <link href="/1176/"/>
      <url>/1176/</url>
      
        <content type="html"><![CDATA[<h2 id="8-手写数组的reduce方法"><a href="#8-手写数组的reduce方法" class="headerlink" title="8. 手写数组的reduce方法"></a>8. 手写数组的reduce方法</h2><blockquote><p>reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终为一个值，是ES5中新增的又一个数组逐项处理方法</p></blockquote><p><strong>参数：</strong></p><ul><li>callback（一个在数组中每一项上调用的函数，接受四个函数：）<ul><li>  previousValue（上一次调用回调函数时的返回值，或者初始值）</li><li>  currentValue（当前正在处理的数组元素）</li><li>  currentIndex（当前正在处理的数组元素下标）</li><li>  array（调用reduce()方法的数组）</li></ul></li><li>  initialValue（可选的初始值。作为第一次调用回调函数时传给previousValue的值）</li></ul><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>查看答案</span></div>    <div class="hide-content"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reduce</span>(<span class="params">arr, cb, initialValue</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = initValue == <span class="literal">undefined</span>? num = arr[<span class="number">0</span>]: initValue;</span><br><span class="line">    <span class="keyword">var</span> i = initValue == <span class="literal">undefined</span>? <span class="number">1</span>: <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i; i&lt; arr.length; i++)&#123;</span><br><span class="line">       num = cb(num,arr[i],i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">result, currentValue, index</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> result + currentValue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> b = reduce(arr, fn,<span class="number">10</span>) </span><br><span class="line"><span class="keyword">var</span> c = reduce(arr, fn)</span><br><span class="line"><span class="built_in">console</span>.log(b)   <span class="comment">// 24</span></span><br></pre></td></tr></table></figure></div></div>]]></content>
      
      
      <categories>
          
          <category> Js手写题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js-hand-7</title>
      <link href="/216/"/>
      <url>/216/</url>
      
        <content type="html"><![CDATA[<h2 id="7-利用reduce实现数组的map方法"><a href="#7-利用reduce实现数组的map方法" class="headerlink" title="7. 利用reduce实现数组的map方法"></a>7. 利用reduce实现数组的map方法</h2><p>利用数组内置的reduce方法实现map方法，考察对reduce原理的掌握</p><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>查看答案</span></div>    <div class="hide-content"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.myMap = <span class="function"><span class="keyword">function</span>(<span class="params">fn,thisValue</span>)</span>&#123;</span><br><span class="line">     <span class="keyword">var</span> res = [];</span><br><span class="line">     thisValue = thisValue||[];</span><br><span class="line">     <span class="built_in">this</span>.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">pre,cur,index,arr</span>)</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> res.push(fn.call(thisValue,cur,index,arr));</span><br><span class="line">     &#125;,[]);</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>];</span><br><span class="line">arr.myMap(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,arr</span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(item,index,arr);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div>]]></content>
      
      
      <categories>
          
          <category> Js手写题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js-hand-6</title>
      <link href="/49177/"/>
      <url>/49177/</url>
      
        <content type="html"><![CDATA[<h2 id="6-实现数组的map方法"><a href="#6-实现数组的map方法" class="headerlink" title="6. 实现数组的map方法"></a>6. 实现数组的map方法</h2><p>数组的<strong>map()</strong> 方法会返回一个新的数组，这个新数组中的每个元素对应原数组中的对应位置元素调用一次提供的函数后的返回值。</p><p><strong>用法：</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> b = array1.map(<span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b);   <span class="comment">// Array [2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure><p>实现前，我们先看一下map方法的参数有哪些  </p><p>map方法有两个参数，一个是操作数组元素的方法fn，一个是this指向(可选)，其中使用fn时可以获取三个参数，实现时记得不要漏掉，这样才算完整实现嘛</p><p><strong>原生实现：</strong></p><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>查看答案</span></div>    <div class="hide-content"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现</span></span><br><span class="line"> <span class="built_in">Array</span>.prototype.myMap = <span class="function"><span class="keyword">function</span>(<span class="params">fn, thisValue</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> res = []</span><br><span class="line">        thisValue = thisValue||[]</span><br><span class="line">        <span class="keyword">let</span> arr = <span class="built_in">this</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">            res.push(fn.call(thisValue, arr[i],i,arr))   <span class="comment">// 参数分别为this指向，当前数组项，当前索引，当前数组</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用</span></span><br><span class="line">    <span class="keyword">const</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">const</span> b = a.myMap(<span class="function">(<span class="params">a,index</span>)=&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a+<span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="built_in">console</span>.log(b)   <span class="comment">// 输出 [2, 3, 4]</span></span><br></pre></td></tr></table></figure></div></div>]]></content>
      
      
      <categories>
          
          <category> Js手写题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js-hand-5</title>
      <link href="/49497/"/>
      <url>/49497/</url>
      
        <content type="html"><![CDATA[<ol start="5"><li>手写instanceof<br>instanceof作用:</li></ol><p><strong>判断一个实例是否是其父类或者祖先类型的实例。</strong></p><p><strong>instanceof</strong> <strong>在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 prototype</strong>查找失败，返回 false</p><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>查看答案</span></div>    <div class="hide-content"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myInstanceof = <span class="function">(<span class="params">target,origin</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(target.__proto__===origin.prototype) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        target = target.__proto__</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">console</span>.log(myInstanceof(a,<span class="built_in">Array</span>));  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(myInstanceof(a,<span class="built_in">Object</span>));  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div></div>]]></content>
      
      
      <categories>
          
          <category> Js手写题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络常见面试题</title>
      <link href="/14068/"/>
      <url>/14068/</url>
      
        <content type="html"><![CDATA[<h2 id="Post-和-Get-的区别？"><a href="#Post-和-Get-的区别？" class="headerlink" title="Post 和 Get 的区别？"></a>Post 和 Get 的区别？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Post 和 Get 是 HTTP 请求的两种方法。</span><br><span class="line"></span><br><span class="line">（1）从应用场景上来说，GET 请求是一个幂等的请求，一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网</span><br><span class="line">页。而 Post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景。比如注册用户这一类的操作。</span><br><span class="line"></span><br><span class="line">（2）因为不同的应用场景，所以浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。</span><br><span class="line"></span><br><span class="line">（3）从发送的报文格式来说，Get 请求的报文中实体部分为空，Post 请求的报文中实体部分一般为向服务器发送的数据。</span><br><span class="line"></span><br><span class="line">（4）但是 Get 请求也可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 Post 请求来说，一个方面是不太安全，</span><br><span class="line">因为请求的 url 会被保留在历史记录中。并且浏览器由于对 url 有一个长度上的限制，所以会影响 get 请求发送数据时</span><br><span class="line">的长度。这个限制是浏览器规定的，并不是 RFC 规定的。还有就是 post 的参数传递支持更多的数据类型。</span><br></pre></td></tr></table></figure><h2 id="TLS-SSL-中什么一定要用三个随机数，来生成”会话密钥”？"><a href="#TLS-SSL-中什么一定要用三个随机数，来生成”会话密钥”？" class="headerlink" title="TLS/SSL 中什么一定要用三个随机数，来生成”会话密钥”？"></a>TLS/SSL 中什么一定要用三个随机数，来生成”会话密钥”？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">客户端和服务器都需要生成随机数，以此来保证每次生成的秘钥都不相同。使用三个随机数，是因为 SSL 的协议默认不信任每个主</span><br><span class="line">机都能产生完全随机的数，如果只使用一个伪随机的数来生成秘钥，就很容易被破解。通过使用三个随机数的方式，增加了自由度，</span><br><span class="line">一个伪随机可能被破解，但是三个伪随机就很接近于随机了，因此可以使用这种方法来保持生成秘钥的随机性和安全性。</span><br></pre></td></tr></table></figure><h2 id="SSL-连接断开后如何恢复？"><a href="#SSL-连接断开后如何恢复？" class="headerlink" title="SSL 连接断开后如何恢复？"></a>SSL 连接断开后如何恢复？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一共有两种方法来恢复断开的 SSL 连接，一种是使用 session ID，一种是 session ticket。</span><br><span class="line"></span><br><span class="line">使用 session ID 的方式，每一次的会话都有一个编号，当对话中断后，下一次重新连接时，只要客户端给出这个编号，服务器</span><br><span class="line">如果有这个编号的记录，那么双方就可以继续使用以前的秘钥，而不用重新生成一把。目前所有的浏览器都支持这一种方法。但是</span><br><span class="line">这种方法有一个缺点是，session ID 只能够存在一台服务器上，如果我们的请求通过负载平衡被转移到了其他的服务器上，那</span><br><span class="line">么就无法恢复对话。</span><br><span class="line"></span><br><span class="line">另一种方式是 session ticket 的方式，session ticket 是服务器在上一次对话中发送给客户的，这个 ticket 是加密的</span><br><span class="line">，只有服务器能够解密，里面包含了本次会话的信息，比如对话秘钥和加密方法等。这样不管我们的请求是否转移到其他的服务器</span><br><span class="line">上，当服务器将 ticket 解密以后，就能够获取上次对话的信息，就不用重新生成对话秘钥了。</span><br></pre></td></tr></table></figure><h2 id="RSA-算法的安全性保障？"><a href="#RSA-算法的安全性保障？" class="headerlink" title="RSA 算法的安全性保障？"></a>RSA 算法的安全性保障？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对极大整数做因数分解的难度决定了 RSA 算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA 算法愈可靠。现在102</span><br><span class="line">4位的 RSA 密钥基本安全，2048位的密钥极其安全。</span><br></pre></td></tr></table></figure><h2 id="DNS-为什么使用-UDP-协议作为传输层协议？"><a href="#DNS-为什么使用-UDP-协议作为传输层协议？" class="headerlink" title="DNS 为什么使用 UDP 协议作为传输层协议？"></a>DNS 为什么使用 UDP 协议作为传输层协议？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DNS 使用 UDP 协议作为传输层协议的主要原因是为了避免使用 TCP 协议时造成的连接时延。因为为了得到一个域名的 IP 地</span><br><span class="line">址，往往会向多个域名服务器查询，如果使用 TCP 协议，那么每次请求都会存在连接时延，这样使 DNS 服务变得很慢，因为大</span><br><span class="line">多数的地址查询请求，都是浏览器请求页面时发出的，这样会造成网页的等待时间过长。</span><br><span class="line"></span><br><span class="line">使用 UDP 协议作为 DNS 协议会有一个问题，由于历史原因，物理链路的最小MTU = 576，所以为了限制报文长度不超过576，</span><br><span class="line">UDP 的报文段的长度被限制在 512 个字节以内，这样一旦 DNS 的查询或者应答报文，超过了 512 字节，那么基于 UDP 的</span><br><span class="line">DNS 协议就会被截断为 512 字节，那么有可能用户得到的 DNS 应答就是不完整的。这里 DNS 报文的长度一旦超过限制，并不</span><br><span class="line">会像 TCP 协议那样被拆分成多个报文段传输，因为 UDP 协议不会维护连接状态，所以我们没有办法确定那几个报文段属于同一</span><br><span class="line">个数据，UDP 只会将多余的数据给截取掉。为了解决这个问题，我们可以使用 TCP 协议去请求报文。</span><br><span class="line"></span><br><span class="line">DNS 还存在的一个问题是安全问题，就是我们没有办法确定我们得到的应答，一定是一个安全的应答，因为应答可以被他人伪造，</span><br><span class="line">所以现在有了 DNS over HTTPS 来解决这个问题。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/310145373">《为什么 DNS 使用 UDP 而不是 TCP？》</a></p><h2 id="当你在浏览器中输入-Google-com-并且按下回车之后发生了什么？"><a href="#当你在浏览器中输入-Google-com-并且按下回车之后发生了什么？" class="headerlink" title="当你在浏览器中输入 Google.com 并且按下回车之后发生了什么？"></a>当你在浏览器中输入 Google.com 并且按下回车之后发生了什么？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，</span><br><span class="line">将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字</span><br><span class="line">符，则对非法字符进行转义后再进行下一过程。</span><br><span class="line"></span><br><span class="line">（2）浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新</span><br><span class="line">的请求。</span><br><span class="line"></span><br><span class="line">（3）下一步我们首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果</span><br><span class="line">有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域</span><br><span class="line">名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地</span><br><span class="line">址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用</span><br><span class="line">户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。</span><br><span class="line"></span><br><span class="line">（4）当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源</span><br><span class="line">端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给</span><br><span class="line">数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，我们本机的 MAC 地址作为源 MAC 地址，目的 MAC 地</span><br><span class="line">址需要分情况处理，通过将 IP 地址与我们本机的子网掩码相与，我们可以判断我们是否与请求主机在同一个子网里，如果</span><br><span class="line">在同一个子网里，我们可以使用 APR 协议获取到目的主机的 MAC 地址，如果我们不在一个子网里，那么我们的请求应该</span><br><span class="line">转发给我们的网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应</span><br><span class="line">该为网关的地址。</span><br><span class="line"></span><br><span class="line">（5）下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接</span><br><span class="line">收到请求后向服务器端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的</span><br><span class="line">确认应答后，进入连接建立的状态，同时向服务器也发送一个 ACK 确认报文段，服务器端接收到确认后，也进入连接建立</span><br><span class="line">状态，此时双方的连接就建立起来了。</span><br><span class="line"></span><br><span class="line">（6）如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版</span><br><span class="line">本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证</span><br><span class="line">书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后</span><br><span class="line">发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解</span><br><span class="line">密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加</span><br><span class="line">密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。</span><br><span class="line"></span><br><span class="line">（7）当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行</span><br><span class="line">解析，开始页面的渲染过程。</span><br><span class="line"></span><br><span class="line">（8）浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端</span><br><span class="line">是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建</span><br><span class="line">立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页</span><br><span class="line">面进行绘制。这个时候整个页面就显示出来了。</span><br><span class="line"></span><br><span class="line">（9）最后一步是 TCP 断开连接的四次挥手过程。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://blog.jobbole.com/84870/">《当你在浏览器中输入 Google.com 并且按下回车之后发生了什么？》</a></p><h2 id="谈谈-CDN-服务？"><a href="#谈谈-CDN-服务？" class="headerlink" title="谈谈 CDN 服务？"></a>谈谈 CDN 服务？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CDN 是一个内容分发网络，通过对源网站资源的缓存，利用本身多台位于不同地域、不同运营商的服务器，向用户提供资就近访问的</span><br><span class="line">功能。也就是说，用户的请求并不是直接发送给源网站，而是发送给 CDN 服务器，由 CND 服务器将请求定位到最近的含有该资源</span><br><span class="line">的服务器上去请求。这样有利于提高网站的访问速度，同时通过这种方式也减轻了源服务器的访问压力。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/36514327?rf=37353035">《CDN 是什么？使用 CDN 有什么优势？》</a></p><h2 id="什么是正向代理和反向代理？"><a href="#什么是正向代理和反向代理？" class="headerlink" title="什么是正向代理和反向代理？"></a>什么是正向代理和反向代理？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我们常说的代理也就是指正向代理，正向代理的过程，它隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的</span><br><span class="line">服务都被代理服务器代替来请求。</span><br><span class="line"></span><br><span class="line">反向代理隐藏了真实的服务端，当我们请求一个网站的时候，背后可能有成千上万台服务器为我们服务，但具体是哪一台，我们不知</span><br><span class="line">道，也不需要知道，我们只需要知道反向代理服务器是谁就好了，反向代理服务器会帮我们把请求转发到真实的服务器那里去。反向</span><br><span class="line">代理器一般用来实现负载平衡。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://mp.weixin.qq.com/s/ikrI3rmSYs83wdSWqq2QIg">《正向代理与反向代理有什么区别》</a><br><a href="https://segmentfault.com/q/1010000017502539/a-1020000017532348">《webpack 配置 proxy 反向代理的原理是什么？》</a></p><h2 id="负载平衡的两种实现方式？"><a href="#负载平衡的两种实现方式？" class="headerlink" title="负载平衡的两种实现方式？"></a>负载平衡的两种实现方式？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一种是使用反向代理的方式，用户的请求都发送到反向代理服务上，然后由反向代理服务器来转发请求到真实的服务器上，以此来实</span><br><span class="line">现集群的负载平衡。</span><br><span class="line"></span><br><span class="line">另一种是 DNS 的方式，DNS 可以用于在冗余的服务器上实现负载平衡。因为现在一般的大型网站使用多台服务器提供服务，因此一</span><br><span class="line">个域名可能会对应多个服务器地址。当用户向网站域名请求的时候，DNS 服务器返回这个域名所对应的服务器 IP 地址的集合，但在</span><br><span class="line">每个回答中，会循环这些 IP 地址的顺序，用户一般会选择排在前面的地址发送请求。以此将用户的请求均衡的分配到各个不同的服</span><br><span class="line">务器上，这样来实现负载均衡。这种方式有一个缺点就是，由于 DNS 服务器中存在缓存，所以有可能一个服务器出现故障后，域名解</span><br><span class="line">析仍然返回的是那个 IP 地址，就会造成访问的问题。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://mp.weixin.qq.com/s?__biz=MzA5Njc2OTg4NQ==&mid=2247483870&idx=1&sn=bab36544ec62c394c104df699cf85154&chksm=90aa43eca7ddcafa01634cefee12fd8a332250d3f49d8b6647f536c215ac297e4b6a53af8253#rd">《负载均衡的原理》</a></p><h2 id="http-请求方法-options-方法有什么用？"><a href="#http-请求方法-options-方法有什么用？" class="headerlink" title="http 请求方法 options 方法有什么用？"></a>http 请求方法 options 方法有什么用？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OPTIONS 请求与 HEAD 类似，一般也是用于客户端查看服务器的性能。这个方法会请求服务器返回该资源所支持的所有 HTTP 请</span><br><span class="line">求方法，该方法会用&#x27;*&#x27;来代替资源名称，向服务器发送 OPTIONS 请求，可以测试服务器功能是否正常。JS 的 XMLHttpRequest</span><br><span class="line">对象进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。</span><br></pre></td></tr></table></figure><p>相关资料可以参考：<br><a href="https://itbilu.com/other/relate/EkwKysXIl.html">《HTTP 请求方法》</a></p><h2 id="http1-1-和-http1-0-之间有哪些区别？"><a href="#http1-1-和-http1-0-之间有哪些区别？" class="headerlink" title="http1.1 和 http1.0 之间有哪些区别？"></a>http1.1 和 http1.0 之间有哪些区别？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http1.1 相对于 http1.0 有这样几个区别：</span><br><span class="line">（1）连接方面的区别，http1.1 默认使用持久连接，而 http1.0 默认使用非持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。</span><br><span class="line">（2）资源请求方面的区别，在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</span><br><span class="line"></span><br><span class="line">（3）缓存方面的区别，在 http1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。</span><br><span class="line"></span><br><span class="line">（4）http1.1 中还新增了 host 字段，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，就可以将请求发往同一台服务器上的不同网站。</span><br><span class="line"></span><br><span class="line">（5）http1.1 相对于 http1.0 还新增了很多方法，如 PUT、HEAD、OPTIONS 等。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/entry/5981c5df518825359a2b9476">《HTTP1.0、HTTP1.1 和 HTTP2.0 的区别》</a><br><a href="http://www.ruanyifeng.com/blog/2016/08/http.html">《HTTP 协议入门》</a><br><a href="https://blog.csdn.net/netdxy/article/details/51195560">《网络—一篇文章详解请求头 Host 的概念》</a></p><h2 id="网站域名加-www-与不加-www-的区别？"><a href="#网站域名加-www-与不加-www-的区别？" class="headerlink" title="网站域名加 www 与不加 www 的区别？"></a>网站域名加 www 与不加 www 的区别？</h2><p>详细资料可以参考：<br><a href="https://www.f9seo.com/post-816.html">《为什么域名前要加 www 前缀 www 是什么意思？》</a><br><a href="https://www.zhihu.com/question/20414602">《为什么越来越多的网站域名不加「www」前缀？》</a><br><a href="https://blog.csdn.net/andybruse/article/details/7982278">《域名有 www 与没有 www 有什么区别？》</a></p><h2 id="即时通讯的实现，短轮询、长轮询、SSE-和-WebSocket-间的区别？"><a href="#即时通讯的实现，短轮询、长轮询、SSE-和-WebSocket-间的区别？" class="headerlink" title="即时通讯的实现，短轮询、长轮询、SSE 和 WebSocket 间的区别？"></a>即时通讯的实现，短轮询、长轮询、SSE 和 WebSocket 间的区别？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">短轮询和长轮询的目的都是用于实现客户端和服务器端的一个即时通讯。</span><br><span class="line"></span><br><span class="line">短轮询的基本思路就是浏览器每隔一段时间向浏览器发送 http 请求，服务器端在收到请求后，不论是否有数据更新，都直接进行</span><br><span class="line">响应。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客</span><br><span class="line">户端能够模拟实时地收到服务器端的数据的变化。这种方式的优点是比较简单，易于理解。缺点是这种方式由于需要不断的建立 ht</span><br><span class="line">tp 连接，严重浪费了服务器端和客户端的资源。当用户增加时，服务器端的压力就会变大，这是很不合理的。</span><br><span class="line"></span><br><span class="line">长轮询的基本思路是，首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将</span><br><span class="line">这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制才返回。</span><br><span class="line">客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。长轮询和短轮询比起来，它的</span><br><span class="line">优点是明显减少了很多不必要的 http 请求次数，相比之下节约了资源。长轮询的缺点在于，连接挂起也会导致资源的浪费。</span><br><span class="line"></span><br><span class="line">SSE 的基本思想是，服务器使用流信息向服务器推送信息。严格地说，http 协议无法做到服务器主动推送信息。但是，有一种变通</span><br><span class="line">方法，就是服务器向客户端声明，接下来要发送的是流信息。也就是说，发送的不是一次性的数据包，而是一个数据流，会连续不断</span><br><span class="line">地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流，视频播放就是这样的例子。SSE 就是利用这种机</span><br><span class="line">制，使用流信息向浏览器推送信息。它基于 http 协议，目前除了 IE/Edge，其他浏览器都支持。它相对于前面两种方式来说，不</span><br><span class="line">需要建立过多的 http 请求，相比之下节约了资源。</span><br><span class="line"></span><br><span class="line">上面三种方式本质上都是基于 http 协议的，我们还可以使用 WebSocket 协议来实现。WebSocket 是 Html5 定义的一个新协</span><br><span class="line">议，与传统的 http 协议不同，该协议允许由服务器主动的向客户端推送信息。使用 WebSocket 协议的缺点是在服务器端的配置</span><br><span class="line">比较复杂。WebSocket 是一个全双工的协议，也就是通信双方是平等的，可以相互发送消息，而 SSE 的方式是单向通信的，只能</span><br><span class="line">由服务器端向客户端推送信息，如果客户端需要发送信息就是属于下一个 http 请求了。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://cloud.tencent.com/developer/article/1076547">《轮询、长轮询、长连接、websocket》</a><br><a href="http://www.ruanyifeng.com/blog/2017/05/server-sent_events.html">《Server-Sent Events 教程》</a><br><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html">《WebSocket 教程》</a></p><h2 id="怎么实现多个网站之间共享登录状态"><a href="#怎么实现多个网站之间共享登录状态" class="headerlink" title="怎么实现多个网站之间共享登录状态"></a>怎么实现多个网站之间共享登录状态</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在多个网站之间共享登录状态指的就是单点登录。多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。</span><br><span class="line"></span><br><span class="line">我认为单点登录可以这样来实现，首先将用户信息的验证中心独立出来，作为一个单独的认证中心，该认证中心的作用是判断客户端发</span><br><span class="line">送的账号密码的正确性，然后向客户端返回对应的用户信息，并且返回一个由服务器端秘钥加密的登录信息的 token 给客户端，该</span><br><span class="line">token 具有一定的有效时限。当一个应用系统跳转到另一个应用系统时，通过 url 参数的方式来传递 token，然后转移到的应用站</span><br><span class="line">点发送给认证中心，认证中心对 token 进行解密后验证，如果用户信息没有失效，则向客户端返回对应的用户信息，如果失效了则将</span><br><span class="line">页面重定向会单点登录页面。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/35906139">《HTTP 是个无状态协议，怎么保持登录状态？》</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 计算机网络常见面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络知识点</title>
      <link href="/29428/"/>
      <url>/29428/</url>
      
        <content type="html"><![CDATA[<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>应用层协议定义了应用进程间的交互和通信规则，不同主机的应用进程间如何相互传递报文，比如传递的报文的类型、格式、<br>有哪些字段等等。</p><h3 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h3><h4 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h4><p>HTTP 是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，默认使用 80 端口。它使用 TCP 作为传<br>输层协议，保证了数据传输的可靠性。</p><p>HTTP 是一个无状态的协议，HTTP 服务器不会保存关于客户的任何信息。</p><p>HTTP 有两种连接模式，一种是持续连接，一种非持续连接。非持续连接指的是服务器必须为每一个请求的对象建立和维护<br>一个全新的连接。持续连接下，TCP 连接默认不关闭，可以被多个请求复用。采用持续连接的好处是可以避免每次建立 TCP<br>连接三次握手时所花费的时间。在 HTTP1.0 以前使用的非持续的连接，但是可以在请求时，加上 Connection: keep-a<br>live 来要求服务器不要关闭 TCP 连接。HTTP1.1 以后默认采用的是持续的连接。目前对于同一个域，大多数浏览器支持<br>同时建立 6 个持久连接。</p><h4 id="HTTP-请求报文"><a href="#HTTP-请求报文" class="headerlink" title="HTTP 请求报文"></a>HTTP 请求报文</h4><p>HTTP 报文有两种，一种是请求报文，一种是响应报文。</p><p>HTTP 请求报文的格式如下：</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>*/*</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>HTTP 请求报文的第一行叫做请求行，后面的行叫做首部行，首部行后还可以跟一个实体主体。请求首部之后有一个空行，这<br>个空行不能省略，它用来划分首部与实体。</p><p>请求行包含三个字段：方法字段、URL 字段和 HTTP 版本字段。</p><p>方法字段可以取几种不同的值，一般有 GET、POST、HEAD、PUT 和 DELETE。一般 GET 方法只被用于向服务器获取数据。<br>POST 方法用于将实体提交到指定的资源，通常会造成服务器资源的修改。HEAD 方法与 GET 方法类似，但是在返回的响应<br>中，不包含请求对象。PUT 方法用于上传文件到服务器，DELETE 方法用于删除服务器上的对象。虽然请求的方法很多，但<br>更多表达的是一种语义上的区别，并不是说 POST 能做的事情，GET 就不能做了，主要看我们如何选择。更多的方法可以参<br>看<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods">文档</a>。</p><h4 id="HTTP-响应报文"><a href="#HTTP-响应报文" class="headerlink" title="HTTP 响应报文"></a>HTTP 响应报文</h4><p>HTTP 报文有两种，一种是请求报文，一种是响应报文。</p><p>HTTP 响应报文的格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.0 200 OK</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Length: 137582</span><br><span class="line">Expires: Thu, 05 Dec 1997 16:00:00 GMT</span><br><span class="line">Last-Modified: Wed, 5 August 1996 15:55:28 GMT</span><br><span class="line">Server: Apache 0.84</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;Hello World&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>HTTP 响应报文的第一行叫做状态行，后面的行是首部行，最后是实体主体。</p><p>状态行包含了三个字段：协议版本字段、状态码和相应的状态信息。</p><p>实体部分是报文的主要部分，它包含了所请求的对象。</p><p>常见的状态有</p><p>200-请求成功、202-服务器端已经收到请求消息，但是尚未进行处理<br>301-永久移动、302-临时移动、304-所请求的资源未修改、<br>400-客户端请求的语法错误、404-请求的资源不存在<br>500-服务器内部错误。</p><p>一般 1XX 代表服务器接收到请求、2XX 代表成功、3XX 代表重定向、4XX 代表客户端错误、5XX 代表服务器端错误。</p><p>更多关于状态码的可以查看：</p><p><a href="http://www.runoob.com/http/http-status-codes.html">《HTTP 状态码》</a></p><h4 id="首部行"><a href="#首部行" class="headerlink" title="首部行"></a>首部行</h4><p>首部可以分为四种首部，请求首部、响应首部、通用首部和实体首部。通用首部和实体首部在请求报文和响应报文中都可以设<br>置，区别在于请求首部和响应首部。</p><p>常见的请求首部有 Accept 可接收媒体资源的类型、Accept-Charset 可接收的字符集、Host 请求的主机名。</p><p>常见的响应首部有 ETag 资源的匹配信息，Location 客户端重定向的 URI。</p><p>常见的通用首部有 Cache-Control 控制缓存策略、Connection 管理持久连接。</p><p>常见的实体首部有 Content-Length 实体主体的大小、Expires 实体主体的过期时间、Last-Modified 资源的最后修<br>改时间。</p><p>更多关于首部的资料可以查看：</p><p><a href="https://www.cnblogs.com/jycboy/p/http_head.html">《HTTP 首部字段详细介绍》</a></p><p><a href="https://blog.csdn.net/qq_34289537/article/details/52971516">《图解 HTTP》</a></p><h4 id="HTTP-1-1-协议缺点"><a href="#HTTP-1-1-协议缺点" class="headerlink" title="HTTP/1.1 协议缺点"></a>HTTP/1.1 协议缺点</h4><p>HTTP/1.1 默认使用了持久连接，多个请求可以复用同一个 TCP 连接，但是在同一个 TCP 连接里面，数据请求的通信次序<br>是固定的。服务器只有处理完一个请求的响应后，才会进行下一个请求的处理，如果前面请求的响应特别慢的话，就会造成许<br>多请求排队等待的情况，这种情况被称为“队头堵塞”。队头阻塞会导致持久连接在达到最大数量时，剩余的资源需要等待其他<br>资源请求完成后才能发起请求。</p><p>为了避免这个问题，一个是减少请求数，一个是同时打开多个持久连接。这就是我们对网站优化时，使用雪碧图、合并脚本的<br>原因。</p><h3 id="HTTP-2-协议"><a href="#HTTP-2-协议" class="headerlink" title="HTTP/2 协议"></a>HTTP/2 协议</h3><p>2009 年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。这个协议在 Chrome 浏览器上证明<br>可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。2015 年，HTTP/2 发布。</p><p>HTTP/2 主要有以下新的特性：</p><h4 id="二进制协议"><a href="#二进制协议" class="headerlink" title="二进制协议"></a>二进制协议</h4><p>HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是<br>二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”，可以分为头信息帧和数据帧。<br>帧的概念是它实现多路复用的基础。</p><h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4><p>HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回<br>应，而且不用按照顺序一一发送，这样就避免了”队头堵塞”的问题。</p><h4 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h4><p>HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的<br>请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每<br>个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流 ID ，用来区分它属于哪个数据流。</p><h4 id="头信息压缩"><a href="#头信息压缩" class="headerlink" title="头信息压缩"></a>头信息压缩</h4><p>HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是<br>重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。</p><p>HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，<br>客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引<br>号，这样就能提高速度了。</p><h4 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h4><p>HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送，提前给客户端推送必要的资源<br>，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，和 WebSocket 以及使用<br>SSE 等方式向客户端发送即时数据的推送是不同的。</p><p>详细的资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2016/08/http.html">《HTTP 协议入门》</a><br><a href="http://www.ruanyifeng.com/blog/2018/03/http2_server_push.html">《HTTP/2 服务器推送（Server Push）教程》</a></p><h4 id="HTTP-2-协议缺点"><a href="#HTTP-2-协议缺点" class="headerlink" title="HTTP/2 协议缺点"></a>HTTP/2 协议缺点</h4><p>因为 HTTP/2 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。由于多个数据流使用同一个 TCP 连接，遵<br>守同一个流量状态控制和拥塞控制。只要一个数据流遭遇到拥塞，剩下的数据流就没法发出去，这样就导致了后面的所有数据都<br>会被阻塞。HTTP/2 出现的这个问题是由于其使用 TCP 协议的问题，与它本身的实现其实并没有多大关系。</p><h4 id="HTTP-3-协议"><a href="#HTTP-3-协议" class="headerlink" title="HTTP/3 协议"></a>HTTP/3 协议</h4><p>由于 TCP 本身存在的一些限制，Google 就开发了一个基于 UDP 协议的 QUIC 协议，并且使用在了 HTTP/3 上。 QUIC<br>协议在 UDP 协议上实现了多路复用、有序交付、重传等等功能</p><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/302412059">《如何看待 HTTP/3 ？》</a></p><h3 id="HTTPS-协议"><a href="#HTTPS-协议" class="headerlink" title="HTTPS 协议"></a>HTTPS 协议</h3><h4 id="HTTP-存在的问题"><a href="#HTTP-存在的问题" class="headerlink" title="HTTP 存在的问题"></a>HTTP 存在的问题</h4><ol><li><p>HTTP 报文使用明文方式发送，可能被第三方窃听。</p></li><li><p>HTTP 报文可能被第三方截取后修改通信内容，接收方没有办法发现报文内容的修改。</p></li><li><p>HTTP 还存在认证的问题，第三方可以冒充他人参与通信。</p></li></ol><h4 id="HTTPS-简介"><a href="#HTTPS-简介" class="headerlink" title="HTTPS 简介"></a>HTTPS 简介</h4><p>HTTPS 指的是超文本传输安全协议，HTTPS 是基于 HTTP 协议的，不过它会使用 TLS/SSL 来对数据加密。使用 TLS/<br>SSL 协议，所有的信息都是加密的，第三方没有办法窃听。并且它提供了一种校验机制，信息一旦被篡改，通信的双方会立<br>刻发现。它还配备了身份证书，防止身份被冒充的情况出现。</p><h4 id="TLS-握手过程"><a href="#TLS-握手过程" class="headerlink" title="TLS 握手过程"></a>TLS 握手过程</h4><ol><li><p>第一步，客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。</p></li><li><p>第二步，服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。</p></li><li><p>第三步，客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服<br>务器。并且还会提供一个前面所有内容的 hash 的值，用来供服务器检验。</p></li><li><p>第四步，服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的 hash 值来供客户端检验。</p></li><li><p>第五步，客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥<br>来加密信息。</p></li></ol><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>TLS 的握手过程主要用到了三个方法来保证传输的安全。</p><p>首先是对称加密的方法，对称加密的方法是，双方使用同一个秘钥对数据进行加密和解密。但是对称加密的存在一个问题，就<br>是如何保证秘钥传输的安全性，因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。<br>这就要用到非对称加密的方法。</p><p>非对称加密的方法是，我们拥有两个秘钥，一个是公钥，一个是私钥。公钥是公开的，私钥是保密的。用私钥加密的数据，只<br>有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密。我们可以将公钥公布出去，任何想和我们通信的客户，<br>都可以使用我们提供的公钥对数据进行加密，这样我们就可以使用私钥进行解密，这样就能保证数据的安全了。但是非对称加<br>密有一个缺点就是加密的过程很慢，因此如果每次通信都使用非对称加密的方式的话，反而会造成等待时间过长的问题。</p><p>因此我们可以使用对称加密和非对称加密结合的方式，因为对称加密的方式的缺点是无法保证秘钥的安全传输，因此我们可以<br>非对称加密的方式来对对称加密的秘钥进行传输，然后以后的通信使用对称加密的方式来加密，这样就解决了两个方法各自存<br>在的问题。</p><p>但是现在的方法也不一定是安全的，因为我们没有办法确定我们得到的公钥就一定是安全的公钥。可能存在一个中间人，截取<br>了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥<br>解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而我们自己还不知道。</p><p>为了解决这样的问题，我们可以使用数字证书的方式，首先我们使用一种 Hash 算法来对我们的公钥和其他信息进行加密生成<br>一个信息摘要，然后让有公信力的认证中心（简称 CA ）用它的私钥对消息摘要加密，形成签名。最后将原始的信息和签名合<br>在一起，称为数字证书。当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证<br>处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和我们生成的摘要进行对比，就能发现我们得到的信息是否被更改<br>了。这个方法最要的是认证中心的可靠性，一般浏览器里会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有<br>这样我们才能保证数据的安全。</p><p>详细资料可以参考：<br><a href="https://mp.weixin.qq.com/s/StqqafHePlBkWAPQZg3NrA">《一个故事讲完 https》</a><br><a href="http://ruanyifeng.com/blog/2014/02/ssl_tls.html">《SSL/TLS 协议运行机制的概述》</a><br><a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html">《图解 SSL/TLS 协议》</a><br><a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">《RSA 算法原理（一）》</a><br><a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html">《RSA 算法原理（二）》</a><br><a href="https://juejin.im/post/5ad6ad575188255c272273c4">《分分钟让你理解 HTTPS》</a></p><h3 id="DNS-协议"><a href="#DNS-协议" class="headerlink" title="DNS 协议"></a>DNS 协议</h3><h4 id="概况-1"><a href="#概况-1" class="headerlink" title="概况"></a>概况</h4><p>DNS 协议提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。它是一个由分层的 DNS 服务器组成的分<br>布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。DNS 协议运行在 UDP 协议之上，使用 53 号<br>端口。</p><h4 id="域名的层级结构"><a href="#域名的层级结构" class="headerlink" title="域名的层级结构"></a>域名的层级结构</h4><p>域名的层级结构可以如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">主机名.次级域名.顶级域名.根域名</span><br><span class="line"></span><br><span class="line"># 即</span><br><span class="line"></span><br><span class="line">host.sld.tld.root</span><br></pre></td></tr></table></figure><p>根据域名的层级结构，管理不同层级域名的服务器，可以分为根域名服务器、顶级域名服务器和权威域名服务器。</p><h4 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h4><p>DNS 的查询过程一般为，我们首先将 DNS 请求发送到本地 DNS 服务器，由本地 DNS 服务器来代为请求。</p><ol><li>从”根域名服务器”查到”顶级域名服务器”的 NS 记录和 A 记录（ IP 地址）。</li><li>从”顶级域名服务器”查到”次级域名服务器”的 NS 记录和 A 记录（ IP 地址）。</li><li>从”次级域名服务器”查出”主机名”的 IP 地址。</li></ol><p>比如我们如果想要查询 <a href="http://www.baidu.com/">www.baidu.com</a> 的 IP 地址，我们首先会将请求发送到本地的 DNS 服务器中，本地 DNS 服务<br>器会判断是否存在该域名的缓存，如果不存在，则向根域名服务器发送一个请求，根域名服务器返回负责 .com 的顶级域名<br>服务器的 IP 地址的列表。然后本地 DNS 服务器再向其中一个负责 .com 的顶级域名服务器发送一个请求，负责 .com<br>的顶级域名服务器返回负责 .baidu 的权威域名服务器的 IP 地址列表。然后本地 DNS 服务器再向其中一个权威域名服<br>务器发送一个请求，最后权威域名服务器返回一个对应的主机名的 IP 地址列表。</p><h4 id="DNS-记录和报文"><a href="#DNS-记录和报文" class="headerlink" title="DNS 记录和报文"></a>DNS 记录和报文</h4><p>DNS 服务器中以资源记录的形式存储信息，每一个 DNS 响应报文一般包含多条资源记录。一条资源记录的具体的格式为</p><p>（Name，Value，Type，TTL）</p><p>其中 TTL 是资源记录的生存时间，它定义了资源记录能够被其他的 DNS 服务器缓存多长时间。</p><p>常用的一共有四种 Type 的值，分别是 A、NS、CNAME 和 MX ，不同 Type 的值，对应资源记录代表的意义不同。</p><ol><li><p>如果 Type = A，则 Name 是主机名，Value 是主机名对应的 IP 地址。因此一条记录为 A 的资源记录，提供了标<br>准的主机名到 IP 地址的映射。</p></li><li><p>如果 Type = NS，则 Name 是个域名，Value 是负责该域名的 DNS 服务器的主机名。这个记录主要用于 DNS 链式<br>查询时，返回下一级需要查询的 DNS 服务器的信息。</p></li><li><p>如果 Type = CNAME，则 Name 为别名，Value 为该主机的规范主机名。该条记录用于向查询的主机返回一个主机名<br>对应的规范主机名，从而告诉查询主机去查询这个主机名的 IP 地址。主机别名主要是为了通过给一些复杂的主机名提供<br>一个便于记忆的简单的别名。</p></li><li><p>如果 Type = MX，则 Name 为一个邮件服务器的别名，Value 为邮件服务器的规范主机名。它的作用和 CNAME 是一<br>样的，都是为了解决规范主机名不利于记忆的缺点。</p></li></ol><h4 id="递归查询和迭代查询"><a href="#递归查询和迭代查询" class="headerlink" title="递归查询和迭代查询"></a>递归查询和迭代查询</h4><p>递归查询指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归<br>查询，用户只需要发出一次查询请求。</p><p>迭代查询指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出<br>多次的查询请求。</p><p>一般我们向本地 DNS 服务器发送请求的方式就是递归查询，因为我们只需要发出一次请求，然后本地 DNS 服务器返回给我<br>们最终的请求结果。而本地 DNS 服务器向其他域名服务器请求的过程是迭代查询的过程，因为每一次域名服务器只返回单次<br>查询的结果，下一级的查询由本地 DNS 服务器自己进行。</p><h4 id="DNS-缓存"><a href="#DNS-缓存" class="headerlink" title="DNS 缓存"></a>DNS 缓存</h4><p>DNS 缓存的原理非常简单，在一个请求链中，当某个 DNS 服务器接收到一个 DNS 回答后，它能够将回答中的信息缓存在本<br>地存储器中。返回的资源记录中的 TTL 代表了该条记录的缓存的时间。</p><h4 id="DNS-实现负载平衡"><a href="#DNS-实现负载平衡" class="headerlink" title="DNS 实现负载平衡"></a>DNS 实现负载平衡</h4><p>DNS 可以用于在冗余的服务器上实现负载平衡。因为现在一般的大型网站使用多台服务器提供服务，因此一个域名可能会对应<br>多个服务器地址。当用户发起网站域名的 DNS 请求的时候，DNS 服务器返回这个域名所对应的服务器 IP 地址的集合，但在<br>每个回答中，会循环这些 IP 地址的顺序，用户一般会选择排在前面的地址发送请求。以此将用户的请求均衡的分配到各个不<br>同的服务器上，这样来实现负载均衡。</p><p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2016/06/dns.html">《DNS 原理入门》</a><br><a href="http://www.ruanyifeng.com/blog/2018/05/root-domain.html">《根域名的知识》</a></p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>传输层协议主要是为不同主机上的不同进程间提供了逻辑通信的功能。传输层只工作在端系统中。</p><h3 id="多路复用与多路分解"><a href="#多路复用与多路分解" class="headerlink" title="多路复用与多路分解"></a>多路复用与多路分解</h3><p>将传输层报文段中的数据交付到正确的套接字的工作被称为多路分解。</p><p>在源主机上从不同的套接字中收集数据，封装头信息生成报文段后，将报文段传递到网络层，这个过程被称为多路复用。</p><p>无连接的多路复用和多路分解指的是 UDP 套接字的分配过程，一个 UDP 套接字由一个二元组来标识，这个二元组包含了一<br>个目的地址和一个目的端口号。因此不同源地址和端口号的 UDP 报文段到达主机后，如果它们拥有相同的目的地址和目的端<br>口号，那么不同的报文段将会转交到同一个 UDP 套接字中。</p><p>面向连接的多路复用和多路分解指的是 TCP 套接字的分配过程，一个 TCP 套接字由一个四元组来标识，这个四元组包含了<br>源 IP 地址、源端口号、目的地址和目的端口号。因此，一个 TCP 报文段从网络中到达一台主机上时，该主机使用全部 4 个<br>值来将报文段定向到相应的套接字。</p><h3 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h3><p>UDP 是一种无连接的，不可靠的传输层协议。它只提供了传输层需要实现的最低限度的功能，除了复用/分解功能和少量的差<br>错检测外，它几乎没有对 IP 增加其他的东西。UDP 协议适用于对实时性要求高的应用场景。</p><p>特点：</p><ol><li><p>使用 UDP 时，在发送报文段之前，通信双方没有握手的过程，因此 UDP 被称为是无连接的传输层协议。因为没有握手<br>过程，相对于 TCP 来说，没有建立连接的时延。因为没有连接，所以不需要在端系统中保存连接的状态。</p></li><li><p>UDP 提供尽力而为的交付服务，也就是说 UDP 协议不保证数据的可靠交付。</p></li><li><p>UDP 没有拥塞控制和流量控制的机制，所以 UDP 报文段的发送速率没有限制。</p></li><li><p>因为一个 UDP 套接字只使用目的地址和目的端口来标识，所以 UDP 可以支持一对一、一对多、多对一和多对多的交互<br>通信。</p></li><li><p>UDP 首部小，只有 8 个字节。</p></li></ol><h4 id="UDP-报文段结构"><a href="#UDP-报文段结构" class="headerlink" title="UDP 报文段结构"></a>UDP 报文段结构</h4><p>UDP 报文段由首部和应用数据组成。报文段首部包含四个字段，分别是源端口号、目的端口号、长度和检验和，每个字段的长<br>度为两个字节。长度字段指的是整个报文段的长度，包含了首部和应用数据的大小。校验和是 UDP 提供的一种差错校验机制。<br>虽然提供了差错校验的机制，但是 UDP 对于差错的恢复无能为力。</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-16.png" alt="UDP 报文段结构"></p><h3 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h3><p>TCP 协议是面向连接的，提供可靠数据传输服务的传输层协议。</p><p>特点：</p><ol><li><p>TCP 协议是面向连接的，在通信双方进行通信前，需要通过三次握手建立连接。它需要在端系统中维护双方连接的状态信息。</p></li><li><p>TCP 协议通过序号、确认号、定时重传、检验和等机制，来提供可靠的数据传输服务。</p></li><li><p>TCP 协议提供的是点对点的服务，即它是在单个发送方和单个接收方之间的连接。</p></li><li><p>TCP 协议提供的是全双工的服务，也就是说连接的双方的能够向对方发送和接收数据。</p></li><li><p>TCP 提供了拥塞控制机制，在网络拥塞的时候会控制发送数据的速率，有助于减少数据包的丢失和减轻网络中的拥塞程度。</p></li><li><p>TCP 提供了流量控制机制，保证了通信双方的发送和接收速率相同。如果接收方可接收的缓存很小时，发送方会降低发送<br>速率，避免因为缓存填满而造成的数据包的丢失。</p></li></ol><h4 id="TCP-报文段结构"><a href="#TCP-报文段结构" class="headerlink" title="TCP 报文段结构"></a>TCP 报文段结构</h4><p>TCP 报文段由首部和数据组成，它的首部一般为 20 个字节。</p><p>源端口和目的端口号用于报文段的多路复用和分解。</p><p>32 比特的序号和 32 比特的确认号，用与实现可靠数据运输服务。</p><p>16 比特的接收窗口字段用于实现流量控制，该字段表示接收方愿意接收的字节的数量。</p><p>4 比特的首部长度字段，该字段指示了以 32 比特的字为单位的 TCP 首部的长度。</p><p>6 比特的标志字段，ACK 字段用于指示确认序号的值是有效的，RST、SYN 和 FIN 比特用于连接建立和拆除。设置 PSH 字<br>段指示接收方应该立即将数据交给上层，URG 字段用来指示报文段里存在紧急的数据。</p><p>校验和提供了对数据的差错检测。</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-17.png" alt="TCP 报文段结构"></p><h4 id="TCP-三次握手的过程"><a href="#TCP-三次握手的过程" class="headerlink" title="TCP 三次握手的过程"></a>TCP 三次握手的过程</h4><p>第一次握手，客户端向服务器发送一个 SYN 连接请求报文段，报文段的首部中 SYN 标志位置为 1，序号字段是一个任选的<br>随机数。它代表的是客户端数据的初始序号。</p><p>第二次握手，服务器端接收到客户端发送的 SYN 连接请求报文段后，服务器首先会为该连接分配 TCP 缓存和变量，然后向<br>客户端发送 SYN ACK 报文段，报文段的首部中 SYN 和 ACK 标志位都被置为 1，代表这是一个对 SYN 连接请求的确认，<br>同时序号字段是服务器端产生的一个任选的随机数，它代表的是服务器端数据的初始序号。确认号字段为客户端发送的序号加<br>一。</p><p>第三次握手，客户端接收到服务器的肯定应答后，它也会为这次 TCP 连接分配缓存和变量，同时向服务器端发送一个对服务<br>器端的报文段的确认。第三次握手可以在报文段中携带数据。</p><p>在我看来，TCP 三次握手的建立连接的过程就是相互确认初始序号的过程，告诉对方，什么样序号的报文段能够被正确接收。<br>第三次握手的作用是客户端对服务器端的初始序号的确认。如果只使用两次握手，那么服务器就没有办法知道自己的序号是否<br>已被确认。同时这样也是为了防止失效的请求报文段被服务器接收，而出现错误的情况。</p><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/24853633">《TCP 为什么是三次握手，而不是两次或四次？》</a><br><a href="https://blog.csdn.net/qzcsu/article/details/72861891">《TCP 的三次握手与四次挥手》</a></p><h4 id="TCP-四次挥手的过程"><a href="#TCP-四次挥手的过程" class="headerlink" title="TCP 四次挥手的过程"></a>TCP 四次挥手的过程</h4><p>因为 TCP 连接是全双工的，也就是说通信的双方都可以向对方发送和接收消息，所以断开连接需要双方的确认。</p><p>第一次挥手，客户端认为没有数据要再发送给服务器端，它就向服务器发送一个 FIN 报文段，申请断开客户端到服务器端的<br>连接。发送后客户端进入 FIN_WAIT_1 状态。</p><p>第二次挥手，服务器端接收到客户端释放连接的请求后，向客户端发送一个确认报文段，表示已经接收到了客户端释放连接的<br>请求，以后不再接收客户端发送过来的数据。但是因为连接是全双工的，所以此时，服务器端还可以向客户端发送数据。服务<br>器端进入 CLOSE_WAIT 状态。客户端收到确认后，进入 FIN_WAIT_2 状态。</p><p>第三次挥手，服务器端发送完所有数据后，向客户端发送 FIN 报文段，申请断开服务器端到客户端的连接。发送后进入 LAS<br>T_ACK 状态。</p><p>第四次挥手，客户端接收到 FIN 请求后，向服务器端发送一个确认应答，并进入 TIME_WAIT 阶段。该阶段会持续一段时间，<br>这个时间为报文段在网络中的最大生存时间，如果该时间内服务端没有重发请求的话，客户端进入 CLOSED 的状态。如果收到<br>服务器的重发请求就重新发送确认报文段。服务器端收到客户端的确认报文段后就进入 CLOSED 状态，这样全双工的连接就被<br>释放了。</p><p>TCP 使用四次挥手的原因是因为 TCP 的连接是全双工的，所以需要双方分别释放到对方的连接，单独一方的连接释放，只代<br>表不能再向对方发送数据，连接处于的是半释放的状态。</p><p>最后一次挥手中，客户端会等待一段时间再关闭的原因，是为了防止发送给服务器的确认报文段丢失或者出错，从而导致服务器<br>端不能正常关闭。</p><p>详细资料可以参考：</p><p><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5c447392e51d45524b02eaf5">《前端面试之道》</a></p><h4 id="状态转化图"><a href="#状态转化图" class="headerlink" title="状态转化图"></a>状态转化图</h4><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-18.png" alt="客户端状态图"></p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-19.png" alt="服务端状态图"></p><h4 id="ARQ-协议"><a href="#ARQ-协议" class="headerlink" title="ARQ 协议"></a>ARQ 协议</h4><p>ARQ 协议指的是自动重传请求，它通过超时和重传来保证数据的可靠交付，它是 TCP 协议实现可靠数据传输的一个很重要的<br>机制。</p><p>它分为停止等待 ARQ 协议和连续 ARQ 协议。</p><p>一、停止等待 ARQ 协议</p><p>停止等待 ARQ 协议的基本原理是，对于发送方来说发送方每发送一个分组，就为这个分组设置一个定时器。当发送分组的确认<br>回答返回了，则清除定时器，发送下一个分组。如果在规定的时间内没有收到已发送分组的肯定回答，则重新发送上一个分组。</p><p>对于接受方来说，每次接受到一个分组，就返回对这个分组的肯定应答，当收到冗余的分组时，就直接丢弃，并返回一个对冗余<br>分组的确认。当收到分组损坏的情况的时候，直接丢弃。</p><p>使用停止等待 ARQ 协议的缺点是每次发送分组必须等到分组确认后才能发送下一个分组，这样会造成信道的利用率过低。</p><p>二、连续 ARQ 协议</p><p>连续 ARQ 协议是为了解决停止等待 ARQ 协议对于信道的利用率过低的问题。它通过连续发送一组分组，然后再等待对分组的<br>确认回答，对于如何处理分组中可能出现的差错恢复情况，一般可以使用滑动窗口协议和选择重传协议来实现。</p><ol><li>滑动窗口协议</li></ol><p>使用滑动窗口协议，在发送方维持了一个发送窗口，发送窗口以前的分组是已经发送并确认了的分组，发送窗口中包含了已经发<br>送但未确认的分组和允许发送但还未发送的分组，发送窗口以后的分组是缓存中还不允许发送的分组。当发送方向接收方发送分<br>组时，会依次发送窗口内的所有分组，并且设置一个定时器，这个定时器可以理解为是最早发送但未收到确认的分组。如果在定<br>时器的时间内收到某一个分组的确认回答，则滑动窗口，将窗口的首部移动到确认分组的后一个位置，此时如果还有已发送但没<br>有确认的分组，则重新设置定时器，如果没有了则关闭定时器。如果定时器超时，则重新发送所有已经发送但还未收到确认的分<br>组。</p><p>接收方使用的是累计确认的机制，对于所有按序到达的分组，接收方返回一个分组的肯定回答。如果收到了一个乱序的分组，那<br>么接方会直接丢弃，并返回一个最近的按序到达的分组的肯定回答。使用累计确认保证了确认号以前的分组都已经按序到达了，<br>所以发送窗口可以移动到已确认分组的后面。</p><p>滑动窗口协议的缺点是因为使用了累计确认的机制，如果出现了只是窗口中的第一个分组丢失，而后面的分组都按序到达的情况<br>的话，那么滑动窗口协议会重新发送所有的分组，这样就造成了大量不必要分组的丢弃和重传。</p><ol start="2"><li>选择重传协议</li></ol><p>因为滑动窗口使用累计确认的方式，所以会造成很多不必要分组的重传。使用选择重传协议可以解决这个问题。</p><p>选择重传协议在发送方维护了一个发送窗口。发送窗口的以前是已经发送并确认的分组，窗口内包含了已发送但未被确认的分组，<br>已确认的乱序分组，和允许发送但还未发送的分组，发送窗口以后的是缓存中还不允许发送的分组。选择重传协议与滑动窗口协<br>议最大的不同是，发送方发送分组时，为一个分组都创建了一个定时器。当发送方接受到一个分组的确认应答后，取消该分组的<br>定时器，并判断接受该分组后，是否存在由窗口首部为首的连续的确认分组，如果有则向后移动窗口的位置，如果没有则将该分<br>组标识为已接收的乱序分组。当某一个分组定时器到时后，则重新传递这个分组。</p><p>在接收方，它会确认每一个正确接收的分组，不管这个分组是按序的还是乱序的，乱序的分组将被缓存下来，直到所有的乱序分<br>组都到达形成一个有序序列后，再将这一段分组交付给上层。对于不能被正确接收的分组，接收方直接忽略该分组。</p><p>详细资料可以参考：<br><a href="https://blog.csdn.net/guoweimelon/article/details/50879588">《TCP 连续 ARQ 协议和滑动窗口协议》</a></p><h4 id="TCP-的可靠运输机制"><a href="#TCP-的可靠运输机制" class="headerlink" title="TCP 的可靠运输机制"></a>TCP 的可靠运输机制</h4><p>TCP 的可靠运输机制是基于连续 ARQ 协议和滑动窗口协议的。</p><p>TCP 协议在发送方维持了一个发送窗口，发送窗口以前的报文段是已经发送并确认了的报文段，发送窗口中包含了已经发送但<br>未确认的报文段和允许发送但还未发送的报文段，发送窗口以后的报文段是缓存中还不允许发送的报文段。当发送方向接收方发<br>送报文时，会依次发送窗口内的所有报文段，并且设置一个定时器，这个定时器可以理解为是最早发送但未收到确认的报文段。<br>如果在定时器的时间内收到某一个报文段的确认回答，则滑动窗口，将窗口的首部向后滑动到确认报文段的后一个位置，此时如<br>果还有已发送但没有确认的报文段，则重新设置定时器，如果没有了则关闭定时器。如果定时器超时，则重新发送所有已经发送<br>但还未收到确认的报文段，并将超时的间隔设置为以前的两倍。当发送方收到接收方的三个冗余的确认应答后，这是一种指示，<br>说明该报文段以后的报文段很有可能发生丢失了，那么发送方会启用快速重传的机制，就是当前定时器结束前，发送所有的已发<br>送但确认的报文段。</p><p>接收方使用的是累计确认的机制，对于所有按序到达的报文段，接收方返回一个报文段的肯定回答。如果收到了一个乱序的报文<br>段，那么接方会直接丢弃，并返回一个最近的按序到达的报文段的肯定回答。使用累计确认保证了返回的确认号之前的报文段都<br>已经按序到达了，所以发送窗口可以移动到已确认报文段的后面。</p><p>发送窗口的大小是变化的，它是由接收窗口剩余大小和网络中拥塞程度来决定的，TCP 就是通过控制发送窗口的长度来控制报文<br>段的发送速率。</p><p>但是 TCP 协议并不完全和滑动窗口协议相同，因为许多的 TCP 实现会将失序的报文段给缓存起来，并且发生重传时，只会重<br>传一个报文段，因此 TCP 协议的可靠传输机制更像是窗口滑动协议和选择重传协议的一个混合体。</p><h4 id="TCP-的流量控制机制"><a href="#TCP-的流量控制机制" class="headerlink" title="TCP 的流量控制机制"></a>TCP 的流量控制机制</h4><p>TCP 提供了流量控制的服务，这个服务的主要目的是控制发送方的发送速率，保证接收方来得及接收。因为一旦发送的速率大<br>于接收方所能接收的速率，就会造成报文段的丢失。接收方主要是通过接收窗口来告诉发送方自己所能接收的大小，发送方根据<br>接收方的接收窗口的大小来调整发送窗口的大小，以此来达到控制发送速率的目的。</p><h4 id="TCP-的拥塞控制机制"><a href="#TCP-的拥塞控制机制" class="headerlink" title="TCP 的拥塞控制机制"></a>TCP 的拥塞控制机制</h4><p>TCP 的拥塞控制主要是根据网络中的拥塞情况来控制发送方数据的发送速率，如果网络处于拥塞的状态，发送方就减小发送的<br>速率，这样一方面是为了避免继续增加网络中的拥塞程度，另一方面也是为了避免网络拥塞可能造成的报文段丢失。</p><p>TCP 的拥塞控制主要使用了四个机制，分别是慢启动、拥塞避免、快速重传和快速恢复。</p><p>慢启动的基本思想是，因为在发送方刚开始发送数据的时候，并不知道网络中的拥塞程度，所以先以较低的速率发送，进行试探<br>，每次收到一个确认报文，就将发动窗口的长度加一，这样每个 RTT 时间后，发送窗口的长度就会加倍。当发送窗口的大小达<br>到一个阈值的时候就进入拥塞避免算法。</p><p>拥塞避免算法是为了避免可能发生的拥塞，将发送窗口的大小由每过一个 RTT 增长一倍，变为每过一个 RTT ，长度只加一。<br>这样将窗口的增长速率由指数增长，变为加法线性增长。</p><p>快速重传指的是，当发送方收到三个冗余的确认应答时，因为 TCP 使用的是累计确认的机制，所以很有可能是发生了报文段的<br>丢失，因此采用立即重传的机制，在定时器结束前发送所有已发送但还未接收到确认应答的报文段。</p><p>快速恢复是对快速重传的后续处理，因为网络中可能已经出现了拥塞情况，所以会将慢启动的阀值减小为原来的一半，然后将拥<br>塞窗口的值置为减半后的阀值，然后开始执行拥塞避免算法，使得拥塞窗口缓慢地加性增大。简单来理解就是，乘性减，加性增。</p><p>TCP 认为网络拥塞的主要依据是报文段的重传次数，它会根据网络中的拥塞程度，通过调整慢启动的阀值，然后交替使用上面四<br>种机制来达到拥塞控制的目的。</p><p>详细资料可以参考：<br><a href="https://www.jianshu.com/p/7d59f9292b03">《TCP 的拥塞控制机制》</a><br><a href="http://www.voidcn.com/article/p-vrdkquop-ms.html">《网络基本功：TCP 拥塞控制机制》</a></p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>网络层协议主要实现了不同主机间的逻辑通信功能。网络层协议一共包含两个主要的组件，一个 IP 网际协议，一个是路由选<br>择协议。</p><p>IP 网际协议规定了网络层的编址和转发方式，比如说我们接入网络的主机都会被分配一个 IP 地址，常用的比如 IPV4 使用<br>32 位来分配地址，还有 IPv6 使用 128 位来分配地址。</p><p>路由选择协议决定了数据报从源到目的地所流经的路径，常见的比如距离向量路由选择算法等。</p><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>数据链路层提供的服务是如何将数据报通过单一通信链路从一个结点移动到相邻节点。每一台主机都有一个唯一的 MAC 地址，<br>这是由网络适配器决定的，在全世界都是独一无二的。</p><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>物理层提供的服务是尽可能的屏蔽掉组成网络的物理设备和传输介质间的差异，使数据链路层不需要考虑网络的具体传输介质<br>是什么。</p><p>详细资料可以参考：<br><a href="https://juejin.im/post/5b7be0b2e51d4538db34a51e#heading-1">《搞定计算机网络面试，看这篇就够了（补充版）》</a><br><a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html">《互联网协议入门（一）》</a><br><a href="http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html">《互联网协议入门（二）》</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 计算机网络知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue常见面试题</title>
      <link href="/61586/"/>
      <url>/61586/</url>
      
        <content type="html"><![CDATA[<h2 id="new-Vue-发生了什么"><a href="#new-Vue-发生了什么" class="headerlink" title="new Vue() 发生了什么"></a>new Vue() 发生了什么</h2><blockquote><ol><li>内部执行了根实例的初始化过程</li><li><code>options</code> 合并</li><li>属性初始化</li><li>自定义事件处理</li><li>数据响应式处理</li><li>初始化生命周期钩子</li></ol></blockquote><h2 id="Vue-数据响应式原理"><a href="#Vue-数据响应式原理" class="headerlink" title="Vue 数据响应式原理"></a>Vue 数据响应式原理</h2>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">- <span class="string">`defineReactive`</span> 把数据定义成响应式的</span><br><span class="line">- 给属性增加一个 <span class="string">`dep`</span>，用来收集对应的那些 <span class="string">`watcher`</span></span><br><span class="line">- 等数据变化进行更新</span><br></pre></td></tr></table></figure><h2 id="Vue-生命周期"><a href="#Vue-生命周期" class="headerlink" title="Vue 生命周期"></a>Vue 生命周期</h2>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">`beforeCreate`</span></span><br><span class="line"></span><br><span class="line">这是第一个生命周期函数，此时，组件的 <span class="string">`data`</span> 和 <span class="string">`methods`</span> 以及页面 <span class="string">`DOM`</span> 结构都还没有初始化，所以这个阶段，什么都做不了</span><br><span class="line"></span><br><span class="line"><span class="string">`created`</span></span><br><span class="line"></span><br><span class="line">这是组件创建阶段第二个生命周期函数，此时，组件的 <span class="string">`data`</span> 和 <span class="string">`methods`</span> 已经可以用了，但是页面还没有渲染出来；在这个生命周期函数中，我们经常会发起 <span class="string">`Ajax`</span> 请求</span><br><span class="line"></span><br><span class="line"><span class="string">`beforeMount`</span></span><br><span class="line"></span><br><span class="line">当模板在内存中编译完成，会立即执行实例创建阶段的第三个生命周期；此时内存中的模板结构，还没有真正渲染到页面上，此时页面上看不到真实的数据( 用户看到的只是一个模板页面 )</span><br><span class="line"></span><br><span class="line"><span class="string">`mounted`</span></span><br><span class="line"></span><br><span class="line">这个是组件创建阶段最后一个生命周期函数，此时，页面已经真正的渲染好了，用户已经可以看到真实的页面数据了；当这个生命周期函数执行完，组件就离开了创建阶段，进入到了运行中的阶段</span><br><span class="line"></span><br><span class="line">- 如果用到了第三方的 <span class="string">`UI`</span> 插件，而且这个插件还需要被初始化，那么，必须在 <span class="string">`mounted`</span> 及之后来初始化插件（echarts 图表）</span><br><span class="line"></span><br><span class="line"><span class="string">`beforeUpdate`</span></span><br><span class="line"></span><br><span class="line">当执行 <span class="string">`beforeUpdate`</span> 生命周期函数的时候， 数据肯定时最新的，但是页面上呈现的数据，还是旧的</span><br><span class="line"></span><br><span class="line"><span class="string">`updated`</span></span><br><span class="line"></span><br><span class="line">页面已经完成了更新，此时，<span class="string">`data`</span> 数据是最新的，同时，页面上呈现的数据，也是最新的</span><br><span class="line"></span><br><span class="line"><span class="string">`beforeDestory`</span></span><br><span class="line"></span><br><span class="line">当执行 <span class="string">`beforeDestory`</span> 的时候，组件即将被销毁，但是还没有真正开始销毁，此时组件还是正常可用的，<span class="string">`data`</span>、<span class="string">`methods`</span> 等数据或方法，依然可以被正常访问</span><br><span class="line"></span><br><span class="line"><span class="string">`destoryed`</span></span><br><span class="line"></span><br><span class="line">组件已经完成了销毁，此时组件已经废了，<span class="string">`data`</span>、<span class="string">`methods`</span> 都不可用了</span><br></pre></td></tr></table></figure><h2 id="SPA-优缺点"><a href="#SPA-优缺点" class="headerlink" title="SPA 优缺点"></a>SPA 优缺点</h2><blockquote><p>SPA( single-page application )仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。⼀旦⻚⾯加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p><blockquote><p>优点<br>      1. 前后端分离<br>      2. 减轻服务器的负担<br>      3. 良好的交互体验 - ajax<br>缺点<br>      1. 不利于 SEO<br>      2. 首屏渲染时间长<br>      3. 前进、后退难以管理</p></blockquote></blockquote><h2 id="说说-vue-的事件管理"><a href="#说说-vue-的事件管理" class="headerlink" title="说说 vue 的事件管理"></a>说说 vue 的事件管理</h2><blockquote><p>待更新</p></blockquote><h2 id="vue-如何防止数据被再次-observe"><a href="#vue-如何防止数据被再次-observe" class="headerlink" title="vue 如何防止数据被再次 observe"></a>vue 如何防止数据被再次 observe</h2><blockquote><p>待更新</p></blockquote><h2 id="数据变化，派发更新的时候，做了何优化"><a href="#数据变化，派发更新的时候，做了何优化" class="headerlink" title="数据变化，派发更新的时候，做了何优化"></a>数据变化，派发更新的时候，做了何优化</h2><blockquote><p>将变更放入队列，在下一个 <code>nexttick</code> 之后更新</p></blockquote><h2 id="Vue-nextTick-原理"><a href="#Vue-nextTick-原理" class="headerlink" title="Vue.$nextTick 原理"></a><code>Vue.$nextTick</code> 原理</h2><p>在下次 <code>DOM</code> 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 <code>DOM</code></p><ul><li>言外之意就是在主线程执行代码完成之后，立刻执行</li><li>也就是在微任务队列中(也可能是宏任务队列，视运行环境而定)</li><li>内部实现依次使用 <code>Promise</code> -&gt; <code>MutationObserver</code> -&gt; <code>setImmediate</code> -&gt; <code>setTimeout</code> 做兼容</li><li>Vue 源码 <code>src/core/util/next-tick.js</code> 文件</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; isNative(<span class="built_in">Promise</span>)) &#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve()</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    p.then(flushCallbacks)</span><br><span class="line">    <span class="keyword">if</span> (isIOS) <span class="built_in">setTimeout</span>(noop)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">  !isIE &amp;&amp;</span><br><span class="line">  <span class="keyword">typeof</span> MutationObserver !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp;</span><br><span class="line">  (isNative(MutationObserver) ||</span><br><span class="line">    <span class="comment">// PhantomJS and iOS 7.x</span></span><br><span class="line">    MutationObserver.toString() === <span class="string">&#x27;[object MutationObserverConstructor]&#x27;</span>)</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="comment">// Use MutationObserver where native Promise is not available,</span></span><br><span class="line">  <span class="keyword">let</span> counter = <span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> observer = <span class="keyword">new</span> MutationObserver(flushCallbacks)</span><br><span class="line">  <span class="keyword">const</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="built_in">String</span>(counter))</span><br><span class="line">  observer.observe(textNode, &#123;</span><br><span class="line">    <span class="attr">characterData</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    counter = (counter + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">    textNode.data = <span class="built_in">String</span>(counter)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; isNative(setImmediate)) &#123;</span><br><span class="line">  <span class="comment">// Fallback to setImmediate.</span></span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setImmediate(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Fallback to setTimeout.</span></span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(flushCallbacks, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">作用: 视图更新之后，获取最新的 <span class="string">`dom`</span> 节点,<span class="string">`data`</span> 数据修改后，立即拿到最新数据</span><br></pre></td></tr></table></figure><h2 id="CommonJS-和-esModule-的区别"><a href="#CommonJS-和-esModule-的区别" class="headerlink" title="CommonJS 和 esModule 的区别"></a>CommonJS 和 esModule 的区别</h2><blockquote><p><a href="https://es6.ruanyifeng.com/#docs/module-loader">参考</a><br>CommonJS</p></blockquote><ol><li>module.exports 默认值为 {}</li><li>exports 是 module.exports 的引用（exports 默认指向 module.exports 的内存空间）</li><li>require() 返回的是 module.exports 而不是 exports<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//foo.js</span></span><br><span class="line"><span class="built_in">exports</span> = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">&#125; <span class="comment">// 给 exports 重新赋值，断开了 exports 指向 module.exports 的地址，重新指向一个新地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//bar.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; foo &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./foo.js&#x27;</span>)</span><br><span class="line"><span class="comment">//reuqire 返回的是 module.exports 对象， 默认为 &#123;&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>esModule</p></blockquote></li><li>浏览器加载 ES6 模块，也使用 <code>&lt;script&gt;</code> 标签，但是要加入 <code>type=&quot;module&quot;</code> 属性。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span> src=<span class="string">&quot;./foo.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><blockquote><p>差异</p></blockquote></li><li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li><li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</li><li>CommonJS 模块的 require() 是同步加载模块，ES6 模块的 import 命令是异步加载，有一个独立的模块依赖的解析阶段。</li></ol><blockquote><p>CommonJS 模块加载 ES6 模块<br>  使用 import() 方法加载<br>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">;(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&#x27;./foo.mjs&#x27;</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><br>ES6 模块加载 CommonJS 模块<br>    ES6 模块的 import 命令可以加载 CommonJS 模块，但是只能整体加载，不能只加载单一的输出项。<br>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">import</span> packageMain <span class="keyword">from</span> <span class="string">&#x27;commonjs-package&#x27;</span></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">import</span> &#123; method &#125; <span class="keyword">from</span> <span class="string">&#x27;commonjs-package&#x27;</span></span><br></pre></td></tr></table></figure></p></blockquote><h2 id="父组件监听子组件的生命周期"><a href="#父组件监听子组件的生命周期" class="headerlink" title="父组件监听子组件的生命周期"></a>父组件监听子组件的生命周期</h2><blockquote></blockquote><ol><li>子组件生命周期中 <code>emit</code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Parent.vue</span></span><br><span class="line">&lt;Child @mounted=<span class="string">&quot;doSomething&quot;</span>/&gt;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// Child.vue</span></span><br><span class="line"><span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.$emit(<span class="string">&#x27;mounted&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>hook<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Parent.vue</span></span><br><span class="line">&lt;Child @hook:mounted=<span class="string">&quot;doSomething&quot;</span>/&gt;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Vue-Router前端路由"><a href="#Vue-Router前端路由" class="headerlink" title="Vue-Router前端路由"></a>Vue-Router前端路由</h2><ol><li>hash 模式<blockquote><p>类似于服务端路由，前端路由实现起来其实也很简单，就是匹配不同的 url 路径，进行解析，然后动态的渲染出区域 html 内容这种 <code>#</code> 后面 hash 值的变化，并不会导致浏览器向服务器发出请求，浏览器不发出请求，也就不会刷新页面另外每次 hash 值的变化，还会触发 hashchange 这个事件，通过这个事件我们就可以知道 hash 值发生了哪些变化然后我们便可以监听 hashchange 来实现更新页面部分内容的操作</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;hashchange&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>history 模式<blockquote><p>HTML5 新增的API： pushState 和 replaceState，通过这两个 API 可以改变 url 地址且不会发送请求但因为没有 <code>#</code> 号，所以当用户刷新页面之类的操作时，浏览器还是会给服务器发送请求为了避免出现这种情况，所以这个实现需要<em>服务器</em>的支持，需要<em>把所有路由都重定向到根页面</em>。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当活动历史记录条目更改时，将触发popstate事件</span></span><br><span class="line"><span class="comment">// 调用history.pushState()或history.replaceState()不会触发popstate事件。只有在做出浏览器动作时，才会触发该事件，如用户点击浏览器的回退按钮（或者在Javascript代码中调用history.back()或者history.forward()方法）</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;popstate&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h2 id="history-和-hash-模式区别"><a href="#history-和-hash-模式区别" class="headerlink" title="history 和 hash 模式区别"></a><code>history</code> 和 <code>hash</code> 模式区别</h2><blockquote><ol><li><code>hash</code> 模式路径上有 <code>#</code>, 用 <code>window.location.hash</code> 读取。而 <code>history</code> 路由没有会好看一点</li><li><code>hash</code> 路由支持低版本的浏览器，而 <code>history</code> 路由是 <code>HTML5</code> 新增的 <code>API</code></li><li>回车刷新操作时，<code>hash</code> 路由会加载到地址栏对应的页面，而 <code>history</code> 路由一般 404 报错</li><li><code>history</code> 模式需要后台配置支持。当我们刷新页面或者直接访问路径的时候就会返回 404，那是因为在 history 模式下，只是动态的通过 js 操作 window.history 来改变浏览器地址栏里的路径，并没有发起 http 请求，但是当我直接在浏览器里输入这个地址的时候，就一定要对服务器发起 http 请求，但是这个目标在服务器上又不存在，所以会返回 404</li></ol></blockquote><h2 id="vue-router-钩子执行顺序"><a href="#vue-router-钩子执行顺序" class="headerlink" title="vue-router 钩子执行顺序"></a>vue-router 钩子执行顺序</h2><blockquote><p>导航钩子分类</p><blockquote><ol><li>全局守卫</li><li>路由独享守卫</li><li>组件守卫</li></ol></blockquote></blockquote><blockquote><p>全局守卫<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">  console.log(&#x27;全局 - beforeEach&#x27;)</span><br><span class="line">  next() // 必须要有调用 next</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.afterEach(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;全局 - afterEach&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>路由独享守卫<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: &#x27;/home&#x27;,</span><br><span class="line">  name: &#x27;Home&#x27;,</span><br><span class="line">  component: () =&gt; import(&#x27;../views/Home.vue&#x27;),</span><br><span class="line">  beforeEnter (to, from , next) &#123;</span><br><span class="line">    next() // 必须要有调用 next</span><br><span class="line">    console.log(&#x27;路由 - beforeEnter ---&gt; Home&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  path: &#x27;/about&#x27;,</span><br><span class="line">  name: &#x27;About&#x27;,</span><br><span class="line">  component: () =&gt; import(&#x27;../views/About.vue&#x27;),</span><br><span class="line">  beforeEnter (to, from, next) &#123;</span><br><span class="line">    next() // 必须要有调用 next</span><br><span class="line">    console.log(&#x27;路由 - beforeEnter ---&gt; About&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>组件守卫<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Home 组件</span><br><span class="line">beforeRouteEnter(to, from, next) &#123;</span><br><span class="line">  console.log(&#x27;组件 - beforeRouteEnter ---&gt; Home&#x27;)</span><br><span class="line">  next() // 必须要有调用 next</span><br><span class="line">&#125;,</span><br><span class="line">beforeRouteLeave(to, from, next) &#123;</span><br><span class="line">  console.log(&#x27;组件 - beforeRouteLeave ---&gt; Home&#x27;)</span><br><span class="line">  next() // 必须要有调用 next</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// About 组件</span><br><span class="line">beforeRouteEnter(to, from, next) &#123;</span><br><span class="line">  console.log(&#x27;组件 - beforeRouteEnter ---&gt; About&#x27;)</span><br><span class="line">  next()</span><br><span class="line">&#125;,</span><br><span class="line">beforeRouteLeave(to, from, next) &#123;</span><br><span class="line">  next()</span><br><span class="line">  console.log(&#x27;组件 - beforeRouteLeave ---&gt; About&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>顺序<br>  从 <code>Home</code> 组件 跳转到 <code>About</code> 组件 依次输出<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 组件 - beforeRouteLeave ---&gt; Home</span><br><span class="line">- 全局 - beforeEach</span><br><span class="line">- 路由 - beforeEnter ---&gt; About</span><br><span class="line">- 组件 - beforeRouteEnter ---&gt; About</span><br><span class="line">- 全局 - afterEach</span><br></pre></td></tr></table></figure><br>  假设，一打开页面就进入 <code>Home</code> 页面，此时的钩子顺序 如下<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 全局 - beforeEach</span><br><span class="line">- 路由 - beforeEnter ---&gt; Home</span><br><span class="line">- 组件 - beforeRouteEnter ---&gt; Home</span><br><span class="line">- 全局 - afterEach</span><br></pre></td></tr></table></figure><br>  综合上诉两种情况，我们可以得出如下结论<br>    - 如果是第一次进入页面，依次执行 <code>全局的进入前置钩子</code> -&gt; <code>路由的进入钩子</code> -&gt; <code>组件的进入钩子</code> -&gt; <code>全局的进入后置钩子</code><br>    - 如果从组件内离开，将会优先执行组件的 <code>beforeRouteLeave</code> 钩子，此后依次执行 <code>全局的进入前置钩子</code> -&gt; <code>路由的进入钩子</code> -&gt; <code>组件的进入钩子</code> -&gt; <code>全局的进入后置钩子</code><br>    - 顺序依次为： 组件离开(可有可无) -&gt; 全局 -&gt; 路由 -&gt; 组件 -&gt; 全局</p></blockquote><h2 id="vuex-判断修改state-是直接修改还是-提交commit"><a href="#vuex-判断修改state-是直接修改还是-提交commit" class="headerlink" title="vuex 判断修改state 是直接修改还是 提交commit"></a>vuex 判断修改state 是直接修改还是 提交commit</h2><blockquote><p>在严格模式下，直接修改 state 会报错，<code>this.$store.state.xxx = xxx</code></p></blockquote><h2 id="fetch-和-xhr-有什么区别"><a href="#fetch-和-xhr-有什么区别" class="headerlink" title="fetch 和 xhr 有什么区别"></a>fetch 和 xhr 有什么区别</h2><blockquote><ol><li>xhr<blockquote><p>1.1 浏览器内置 api<br>1.2 使用起来也比较繁琐，需要设置很多值。<br>1.3 使用回调函数</p></blockquote></li><li>fetch<blockquote><p>2.1 浏览器内置 api<br>2.2 Fetch 提供了对 Request 和 Response （以及其他与网络请求有关的）对象的通用定义<br>2.3 返回一个 Promise 对象</p></blockquote></li><li>差异<blockquote><ol><li>fetch 使用 Promise，不使用回调函数，因此大大简化了写法，写起来更简洁。</li><li>fetch 采用模块化设计，API 分散在多个对象上（Response 对象、Request 对象、Headers 对象），更合理一些；相比之下，XMLHttpRequest 的 API 设计并不是很好，输入、输出、状态都在同一个接口管理，容易写出非常混乱的代码。</li><li>fetch 通过数据流（Stream 对象）处理数据，可以分块读取，有利于提高网站性能表现，减少内存占用，对于请求大文件或者网速慢的场景相当有用。XMLHTTPRequest 对象不支持数据流，所有的数据必须放在缓存里，不支持分块读取，必须等待全部拿到后，再一次性吐出来。</li></ol></blockquote></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构建工具 - Vite</title>
      <link href="/20009/"/>
      <url>/20009/</url>
      
        <content type="html"><![CDATA[<h2 id="vite-原理"><a href="#vite-原理" class="headerlink" title="vite 原理"></a>vite 原理</h2><ul><li>浏览器遇到 es import 会发起请求</li><li>vite 拦截请求(实际上起了一个服务)，并返回转换编译后的代码</li><li>vite 区分不同类型的文件请求，并将这些请求交给专门的函数去处理</li><li>浏览器遇到 返回的代码还有请求的，继续发起请求</li><li>实现按需加载，不用打包，启动时间和更新大大缩短</li><li>文件变化了，直接让浏览器再次发起请求即可</li></ul><h2 id="vite-打包优化"><a href="#vite-打包优化" class="headerlink" title="vite 打包优化"></a>vite 打包优化</h2><ul><li>代码分割</li><li>文件合并，减少请求次数</li><li>不打包第三方库，直接引入</li></ul>]]></content>
      
      
      <categories>
          
          <category> 构建工具 </category>
          
          <category> Vite </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vite </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构建工具 - webpack</title>
      <link href="/20009/"/>
      <url>/20009/</url>
      
        <content type="html"><![CDATA[<h2 id="谈谈-webpack-原理"><a href="#谈谈-webpack-原理" class="headerlink" title="谈谈 webpack 原理"></a>谈谈 webpack 原理</h2><blockquote><ol><li>初始化参数</li><li>开始编译：初始化 <code>compiler</code> 对象</li><li>确定入口</li><li>编译模板：调用 <code>loader</code></li><li>完成模板编译：得到 <code>loader</code> 翻译后的所有模块</li><li>输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 <code>chunk</code>，再把每个 <code>chunk</code> 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会</li><li>输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统</li></ol></blockquote><h2 id="loader-作用"><a href="#loader-作用" class="headerlink" title="loader 作用"></a><code>loader</code> 作用</h2><blockquote><ol><li>加载文件</li><li>转换文件</li></ol></blockquote><h2 id="plugins-作用"><a href="#plugins-作用" class="headerlink" title="plugins 作用"></a><code>plugins</code> 作用</h2><blockquote><ol><li>打包优化</li><li>资源管理</li><li>注入环境变量</li><li>在 <code>Webpack</code> 运行的生命周期中会广播出许多事件，<code>Plugin</code> 可以监听这些事件，在合适的时机通过 <code>Webpack</code> 提供的 <code>API</code> 改变输出结果</li></ol></blockquote><h2 id="webpack-的生命周期"><a href="#webpack-的生命周期" class="headerlink" title="webpack 的生命周期"></a>webpack 的生命周期</h2><blockquote><ol><li>entry-options：option初始化</li><li>compile：开始编译</li><li>make：分析入口文件创建模板对象(compile中触发make事件并调用addEntry找到入口js文件，进行下一步的模块绑定)</li><li>build-module：构建模块</li><li>after-compile：完成所有模块构建结束编译过程</li><li>emit：compiler开始输出生成的assets、插件；有最后的机会修改输出内容</li><li>after-emit：输出完成</li></ol></blockquote><h2 id="webpack-常用的-plugin-和-loader"><a href="#webpack-常用的-plugin-和-loader" class="headerlink" title="webpack 常用的 plugin 和 loader"></a>webpack 常用的 plugin 和 loader</h2><blockquote><p>常用的 loader<br>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">- <span class="string">`file-loader`</span>：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件</span><br><span class="line">- <span class="string">`url-loader`</span>：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去</span><br><span class="line">- <span class="string">`source-map-loader`</span>：加载额外的 Source <span class="built_in">Map</span> 文件，以方便断点调试</span><br><span class="line">- <span class="string">`image-loader`</span>：加载并且压缩图片文件</span><br><span class="line">- <span class="string">`babel-loader`</span>：把 ES6 转换成 ES5</span><br><span class="line">- <span class="string">`css-loader`</span>：加载 CSS，支持模块化、压缩、文件导入等特性</span><br><span class="line">- <span class="string">`style-loader`</span>：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。</span><br><span class="line">- <span class="string">`eslint-loader`</span>：通过 ESLint 检查 JavaScript 代码</span><br></pre></td></tr></table></figure><br>常用的 plugin<br>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">- <span class="string">`webpack-merge`</span>：用于合并 webpack 的公共配置和环境配置(合并 webpack.config.js 和 webpack.development.js 或者 webpack.production.js)</span><br><span class="line">- <span class="string">`yargs-parser`</span>: 用于将我们的 npm scripts 中的命令行参数转换成键值对的形式如 <span class="string">`--mode development`</span> 会被解析成键值对的形式 <span class="string">`mode: &quot;development&quot;`</span>，便于在配置文件中获取参数</span><br><span class="line">- <span class="string">`clean-webpack-plugin`</span>: 用于清除本地文件，在进行生产环境打包的时候，如果不清除 dist 文件夹，那么每次打包都会生成不同的 js 文件或者 css 文件堆积在文件夹中，因为每次打包都会生成不同的 hash 值导致每次打包生成的文件名与上次打包不一样不会覆盖上次打包留下来的文件</span><br><span class="line">- <span class="string">`progress-bar-webpack-plugin`</span>: 打包编译的时候以进度条的形式反馈打包进度</span><br><span class="line">- <span class="string">`webpack-build-notifier`</span>: 当你打包之后切换到别的页面的时候，完成时会在本地系统弹出一个提示框告知你打包结果(成功或失败或警告)</span><br><span class="line">- <span class="string">`html-webpack-plugin`</span>:  自动生成 html,并默认将打包生成的 js、css 引入到 html 文件中</span><br><span class="line">- <span class="string">`mini-css-extract-plugin`</span>: webpack 打包样式文件中的默认会把样式文件代码打包到 bundle.js 中，mini-css-extract-plugin 这个插件可以将样式文件从 bundle.js 抽离出来一个文件，并且支持 chunk css</span><br><span class="line">- <span class="string">`add-asset-html-webpack-plugin`</span>: 从命名可以看出，它的作用是可以将静态资源 css 或者 js 引入到 html-webpack-plugin 生成的 html 文件中</span><br><span class="line">- <span class="string">`uglifyjs-webpack-plugin`</span>:  代码丑化，用于 js 压缩(可以调用系统的线程进行多线程压缩，优化 webpack 的压缩速度)</span><br><span class="line">- <span class="string">`optimize-css-assets-webpack-plugin`</span>: css 压缩，主要使用 cssnano 压缩器(webpack4 的执行环境内置了 cssnano，所以不用安装)</span><br><span class="line">- <span class="string">`friendly-errors-webpack-plugin`</span>:  能够更好在终端看到 webapck 运行的警告和错误</span><br><span class="line">- <span class="string">`happypack`</span>:  多线程编译，加快编译速度(加快 loader 的编译速度)，注意，thread-loader 不可以和 mini-css-extract-plugin 结合使用</span><br><span class="line">- <span class="string">`splitChunks`</span>: CommonChunkPlugin 的后世，用于对 bundle.js 进行 chunk 切割(webpack 的内置插件)</span><br><span class="line">- <span class="string">`DllPlugin`</span>: 将模块预先编译，它会在第一次编译的时候将配置好的需要预先编译的模块编译在缓存中，第二次编译的时候，解析到这些模块就直接使用缓存，而不是去编译这些模块(webpack 的内置插件)</span><br><span class="line">- <span class="string">`DllReferencePlugin`</span>: 将预先编译好的模块关联到当前编译中，当 webpack 解析到这些模块时，会直接使用预先编译好的模块(webpack 的内置插件)</span><br><span class="line">- <span class="string">`HotModuleReplacementPlugin`</span>: 实现局部热加载(刷新)，区别与在 webpack-dev-server 的全局刷新(webpack 的内置插件)</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="Webpack-和-Gulp、Grunt-的不同"><a href="#Webpack-和-Gulp、Grunt-的不同" class="headerlink" title="Webpack 和 Gulp、Grunt 的不同"></a><code>Webpack</code> 和 <code>Gulp、Grunt</code> 的不同</h2><blockquote><p>1.<code>Gulp、Grunt</code><br>     - 轻量化的任务<br>     - 将打包各个阶段称为 <code>task</code>，需要开发者自己去调用打包中各个阶段生成文件之后的 <code>task</code> 任务（串行执行）<br>  2. <code>Webpack</code><br>     - 打包大型应用<br>     - Webpack<code>打包过程中会发布各个事件，开发者只要在这些事件阶段中通过</code>Webpack<code>提供的</code>API` 修改 编译产物。不需要开发者掌握整个打包流程中各个阶段如何工作（管理好自己需要管理的那部分即可）</p></blockquote><h2 id="如何看待-Webpack-和-Rollup"><a href="#如何看待-Webpack-和-Rollup" class="headerlink" title="如何看待 Webpack 和 Rollup"></a>如何看待 <code>Webpack</code> 和 <code>Rollup</code></h2><blockquote><ol><li><code>Webpack</code> 是大型应用的打包，输出大量文件以及它们之间如何引用</li><li><code>rollup</code> 是 <code>JavaScript</code> 类库的打包（注重最终输出一个 <code>js</code> 文件）</li></ol></blockquote><h2 id="如果要将-vue-文件中的-css-全部提取到一个-css-文件中，为什么使用-plugin，而不是-loader？"><a href="#如果要将-vue-文件中的-css-全部提取到一个-css-文件中，为什么使用-plugin，而不是-loader？" class="headerlink" title="如果要将 .vue 文件中的 css 全部提取到一个 .css 文件中，为什么使用 plugin，而不是 loader？"></a>如果要将 <code>.vue</code> 文件中的 <code>css</code> 全部提取到一个 <code>.css</code> 文件中，为什么使用 <code>plugin</code>，而不是 <code>loader</code>？</h2><blockquote><p>答：<code>plugin</code> 可以在 <code>Webpack</code> 的 生命周期中执行，可以获取到编译完成后的所有文件，在合适的时机通过 <code>Webpack</code> 提供的 <code>API</code> 改变输出结果。<code>loader</code> 用来加载和编译转换文件，不适合做文件内容抽取和合并</p></blockquote><h2 id="webpack-性能优化"><a href="#webpack-性能优化" class="headerlink" title="webpack 性能优化"></a>webpack 性能优化</h2><p>  <strong>开发环境</strong><br>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 优化代码调试(选择合适 <span class="string">`source-map`</span>)</span><br><span class="line">       - source-map: 外部</span><br><span class="line">       - inline-source-map: 内联；<span class="string">`内联和外部的区别：外部生成了文件，内联没有，内联构建速度会更快`</span></span><br><span class="line">       - hidden-source-map: 外部</span><br><span class="line">       - evel-source-map: 内联；<span class="string">`eval-source-map 和 inline-source-map 的区别：inline-source-map只会生成一个内联 sourceMap，eval-source-map 每个文件都会生成一个 sourceMap`</span></span><br><span class="line">       - nosource-source-map: 外部</span><br><span class="line">       - cheap-source-map: 外部</span><br><span class="line">       - cheap-<span class="built_in">module</span>-source-map: 外部</span><br><span class="line"><span class="number">2.</span> HMR</span><br><span class="line">    <span class="string">`devServer: &#123; hot: true &#125;`</span></span><br><span class="line">    作用：一个模块发生变化，只会重新打包这一个模块（而不是打包所有模块）极大提升构建速度</span><br><span class="line">    - 样式文件：可以使用 HMR 功能：因为 style-loader 内部实现了</span><br><span class="line">    - js 文件：默认不能使用 HMR 功能 --&gt; 需要修改 js 代码，添加支持 HMR 功能的代码</span><br><span class="line">    注意：HMR 功能对 js 的处理，只能处理非入口 js 文件的其它文件</span><br><span class="line">    - html 文件：默认不能使用 HMR 功能，同时会导致问题：html 文件不能热更新了(不用做 HMR)</span><br><span class="line">    解决：修改入口文件，将 html 引入</span><br><span class="line"><span class="number">3.</span> Dll</span><br><span class="line"></span><br><span class="line">    - <span class="string">`DllPlugin`</span>：将模块预先编译，只需编译一次（不易变的文件，一般为各类库，如：vue.js, axios。需要在 externals 中声明 build 被 DllPlugin 预编译的库）</span><br><span class="line">    - <span class="string">`DllReferencePlugin`</span>：将预先编译好的模块关联到当前编译中 (将通过 DllPlugin 编译好的文件引入到 index.html 中)</span><br><span class="line"><span class="number">4.</span> 开启缓存</span><br><span class="line">    - babel 缓存</span><br><span class="line">    - <span class="string">`cacheDirectory：true`</span></span><br><span class="line">    |- 让第二次打包构建速度更快</span><br><span class="line">    - 文件资源缓存</span><br><span class="line">    - _<span class="string">`hash`</span>_：每次 webpack 构建时会生成一个唯一的 hash 值</span><br><span class="line">    问题：因为 js 和 css 同时使用一个 hash 值</span><br><span class="line">    |- 如果重新打包，会导致所有缓存失效。（可能我却只改动一个文件）</span><br><span class="line">    - _<span class="string">`chunkhash`</span>_：根据 chunk 生成的 hash 值。如果打包来源于同一个 chunk，那么 hash 值就一样</span><br><span class="line">    问题：js 和 css 的 hash 值还是一样的</span><br><span class="line">    |- 因为 css 是在 js 中被引入的，所以同属于一个 chunk</span><br><span class="line">    - _<span class="string">`contenthash`</span>_：根据文件的内容生成 hash 值。不同文件 hash 值一定不一样</span><br><span class="line">    |- 让代码上线运行缓存更好使用</span><br><span class="line"><span class="number">5.</span> 开启多线程</span><br><span class="line">    - <span class="string">`HappyPack`</span>：多线程编译，加快编译速度(加快 loader 的编译速度)，不建议与 thread-loader 一起使用</span><br><span class="line">    - <span class="string">`thread-loader`</span>：把这个 loader 放置在其他 loader 之前， 放置在这个 loader 之后的 loader 就会在一个单独的 worker 池(worker pool)中运行</span><br><span class="line"></span><br><span class="line">    <span class="number">1.</span> 使用 oneOf 匹配 loader</span><br><span class="line">    <span class="number">2.</span> tree shaking</span><br><span class="line">    - 去除无用代码</span><br><span class="line">    - 前提：<span class="number">1</span>、必须使用 es6 模块化；<span class="number">2</span>、开启 production 环境</span><br><span class="line">    - 作用：减少代码体积</span><br><span class="line">    - 在 <span class="string">`package.json`</span> 中配置</span><br><span class="line"> </span><br><span class="line">    <span class="string">&quot;sideEffects&quot;</span>: <span class="literal">false</span> 所有代码都没有副作用（都可以进行tree shaking）</span><br><span class="line">    问题：可能会把css / @babel/polyfill（副作用）文件干掉</span><br><span class="line">    <span class="string">&quot;sideEffects&quot;</span>: [<span class="string">&quot;*.css&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> 多入口打包</span><br></pre></td></tr></table></figure><br>  <strong>生产环境优化</strong><br>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="number">1.</span> 比开发环境多一个文件压缩</span><br><span class="line">- <span class="string">`uglifyjs-webpack-plugin`</span>：用于 js 压缩</span><br><span class="line">- <span class="string">`mini-css-extract-plugin`</span>：可以将样式文件从 bundle.js 抽离出来一个文件</span><br><span class="line">- <span class="string">`optimize-css-assets-webpack-plugin`</span>：css 压缩，主要使用 cssnano 压缩器</span><br><span class="line"><span class="number">1.</span> 其余内容同上（开发环境）</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 构建工具 </category>
          
          <category> Webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js 高频知识点-目录</title>
      <link href="/39558/"/>
      <url>/39558/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><ul><li><a href="/53408/#%E4%BB%8B%E7%BB%8D-js-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">1. 介绍 js 的基本数据类型。</a></li><li><a href="/53408/#javascript-%E6%9C%89%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%E4%BD%A0%E8%83%BD%E7%94%BB%E4%B8%80%E4%B8%8B%E4%BB%96%E4%BB%AC%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE%E5%90%97">2. JavaScript 有几种类型的值？你能画一下他们的内存图吗？</a></li><li><a href="/53408/#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A0%86%E4%BB%80%E4%B9%88%E6%98%AF%E6%A0%88%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB">3. 什么是堆？什么是栈？它们之间有什么区别和联系？</a></li><li><a href="/53408/#%E5%86%85%E9%83%A8%E5%B1%9E%E6%80%A7-class-%E6%98%AF%E4%BB%80%E4%B9%88">4. 内部属性 Class 是什么？</a></li><li><a href="/53408/#%E4%BB%8B%E7%BB%8D-js-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1">5. 介绍 js 有哪些内置对象？</a></li><li><a href="/53408/#undefined-%E4%B8%8E-undeclared-%E7%9A%84%E5%8C%BA%E5%88%AB">6. undefined 与 undeclared 的区别？</a></li><li><a href="/53408/#null-%E5%92%8C-undefined-%E7%9A%84%E5%8C%BA%E5%88%AB">7. null 和 undefined 的区别？</a></li><li><a href="/53408/#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E5%AE%89%E5%85%A8%E7%9A%84-undefined-%E5%80%BC">8. 如何获取安全的 undefined 值？</a></li><li><a href="/53408/#%E8%AF%B4%E5%87%A0%E6%9D%A1%E5%86%99-javascript-%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A7%84%E8%8C%83">9. 说几条写 JavaScript 的基本规范？</a></li><li><a href="/53408/#JavaScript-%E5%8E%9F%E5%9E%8B%EF%BC%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%EF%BC%9F-%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9">10. JavaScript 原型，原型链？ 有什么特点？</a></li></ul><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><ul><li><a href="/53725/#js-%E8%8E%B7%E5%8F%96%E5%8E%9F%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95">11. js 获取原型的方法？</a></li><li><a href="/53725/#%E5%9C%A8-js-%E4%B8%AD%E4%B8%8D%E5%90%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E5%AD%97%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E5%BC%8F">12. 在 js 中不同进制数字的表示方式</a></li><li><a href="/53725/#js-%E4%B8%AD%E6%95%B4%E6%95%B0%E7%9A%84%E5%AE%89%E5%85%A8%E8%8C%83%E5%9B%B4%E6%98%AF%E5%A4%9A%E5%B0%91">13. js 中整数的安全范围是多少？</a></li><li><a href="/53725/#typeof-nan-%E7%9A%84%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88">14. typeof NaN 的结果是什么？</a></li><li><a href="/53725/#isnan-%E5%92%8C-numberisnan-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB">15. isNaN 和 Number.isNaN 函数的区别？</a></li><li><a href="/53725/#array-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%E5%80%BC%E6%97%B6%E7%9A%84%E8%A1%A8%E7%8E%B0">16. Array 构造函数只有一个参数值时的表现？</a></li><li><a href="/53725/#%E5%85%B6%E4%BB%96%E5%80%BC%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99">17. 其他值到字符串的转换规则？</a></li><li><a href="/53725/#%E5%85%B6%E4%BB%96%E5%80%BC%E5%88%B0%E6%95%B0%E5%AD%97%E5%80%BC%E7%9A%84%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99">18. 其他值到数字值的转换规则？</a></li><li><a href="/53725/#%E5%85%B6%E4%BB%96%E5%80%BC%E5%88%B0%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%E7%9A%84%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99">19. 其他值到布尔类型的值的转换规则？</a></li><li><a href="/53725/#-%E5%92%8C--%E7%9A%84-valueof-%E5%92%8C-tostring-%E7%9A%84%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88">20. {} 和 [] 的 valueOf 和 toString 的结果是什么？</a><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2></li><li><a href="/4380/#%E4%BB%80%E4%B9%88%E6%98%AF%E5%81%87%E5%80%BC%E5%AF%B9%E8%B1%A1">21. 什么是假值对象？</a></li><li><a href="/4380/#-%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E4%BD%9C%E7%94%A8">22. ~ 操作符的作用？</a></li><li><a href="/4380/#%E8%A7%A3%E6%9E%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E5%92%8C%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E5%AD%97%E7%9A%84%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E9%83%BD%E6%98%AF%E6%95%B0%E5%AD%97%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">23. 解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？</a></li><li><a href="/4380/#-%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E4%BA%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8B%BC%E6%8E%A5">24. 操作符什么时候用于字符串的拼接？</a></li><li><a href="/4380/#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%8F%91%E7%94%9F%E5%B8%83%E5%B0%94%E5%80%BC%E7%9A%84%E9%9A%90%E5%BC%8F%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">25. 什么情况下会发生布尔值的隐式强制类型转换？</a></li><li><a href="/4380/#-%E5%92%8C--%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC">26. || 和 &amp;&amp; 操作符的返回值？</a></li><li><a href="/4380/#symbol-%E5%80%BC%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">27. Symbol 值的强制类型转换？</a></li><li><a href="/4380/#-%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99">28. == 操作符的强制类型转换规则？</a></li><li><a href="/4380/#%E5%A6%82%E4%BD%95%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%95%B0%E5%AD%97%E4%BE%8B%E5%A6%82-123b">29. 如何将字符串转化为数字，例如 ‘12.3b’?</a></li><li><a href="/4380/#%E5%A6%82%E4%BD%95%E5%B0%86%E6%B5%AE%E7%82%B9%E6%95%B0%E7%82%B9%E5%B7%A6%E8%BE%B9%E7%9A%84%E6%95%B0%E6%AF%8F%E4%B8%89%E4%BD%8D%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E9%80%97%E5%8F%B7%E5%A6%821200000011%E8%BD%AC%E5%8C%96%E4%B8%BA1200000011">30. 如何将浮点数点左边的数每三位添加一个逗号，如 12000000.11 转化为『12,000,000.11』?</a><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2></li><li><a href="/54109/#%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">31. 常用正则表达式</a></li><li><a href="/54109/#%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%9A%84%E5%90%84%E7%A7%8D%E6%96%B9%E6%B3%95">32. 生成随机数的各种方法？</a></li><li><a href="/54109/#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%8E%92%E5%BA%8F">33. 如何实现数组的随机排序？</a></li><li><a href="/54109/#javascript-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F">34. javascript 创建对象的几种方式？</a></li><li><a href="/54109/#javascript-%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">35. JavaScript 继承的几种实现方式？</a></li><li><a href="/54109/#%E5%AF%84%E7%94%9F%E5%BC%8F%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF%E7%9A%84%E5%AE%9E%E7%8E%B0">36. 寄生式组合继承的实现？</a></li><li><a href="/54109/#javascript-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE">37. Javascript 的作用域链？</a></li><li><a href="/54109/#%E8%B0%88%E8%B0%88-this-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3">38. 谈谈 This 对象的理解。</a></li><li><a href="/54109/#eval-%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84">39. eval 是做什么的？</a></li><li><a href="/54109/#%E4%BB%80%E4%B9%88%E6%98%AF-dom-%E5%92%8C-bom">40. 什么是 DOM 和 BOM？</a><h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2></li><li><a href="/5020/#%E5%86%99%E4%B8%80%E4%B8%AA%E9%80%9A%E7%94%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BE%A6%E5%90%AC%E5%99%A8%E5%87%BD%E6%95%B0">41. 写一个通用的事件侦听器函数。</a></li><li><a href="/5020/#%E4%BA%8B%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88ie-%E4%B8%8E%E7%81%AB%E7%8B%90%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB-%E5%A6%82%E4%BD%95%E9%98%BB%E6%AD%A2%E5%86%92%E6%B3%A1">42. 事件是什么？IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？</a></li><li><a href="/5020/#%E4%B8%89%E7%A7%8D%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88">43. 三种事件模型是什么？</a></li><li><a href="/5020/#%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E6%98%AF%E4%BB%80%E4%B9%88">44. 事件委托是什么？</a></li><li><a href="#1-2-3mapparseint-%E7%AD%94%E6%A1%88%E6%98%AF%E5%A4%9A%E5%B0%91">45. [“1”, “2”, “3”].map(/5020/parseInt 答案是多少？</a>)</li><li><a href="/5020/#%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%AE%83">46. 什么是闭包，为什么要用它？</a></li><li><a href="/5020/#javascript-%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84-use-strict-%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D--%E4%BD%BF%E7%94%A8%E5%AE%83%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">47. javascript 代码中的 “use strict”; 是什么意思 ? 使用它区别是什么？</a></li><li><a href="/5020/#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%B1%9E%E4%BA%8E%E6%9F%90%E4%B8%AA%E7%B1%BB">48. 如何判断一个对象是否属于某个类？</a></li><li><a href="/5020/#instanceof-%E7%9A%84%E4%BD%9C%E7%94%A8">49. instanceof 的作用？</a></li><li><a href="/5020/#new-%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%85%B7%E4%BD%93%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88%E5%91%A2%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0">50. new 操作符具体干了什么呢？如何实现？</a><h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2></li><li><a href="/4828/#javascript%E4%B8%AD%E6%9C%89%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E6%97%B6%E5%AF%B9%E8%B1%A1%E6%9F%A5%E6%89%BE%E6%97%B6%E6%B0%B8%E8%BF%9C%E4%B8%8D%E4%BC%9A%E5%8E%BB%E6%9F%A5%E6%89%BE%E5%8E%9F%E5%9E%8B%E8%BF%99%E4%B8%AA%E5%87%BD%E6%95%B0%E6%98%AF">51. Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？</a></li><li><a href="/4828/#%E5%AF%B9%E4%BA%8E-json-%E7%9A%84%E4%BA%86%E8%A7%A3">52. 对于 JSON 的了解？</a></li><li><a href="/4828/#js-%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B">54. js 延迟加载的方式有哪些？</a></li><li><a href="/4828/#ajax-%E6%98%AF%E4%BB%80%E4%B9%88-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAajax">55. Ajax 是什么? 如何创建一个 Ajax？</a></li><li><a href="/4828/#%E8%B0%88%E4%B8%80%E8%B0%88%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6">56. 谈一谈浏览器的缓存机制？</a></li><li><a href="/4828/#ajax-%E8%A7%A3%E5%86%B3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98">57. Ajax 解决浏览器缓存问题？</a></li><li><a href="/4828/#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB">58. 同步和异步的区别？</a></li><li><a href="/4828/#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%90%8C%E6%BA%90%E6%94%BF%E7%AD%96">59. 什么是浏览器的同源政策？</a></li><li><a href="/4828/#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98">60. 如何解决跨域问题？</a><h2 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h2></li><li><a href="/53789/#%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91%E6%97%B6%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86-cookie">61. 服务器代理转发时，该如何处理 cookie？</a></li><li><a href="/53789/#%E7%AE%80%E5%8D%95%E8%B0%88%E4%B8%80%E4%B8%8B-cookie-">62. 简单谈一下 cookie ？</a></li><li><a href="/53789/#%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E6%80%8E%E4%B9%88%E5%81%9A">63. 模块化开发怎么做？</a></li><li><a href="/53789/#js-%E7%9A%84%E5%87%A0%E7%A7%8D%E6%A8%A1%E5%9D%97%E8%A7%84%E8%8C%83">64. js 的几种模块规范？</a></li><li><a href="/53789/#amd-%E5%92%8C-cmd-%E8%A7%84%E8%8C%83%E7%9A%84%E5%8C%BA%E5%88%AB">65. AMD 和 CMD 规范的区别？</a></li><li><a href="/53789/#es6-%E6%A8%A1%E5%9D%97%E4%B8%8E-commonjs-%E6%A8%A1%E5%9D%97amdcmd-%E7%9A%84%E5%B7%AE%E5%BC%82">66. ES6 模块与 CommonJS 模块、AMD、CMD 的差异。</a></li><li><a href="/53789/#requirejs-%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%E5%A6%82%E4%BD%95%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%A4%9A%E6%AC%A1%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%A6%82%E4%BD%95-%E7%BC%93%E5%AD%98%E7%9A%84">67. requireJS 的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？）</a></li><li><a href="/53789/#js-%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E8%BD%AE%E5%AD%90%E6%80%8E%E4%B9%88%E9%80%A0%E4%B9%9F%E5%B0%B1%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E5%99%A8">68. JS 模块加载器的轮子怎么造，也就是如何实现一个模块加载器？</a></li><li><a href="/53789/#ecmascript6-%E6%80%8E%E4%B9%88%E5%86%99-class%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0-class-%E8%BF%99%E7%A7%8D%E4%B8%9C%E8%A5%BF">69. ECMAScript6 怎么写 class，为什么会出现 class 这种东西?</a></li><li><a href="/53789/#documenwrite-%E5%92%8C-innerhtml-%E7%9A%84%E5%8C%BA%E5%88%AB">70. documen.write 和 innerHTML 的区别？</a><h2 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h2></li><li><a href="/54877/#dom-%E6%93%8D%E4%BD%9C%E6%80%8E%E6%A0%B7%E6%B7%BB%E5%8A%A0%E7%A7%BB%E9%99%A4%E7%A7%BB%E5%8A%A8%E5%A4%8D%E5%88%B6%E5%88%9B%E5%BB%BA%E5%92%8C%E6%9F%A5%E6%89%BE%E8%8A%82%E7%82%B9">71. DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？</a></li><li><a href="/54877/#innerhtml-%E4%B8%8E-outerhtml-%E7%9A%84%E5%8C%BA%E5%88%AB">72. innerHTML 与 outerHTML 的区别？</a></li><li><a href="//54877/#call-%E5%92%8C-apply-%E7%9A%84%E5%8C%BA%E5%88%AB">73. .call 和.apply的区别？</a>)</li><li><a href="/54877/#javascript-%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89">74. JavaScript 类数组对象的定义？</a></li><li><a href="/54877/#%E6%95%B0%E7%BB%84%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8E%9F%E7%94%9F%E6%96%B9%E6%B3%95%E5%88%97%E4%B8%BE%E4%B8%80%E4%B8%8B">75. 数组和对象有哪些原生方法，列举一下？</a></li><li><a href="/54877/#%E6%95%B0%E7%BB%84%E7%9A%84-fill-%E6%96%B9%E6%B3%95">76. 数组的 fill 方法？</a></li><li><a href="/54877/#-%E7%9A%84%E9%95%BF%E5%BA%A6">77. [,,,] 的长度？</a></li><li><a href="/54877/#javascript-%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87">78. JavaScript 中的作用域与变量声明提升？</a></li><li><a href="/54877/#%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84-javascript-">79. 如何编写高性能的 Javascript ？</a></li><li><a href="/54877/#%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-v8-%E5%BC%95%E6%93%8E%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6">80. 简单介绍一下 V8 引擎的垃圾回收机制</a><h2 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h2></li><li><a href="/5788/#%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%E4%BC%9A%E9%80%A0%E6%88%90%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F">81. 哪些操作会造成内存泄漏？</a></li><li><a href="/5788/#%E9%9C%80%E6%B1%82%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E6%93%8D%E4%BD%9C%E4%B8%8D%E4%BC%9A%E6%95%B4%E9%A1%B5%E5%88%B7%E6%96%B0%E7%9A%84%E7%BD%91%E7%AB%99%E5%B9%B6%E4%B8%94%E8%83%BD%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E5%89%8D%E8%BF%9B%E5%90%8E%E9%80%80%E6%97%B6%E6%AD%A3%E7%A1%AE%E5%93%8D%E5%BA%94%E7%BB%99%E5%87%BA%E4%BD%A0%E7%9A%84%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88">82. 需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？</a></li><li><a href="/5788/#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E8%84%9A%E6%9C%AC%E8%BF%90%E8%A1%8C%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%98%E6%98%AF-node-%E7%8E%AF%E5%A2%83%E4%B8%AD%E9%98%BF%E9%87%8C">83. 如何判断当前脚本运行在浏览器还是 node 环境中？（阿里）</a></li><li><a href="/5788/#%E6%8A%8A-script-%E6%A0%87%E7%AD%BE%E6%94%BE%E5%9C%A8%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%9C%80%E5%BA%95%E9%83%A8%E7%9A%84-body-%E5%B0%81%E9%97%AD%E4%B9%8B%E5%89%8D%E5%92%8C%E5%B0%81%E9%97%AD%E4%B9%8B%E5%90%8E%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BC%9A%E5%A6%82%E4%BD%95%E8%A7%A3%E6%9E%90%E5%AE%83%E4%BB%AC">84. 把 script 标签放在页面的最底部的 body 封闭之前和封闭之后有什么区别？浏览器会如何解析它们？</a></li><li><a href="/5788/#%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%9C%89%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4%E6%98%AF%E5%A4%9A%E4%B9%85%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89-%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E8%BF%99%E4%B8%AA%E5%BB%B6%E6%97%B6">85. 移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？</a></li><li><a href="/5788/#%E4%BB%80%E4%B9%88%E6%98%AF%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%80%82%E5%90%88%E4%BD%BF%E7%94%A8%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9">86. 什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？</a></li><li><a href="/5788/#%E6%A3%80%E6%B5%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E7%89%88%E6%9C%AC%E7%89%88%E6%9C%AC%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F">88. 检测浏览器版本版本有哪些方式？</a></li><li><a href="/5788/#%E4%BB%80%E4%B9%88%E6%98%AF-polyfill-">89. 什么是 Polyfill ？</a></li><li><a href="/5788/#%E4%BD%BF%E7%94%A8-js-%E5%AE%9E%E7%8E%B0%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E6%89%A9%E5%B1%95%E5%90%8D">90. 使用 JS 实现获取文件扩展名？</a><h2 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h2></li><li><a href="/48401/#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-js-%E7%9A%84%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96">91. 介绍一下 js 的节流与防抖？</a></li><li><a href="/48401/#Object-is-%E4%B8%8E%E5%8E%9F%E6%9D%A5%E7%9A%84%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C%E7%AC%A6-%E2%80%9C-%E2%80%9D%E3%80%81%E2%80%9C-%E2%80%9D-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F">92. Object.is与原来的比较操作符 “===”、“==” 的区别？</a></li><li><a href="/48401/#escapeencodeuriencodeuricomponent-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">93. escape,encodeURI,encodeURIComponent 有什么区别？</a></li><li><a href="/48401/#unicode-%E5%92%8C-utf-8-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB">94. Unicode 和 UTF-8 之间的关系？</a></li><li><a href="/48401/#js-%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%98%AF%E4%BB%80%E4%B9%88">95. js 的事件循环是什么？</a></li><li><a href="/48401/#js-%E4%B8%AD%E7%9A%84%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%AE%9E%E7%8E%B0">96. js 中的深浅拷贝实现？</a></li><li><a href="/48401/#%E6%89%8B%E5%86%99-callapply-%E5%8F%8A-bind-%E5%87%BD%E6%95%B0">97. 手写 call、apply 及 bind 函数</a></li><li><a href="/48401/#%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96%E7%9A%84%E5%AE%9E%E7%8E%B0">98. 函数柯里化的实现</a></li><li><a href="/48401/#%E4%B8%BA%E4%BB%80%E4%B9%88-01--02--03%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98">99. 为什么 0.1 0.2 != 0.3？如何解决这个问题？</a></li><li><a href="/48401/#%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E5%92%8C%E8%A1%A5%E7%A0%81%E7%9A%84%E4%BB%8B%E7%BB%8D">100. 原码、反码和补码的介绍</a><h2 id="第十一章"><a href="#第十一章" class="headerlink" title="第十一章"></a>第十一章</h2></li><li><a href="/32208/#toprecision-%E5%92%8C-tofixed-%E5%92%8C-mathround-%E7%9A%84%E5%8C%BA%E5%88%AB">101. toPrecision 和 toFixed 和 Math.round 的区别？</a></li><li><a href="/32208/#%E4%BB%80%E4%B9%88%E6%98%AF-xss-%E6%94%BB%E5%87%BB%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83-xss-%E6%94%BB%E5%87%BB">102. 什么是 XSS 攻击？如何防范 XSS 攻击？</a></li><li><a href="/32208/#%E4%BB%80%E4%B9%88%E6%98%AF-csp">103. 什么是 CSP？</a></li><li><a href="/32208/#%E4%BB%80%E4%B9%88%E6%98%AF-csrf-%E6%94%BB%E5%87%BB%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83-csrf-%E6%94%BB%E5%87%BB">104. 什么是 CSRF 攻击？如何防范 CSRF 攻击？</a></li><li><a href="/32208/#%E4%BB%80%E4%B9%88%E6%98%AF-samesite-cookie-%E5%B1%9E%E6%80%A7">105. 什么是 Samesite Cookie 属性？</a></li><li><a href="/32208/#%E4%BB%80%E4%B9%88%E6%98%AF%E7%82%B9%E5%87%BB%E5%8A%AB%E6%8C%81%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83%E7%82%B9%E5%87%BB%E5%8A%AB%E6%8C%81">106. 什么是点击劫持？如何防范点击劫持？</a></li><li><a href="/32208/#sql-%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB">107. SQL 注入攻击？</a></li><li><a href="/32208/#%E4%BB%80%E4%B9%88%E6%98%AF-mvvm%E6%AF%94%E4%B9%8B-mvc-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E4%BB%80%E4%B9%88%E5%8F%88%E6%98%AF-mvp-">108. 什么是 MVVM？比之 MVC 有什么区别？什么又是 MVP ？</a></li><li><a href="/32208/#vue-%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86">109. vue 双向数据绑定原理？</a></li><li><a href="/32208/#objectdefineproperty-%E4%BB%8B%E7%BB%8D">110. Object.defineProperty 介绍？</a><h2 id="第十二章"><a href="#第十二章" class="headerlink" title="第十二章"></a>第十二章</h2></li><li><a href="/31888/#%E4%BD%BF%E7%94%A8-Object-defineProperty-%E6%9D%A5%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9%EF%BC%9F">111. 使用 Object.defineProperty来进行数据劫持有什么缺点？</a></li><li><a href="/31888/#%E4%BB%80%E4%B9%88%E6%98%AF-virtual-dom%E4%B8%BA%E4%BB%80%E4%B9%88-virtual-dom-%E6%AF%94%E5%8E%9F%E7%94%9F-dom-%E5%BF%AB">112. 什么是 Virtual DOM？为什么 Virtual DOM 比原生 DOM 快？</a></li><li><a href="/31888/#%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AA-dom-%E6%A0%91%E7%9A%84%E5%B7%AE%E5%BC%82">113. 如何比较两个 DOM 树的差异？</a></li><li><a href="/31888/#%E4%BB%80%E4%B9%88%E6%98%AF-requestanimationframe-">114. 什么是 requestAnimationFrame ？</a></li><li><a href="/31888/#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-webpack-%E7%9A%84%E7%9C%8B%E6%B3%95">115. 谈谈你对 webpack 的看法</a></li><li><a href="/31888/#offsetwidthoffsetheightclientwidthclientheight-%E4%B8%8E-scrollwidthscrollheight-%E7%9A%84%E5%8C%BA%E5%88%AB">116. offsetWidth/offsetHeight,clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别？</a></li><li><a href="/31888/#%E8%B0%88%E4%B8%80%E8%B0%88%E4%BD%A0%E7%90%86%E8%A7%A3%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B">117. 谈一谈你理解的函数式编程？</a></li><li><a href="/31888/#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">118. 异步编程的实现方式？</a></li><li><a href="/31888/#js-%E5%8A%A8%E7%94%BB%E4%B8%8E-css-%E5%8A%A8%E7%94%BB%E5%8C%BA%E5%88%AB%E5%8F%8A%E7%9B%B8%E5%BA%94%E5%AE%9E%E7%8E%B0">119. Js 动画与 CSS 动画区别及相应实现</a></li><li><a href="/31888/#get-%E8%AF%B7%E6%B1%82%E4%BC%A0%E5%8F%82%E9%95%BF%E5%BA%A6%E7%9A%84%E8%AF%AF%E5%8C%BA">120. get 请求传参长度的误区</a><h2 id="第十三章"><a href="#第十三章" class="headerlink" title="第十三章"></a>第十三章</h2></li><li><a href="/48209/#url-%E5%92%8C-uri-%E7%9A%84%E5%8C%BA%E5%88%AB">121. URL 和 URI 的区别？</a></li><li><a href="/48209/#get-%E5%92%8C-post-%E8%AF%B7%E6%B1%82%E5%9C%A8%E7%BC%93%E5%AD%98%E6%96%B9%E9%9D%A2%E7%9A%84%E5%8C%BA%E5%88%AB">122. get 和 post 请求在缓存方面的区别</a></li><li><a href="/48209/#%E5%9B%BE%E7%89%87%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%A2%84%E5%8A%A0%E8%BD%BD">123. 图片的懒加载和预加载</a></li><li><a href="/48209/#mouseover-%E5%92%8C-mouseenter-%E7%9A%84%E5%8C%BA%E5%88%AB">124. mouseover 和 mouseenter 的区别？</a></li><li><a href="/48209/#js-%E6%8B%96%E6%8B%BD%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0">125. js 拖拽功能的实现</a></li><li><a href="/48209/#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-settimeout-%E5%AE%9E%E7%8E%B0-setinterval%E6%80%8E%E4%B9%88%E6%A8%A1%E6%8B%9F">126. 为什么使用 setTimeout 实现 setInterval？怎么模拟？</a></li><li><a href="/48209/#let-%E5%92%8C-const-%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9">127. let 和 const 的注意点？</a></li><li><a href="/48209/#%E4%BB%80%E4%B9%88%E6%98%AF-rest-%E5%8F%82%E6%95%B0">128. 什么是 rest 参数？</a></li><li><a href="/48209/#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BD%BF%E7%94%A8%E5%B0%BE%E8%B0%83%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84">129. 什么是尾调用，使用尾调用有什么好处？</a></li><li><a href="/48209/#symbol-%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9">130. Symbol 类型的注意点？</a><h2 id="第十四章"><a href="#第十四章" class="headerlink" title="第十四章"></a>第十四章</h2></li><li><a href="/32272/#set-%E5%92%8C-weakset-%E7%BB%93%E6%9E%84">131. Set 和 WeakSet 结构？</a></li><li><a href="/32272/#map-%E5%92%8C-weakmap-%E7%BB%93%E6%9E%84">132. Map 和 WeakMap 结构？</a></li><li><a href="/32272/#%E4%BB%80%E4%B9%88%E6%98%AF-proxy-">133. 什么是 Proxy ？</a></li><li><a href="/32272/#reflect-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%9B%AE%E7%9A%84">134. Reflect 对象创建目的？</a></li><li><a href="/32272/#require-%E6%A8%A1%E5%9D%97%E5%BC%95%E5%85%A5%E7%9A%84%E6%9F%A5%E6%89%BE%E6%96%B9%E5%BC%8F">135. require 模块引入的查找方式？</a></li><li><a href="/32272/#%E4%BB%80%E4%B9%88%E6%98%AF-promise-%E5%AF%B9%E8%B1%A1%E4%BB%80%E4%B9%88%E6%98%AF-promisesa-%E8%A7%84%E8%8C%83">136. 什么是 Promise 对象，什么是 Promises/A 规范？</a></li><li><a href="/32272/#%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA-promise">137. 手写一个 Promise</a></li><li><a href="/32272/#%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%80%E6%94%AF%E6%8C%81%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%97%E4%BD%93%E5%A4%A7%E5%B0%8F">138. 如何检测浏览器所支持的最小字体大小？</a></li><li><a href="/32272/#%E6%80%8E%E4%B9%88%E5%81%9A-js-%E4%BB%A3%E7%A0%81-error-%E7%BB%9F%E8%AE%A1">139. 怎么做 JS 代码 Error 统计？</a></li><li><a href="/32272/#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88">140. 单例模式模式是什么？</a><h2 id="第十五章"><a href="#第十五章" class="headerlink" title="第十五章"></a>第十五章</h2></li><li><a href="/48849/#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88">141. 策略模式是什么？</a></li><li><a href="/48849/#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88">142. 代理模式是什么？</a></li><li><a href="/48849/#%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88">143. 中介者模式是什么？</a></li><li><a href="/48849/#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88">144. 适配器模式是什么？</a></li><li><a href="/48849/#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C">145. 观察者模式和发布订阅模式有什么不同？</a></li><li><a href="/48849/#vue-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%98%AF%E4%BB%80%E4%B9%88">146. Vue 的生命周期是什么？</a></li><li><a href="/48849/#vue-%E7%9A%84%E5%90%84%E4%B8%AA%E7%94%9F%E5%91%BD%E9%98%B6%E6%AE%B5%E6%98%AF%E4%BB%80%E4%B9%88">147. Vue 的各个生命阶段是什么？</a></li><li><a href="/48849/#vue-%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F">148. Vue 组件间的参数传递方式？</a></li><li><a href="/48849/#computed-%E5%92%8C-watch-%E7%9A%84%E5%B7%AE%E5%BC%82">149. computed 和 watch 的差异？</a></li><li><a href="/48849/#vue-router-%E4%B8%AD%E7%9A%84%E5%AF%BC%E8%88%AA%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0">150. vue-router 中的导航钩子函数</a><h2 id="第十六章"><a href="#第十六章" class="headerlink" title="第十六章"></a>第十六章</h2></li><li><a href="/49041/#route-%E5%92%8C-router-%E7%9A%84%E5%8C%BA%E5%88%AB">151. $route 和 $router 的区别？</a></li><li><a href="/49041/#vue-%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6">152. vue 常用的修饰符？</a></li><li><a href="/49041/#vue%E4%B8%AD-key-%E5%80%BC%E7%9A%84%E4%BD%9C%E7%94%A8">153. vue 中 key 值的作用？</a></li><li><a href="/49041/#computed-%E5%92%8C-watch-%E5%8C%BA%E5%88%AB">154. computed 和 watch 区别？</a></li><li><a href="/49041/#keep-alive-%E7%BB%84%E4%BB%B6%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8">155. keep-alive 组件有什么作用？</a></li><li><a href="/49041/#vue-%E4%B8%AD-mixin-%E5%92%8C-mixins-%E5%8C%BA%E5%88%AB">156. vue 中 mixin 和 mixins 区别？</a></li><li><a href="/49041/#%E5%BC%80%E5%8F%91%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D-content-type-">157. 开发中常用的几种 Content-Type ？</a></li><li><a href="/49041/#%E5%A6%82%E4%BD%95%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA-javascript-%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD%E5%87%BD%E6%95%B0">158. 如何封装一个 javascript 的类型判断函数？</a></li><li><a href="/49041/#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%E5%AF%B9%E8%B1%A1">159. 如何判断一个对象是否为空对象？</a></li><li><a href="/49041/#%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85%E5%AE%9E%E7%8E%B0%E6%AF%8F%E9%9A%94%E4%B8%80%E7%A7%92%E6%89%93%E5%8D%B0-1234">160. 使用闭包实现每隔一秒打印 1,2,3,4</a><h2 id="第十七章"><a href="#第十七章" class="headerlink" title="第十七章"></a>第十七章</h2></li><li><a href="/32592/#%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA-jsonp">161. 手写一个 jsonp</a></li><li><a href="/32592/#%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F">162. 手写一个观察者模式？</a></li><li><a href="/32592/#eventemitter-%E5%AE%9E%E7%8E%B0">163. EventEmitter 实现</a></li><li><a href="/32592/#%E4%B8%80%E9%81%93%E5%B8%B8%E8%A2%AB%E4%BA%BA%E8%BD%BB%E8%A7%86%E7%9A%84%E5%89%8D%E7%AB%AFjs%E9%9D%A2%E8%AF%95%E9%A2%98">164. 一道常被人轻视的前端 JS 面试题</a></li><li><a href="/32592/#%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%8F%AF%E7%94%A8%E6%80%A7%E6%97%B6%E9%97%B4%E4%BB%80%E4%B9%88%E6%98%AF-performance-api">165. 如何确定页面的可用性时间，什么是 Performance API？</a></li><li><a href="/32592/#js-%E4%B8%AD%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99">166. js 中的命名规则</a></li><li><a href="/32592/#js-%E8%AF%AD%E5%8F%A5%E6%9C%AB%E5%B0%BE%E5%88%86%E5%8F%B7%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E7%9C%81%E7%95%A5">167. js 语句末尾分号是否可以省略？</a></li><li><a href="#objectassign">168. Object.assign(/32592/</a>)</li><li><a href="/32592/#mathceil-%E5%92%8C-mathfloor">169. Math.ceil 和 Math.floor</a></li><li><a href="/32592/#js-for-%E5%BE%AA%E7%8E%AF%E6%B3%A8%E6%84%8F%E7%82%B9">170. js for 循环注意点</a><h2 id="第十八章"><a href="#第十八章" class="headerlink" title="第十八章"></a>第十八章</h2></li><li><a href="/31504/#%E4%B8%80%E4%B8%AA%E5%88%97%E8%A1%A8%E5%81%87%E8%AE%BE%E6%9C%89100000%E4%B8%AA%E6%95%B0%E6%8D%AE%E8%BF%99%E4%B8%AA%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E">171. 一个列表，假设有 100000 个数据，这个该怎么办？</a></li><li><a href="/31504/#js-%E4%B8%AD%E5%80%92%E8%AE%A1%E6%97%B6%E7%9A%84%E7%BA%A0%E5%81%8F%E5%AE%9E%E7%8E%B0">172. js 中倒计时的纠偏实现？</a></li><li><a href="/31504/#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F">173. 进程间通信的方式？</a></li><li><a href="/31504/#%E5%A6%82%E4%BD%95%E6%9F%A5%E6%89%BE%E4%B8%80%E7%AF%87%E8%8B%B1%E6%96%87%E6%96%87%E7%AB%A0%E4%B8%AD%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%9C%80%E9%AB%98%E7%9A%84%E5%8D%95%E8%AF%8D">174. 如何查找一篇英文文章中出现频率最高的单词？</a></li><li><a href="/31504/#elegetelementsbyclassname%E5%92%8Celequeryselectorall%E7%9A%84%E5%8C%BA%E5%88%AB">175. ele.getElementsByClassName和ele.querySelectorAll的区别？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端面试 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS面试知识点总结(十八)</title>
      <link href="/31504/"/>
      <url>/31504/</url>
      
        <content type="html"><![CDATA[<h2 id="一个列表，假设有-100000-个数据，这个该怎么办？"><a href="#一个列表，假设有-100000-个数据，这个该怎么办？" class="headerlink" title="一个列表，假设有 100000 个数据，这个该怎么办？"></a>一个列表，假设有 100000 个数据，这个该怎么办？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我们需要思考的问题：该处理是否必须同步完成？数据是否必须按顺序完成？</span><br><span class="line"></span><br><span class="line">解决办法：</span><br><span class="line"></span><br><span class="line">（1）将数据分页，利用分页的原理，每次服务器端只返回一定数目的数据，浏览器每次只对一部分进行加载。</span><br><span class="line"></span><br><span class="line">（2）使用懒加载的方法，每次加载一部分数据，其余数据当需要使用时再去加载。</span><br><span class="line"></span><br><span class="line">（3）使用数组分块技术，基本思路是为要处理的项目创建一个队列，然后设置定时器每过一段时间取出一部分数据，然后再使用定时器取出下一个要处理的项目进行处理，接着再设置另一个定时器。</span><br></pre></td></tr></table></figure><h2 id="js-中倒计时的纠偏实现？"><a href="#js-中倒计时的纠偏实现？" class="headerlink" title="js 中倒计时的纠偏实现？"></a>js 中倒计时的纠偏实现？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在前端实现中我们一般通过 setTimeout 和 setInterval 方法来实现一个倒计时效果。但是使用这些方法会存在时间偏差的问题，这是由于 js 的程序执行机制造成的，setTimeout 和 setInterval 的作用是隔一段时间将回调事件加入到事件队列中，因此事件并不是立即执行的，它会等到当前执行栈为空的时候再取出事件执行，因此事件等待执行的时间就是造成误差的原因。</span><br><span class="line"></span><br><span class="line">一般解决倒计时中的误差的有这样两种办法：</span><br><span class="line"></span><br><span class="line">（1）第一种是通过前端定时向服务器发送请求获取最新的时间差，以此来校准倒计时时间。</span><br><span class="line"></span><br><span class="line">（2）第二种方法是前端根据偏差时间来自动调整间隔时间的方式来实现的。这一种方式首先是以 setTimeout 递归的方式来实现倒计时，然后通过一个变量来记录已经倒计时的秒数。每一次函数调用的时候，首先将变量加一，然后根据这个变量和每次的间隔时间，我们就可以计算出此时无偏差时应该显示的时间。然后将当前的真实时间与这个时间相减，这样我们就可以得到时间的偏差大小，因此我们在设置下一个定时器的间隔大小的时候，我们就从间隔时间中减去这个偏差大小，以此来实现由于程序执行所造成的时间误差的纠正。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5badf8305188255c8e728adc">《JavaScript 前端倒计时纠偏实现》</a></p><ol><li>  进程间通信的方式？</li></ol><ul><li>1.管道通信</li><li>2.消息队列通信</li><li>3.信号量通信</li><li>4.信号通信</li><li>5.共享内存通信</li><li>6.套接字通信</li></ul><p>详细资料可以参考：<br><a href="https://blog.csdn.net/violet_echo_0908/article/details/51201278">《进程间 8 种通信方式详解》</a><br><a href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html">《进程与线程的一个简单解释》</a></p><h2 id="如何查找一篇英文文章中出现频率最高的单词？"><a href="#如何查找一篇英文文章中出现频率最高的单词？" class="headerlink" title="如何查找一篇英文文章中出现频率最高的单词？"></a>如何查找一篇英文文章中出现频率最高的单词？</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findMostWord</span>(<span class="params">article</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 合法性判断</span></span><br><span class="line">  <span class="keyword">if</span> (!article) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 参数处理</span></span><br><span class="line">  article = article.trim().toLowerCase();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> wordList = article.match(<span class="regexp">/[a-z]+/g</span>),</span><br><span class="line">    visited = [],</span><br><span class="line">    maxNum = <span class="number">0</span>,</span><br><span class="line">    maxWord = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  article = <span class="string">&quot; &quot;</span> + wordList.join(<span class="string">&quot;  &quot;</span>) + <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历判断单词出现次数</span></span><br><span class="line">  wordList.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (visited.indexOf(item) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 加入 visited </span></span><br><span class="line">      visited.push(item);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> word = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot; &quot;</span> + item + <span class="string">&quot; &quot;</span>, <span class="string">&quot;g&quot;</span>),</span><br><span class="line">        num = article.match(word).length;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (num &gt; maxNum) &#123;</span><br><span class="line">        maxNum = num;</span><br><span class="line">        maxWord = item;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> maxWord + <span class="string">&quot;  &quot;</span> + maxNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ele-getElementsByClassName和ele-querySelectorAll的区别？"><a href="#ele-getElementsByClassName和ele-querySelectorAll的区别？" class="headerlink" title="ele.getElementsByClassName和ele.querySelectorAll的区别？"></a>ele.getElementsByClassName和ele.querySelectorAll的区别？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">element.getElementsByClassName 返回一个即时更新（动态的）HTMLCollection</span><br><span class="line">element.querySelectorAll 返回一个非即时更新（静态的） NodeList</span><br><span class="line">// 先说什么叫即时更新，（前者是动态的，改变 DOM 结构会同步，后者只会记录调用 api 时的结果，不懂可以看下面的例子）</span><br><span class="line">&lt;div id=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;p class=&quot;p&quot;&gt;1&lt;/p&gt;</span><br><span class="line">  &lt;p class=&quot;p&quot;&gt;2&lt;/p&gt;</span><br><span class="line">  &lt;p class=&quot;p&quot;&gt;3&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">let list1 = parent.getElementsByClassName(&#x27;p&#x27;);</span><br><span class="line">let list2 = parent.querySelectorAll(&#x27;.p&#x27;);</span><br><span class="line">console.log(list1.length1); // 3</span><br><span class="line">console.log(list2.length1); // 3</span><br><span class="line">let newP = docuemnt.createElement(&quot;p&quot;)</span><br><span class="line">newP.classList.add(&#x27;p&#x27;);</span><br><span class="line">parent.appendChild(newP);</span><br><span class="line">console.log(list1.length1); // 4 (即时更新)</span><br><span class="line">console.log(list2.length1); // 3（非即时更新）</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">// 在说下返回值</span><br><span class="line">// HTMLCollection 和 NodeList 都是类数组形式</span><br><span class="line">如下一个 div 可以看成是 HTMLDivElement 的实例，其中 Node 的集合为 NodeList；Element 的集合为 HTMLCollection</span><br><span class="line">EventTarget - Node - Element - HTMLElement - HTMLDivElement&lt;br&gt;</span><br><span class="line">EventTarget - Node - Element - SVGElement - SVGPathElement&lt;br&gt;</span><br></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLDivElement">MDN 上元素 div 继承关系</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端面试 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS面试知识点总结(十七)</title>
      <link href="/32592/"/>
      <url>/32592/</url>
      
        <content type="html"><![CDATA[<h2 id="手写一个-jsonp"><a href="#手写一个-jsonp" class="headerlink" title="手写一个 jsonp"></a>手写一个 jsonp</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">url, params, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否含有参数</span></span><br><span class="line">  <span class="keyword">let</span> queryString = url.indexOf(<span class="string">&quot;?&quot;</span>) === -<span class="number">1</span> ? <span class="string">&quot;?&quot;</span> : <span class="string">&quot;&amp;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加参数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> params) &#123;</span><br><span class="line">    <span class="keyword">if</span> (params.hasOwnProperty(k)) &#123;</span><br><span class="line">      queryString += k + <span class="string">&quot;=&quot;</span> + params[k] + <span class="string">&quot;&amp;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理回调函数名</span></span><br><span class="line">  <span class="keyword">let</span> random = <span class="built_in">Math</span>.random()</span><br><span class="line">      .toString()</span><br><span class="line">      .replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">    callbackName = <span class="string">&quot;myJsonp&quot;</span> + random;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加回调函数</span></span><br><span class="line">  queryString += <span class="string">&quot;callback=&quot;</span> + callbackName;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构建请求</span></span><br><span class="line">  <span class="keyword">let</span> scriptNode = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">  scriptNode.src = url + queryString;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">window</span>[callbackName] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 调用回调函数</span></span><br><span class="line">    callback(...arguments);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除这个引入的脚本</span></span><br><span class="line">    <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>].removeChild(scriptNode);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发起请求</span></span><br><span class="line">  <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>].appendChild(scriptNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/zzc5464/p/jsonp.html">《原生 jsonp 具体实现》</a><br><a href="https://segmentfault.com/a/1190000007665361#articleHeader1">《jsonp 的原理与实现》</a></p><h2 id="手写一个观察者模式？"><a href="#手写一个观察者模式？" class="headerlink" title="手写一个观察者模式？"></a>手写一个观察者模式？</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> events = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> topics = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// 注册监听函数</span></span><br><span class="line">    <span class="attr">subscribe</span>: <span class="function"><span class="keyword">function</span>(<span class="params">topic, handler</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!topics.hasOwnProperty(topic)) &#123;</span><br><span class="line">        topics[topic] = [];</span><br><span class="line">      &#125;</span><br><span class="line">      topics[topic].push(handler);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发布事件，触发观察者回调事件</span></span><br><span class="line">    <span class="attr">publish</span>: <span class="function"><span class="keyword">function</span>(<span class="params">topic, info</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (topics.hasOwnProperty(topic)) &#123;</span><br><span class="line">        topics[topic].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">handler</span>) </span>&#123;</span><br><span class="line">          handler(info);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除主题的一个观察者的回调事件</span></span><br><span class="line">    <span class="attr">remove</span>: <span class="function"><span class="keyword">function</span>(<span class="params">topic, handler</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!topics.hasOwnProperty(topic)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> handlerIndex = -<span class="number">1</span>;</span><br><span class="line">      topics[topic].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (item === handler) &#123;</span><br><span class="line">          handlerIndex = index;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (handlerIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        topics[topic].splice(handlerIndex, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除主题的所有观察者的回调事件</span></span><br><span class="line">    <span class="attr">removeAll</span>: <span class="function"><span class="keyword">function</span>(<span class="params">topic</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (topics.hasOwnProperty(topic)) &#123;</span><br><span class="line">        topics[topic] = [];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000006934031#articleHeader1">《JS 事件模型》</a></p><h2 id="EventEmitter-实现"><a href="#EventEmitter-实现" class="headerlink" title="EventEmitter 实现"></a>EventEmitter 实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.events = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">on</span>(<span class="params">event, callback</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> callbacks = <span class="built_in">this</span>.events[event] || [];</span><br><span class="line">    callbacks.push(callback);</span><br><span class="line">    <span class="built_in">this</span>.events[event] = callbacks;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">off</span>(<span class="params">event, callback</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> callbacks = <span class="built_in">this</span>.events[event];</span><br><span class="line">    <span class="built_in">this</span>.events[event] = callbacks &amp;&amp; callbacks.filter(<span class="function"><span class="params">fn</span> =&gt;</span> fn !== callback);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">emit</span>(<span class="params">event, ...args</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> callbacks = <span class="built_in">this</span>.events[event];</span><br><span class="line">    callbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">      fn(...args);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">once</span>(<span class="params">event, callback</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> wrapFun = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">      callback(...args);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">this</span>.off(event, wrapFun);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">this</span>.on(event, wrapFun);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一道常被人轻视的前端-JS-面试题"><a href="#一道常被人轻视的前端-JS-面试题" class="headerlink" title="一道常被人轻视的前端 JS 面试题"></a>一道常被人轻视的前端 JS 面试题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">Foo.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Foo.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="number">3</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="number">4</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//请写出以下输出结果：</span></span><br><span class="line">Foo.getName(); <span class="comment">// 2</span></span><br><span class="line">getName(); <span class="comment">// 4</span></span><br><span class="line">Foo().getName(); <span class="comment">// 1</span></span><br><span class="line">getName(); <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">new</span> Foo.getName(); <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">new</span> Foo().getName(); <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">new</span> Foo().getName(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://github.com/Wscats/Good-text-Share/issues/85">《前端程序员经常忽视的一个 JavaScript 面试题》</a><br><a href="https://segmentfault.com/q/1010000008430170">《一道考察运算符优先级的 JavaScript 面试题》</a><br><a href="https://www.cnblogs.com/xxcanghai/p/5189353.html">《一道常被人轻视的前端 JS 面试题》</a></p><h2 id="如何确定页面的可用性时间，什么是-Performance-API？"><a href="#如何确定页面的可用性时间，什么是-Performance-API？" class="headerlink" title="如何确定页面的可用性时间，什么是 Performance API？"></a>如何确定页面的可用性时间，什么是 Performance API？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Performance API 用于精确度量、控制、增强浏览器的性能表现。这个 API 为测量网站性能，提供以前没有办法做到的精度。</span><br><span class="line"></span><br><span class="line">使用 getTime 来计算脚本耗时的缺点，首先，getTime方法（以及 Date 对象的其他方法）都只能精确到毫秒级别（一秒的千分之一），想要得到更小的时间差别就无能为力了。其次，这种写法只能获取代码运行过程中的时间进度，无法知道一些后台事件的时间进度，比如浏览器用了多少时间从服务器加载网页。</span><br><span class="line"></span><br><span class="line">为了解决这两个不足之处，ECMAScript 5引入“高精度时间戳”这个 API，部署在 performance 对象上。它的精度可以达到1毫秒</span><br><span class="line">的千分之一（1秒的百万分之一）。</span><br><span class="line"></span><br><span class="line">navigationStart：当前浏览器窗口的前一个网页关闭，发生 unload 事件时的 Unix 毫秒时间戳。如果没有前一个网页，则等于 fetchStart 属性。</span><br><span class="line"></span><br><span class="line">loadEventEnd：返回当前网页 load 事件的回调函数运行结束时的 Unix 毫秒时间戳。如果该事件还没有发生，返回 0。</span><br></pre></td></tr></table></figure><p>根据上面这些属性，可以计算出网页加载各个阶段的耗时。比如，网页加载整个过程的耗时的计算方法如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> t = performance.timing;</span><br><span class="line"><span class="keyword">var</span> pageLoadTime = t.loadEventEnd - t.navigationStart;</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://javascript.ruanyifeng.com/bom/performance.html">《Performance API》</a></p><h2 id="js-中的命名规则"><a href="#js-中的命名规则" class="headerlink" title="js 中的命名规则"></a>js 中的命名规则</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）第一个字符必须是字母、下划线（_）或美元符号（$）</span><br><span class="line">（2）余下的字符可以是下划线、美元符号或任何字母或数字字符</span><br><span class="line"></span><br><span class="line">一般我们推荐使用驼峰法来对变量名进行命名，因为这样可以与 ECMAScript 内置的函数和对象命名格式保持一致。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://www.w3school.com.cn/js/pro_js_variables.asp">《ECMAScript 变量》</a></p><h2 id="js-语句末尾分号是否可以省略？"><a href="#js-语句末尾分号是否可以省略？" class="headerlink" title="js 语句末尾分号是否可以省略？"></a>js 语句末尾分号是否可以省略？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在 ECMAScript 规范中，语句结尾的分号并不是必需的。但是我们一般最好不要省略分号，因为加上分号一方面有</span><br><span class="line">利于我们代码的可维护性，另一方面也可以避免我们在对代码进行压缩时出现错误。</span><br></pre></td></tr></table></figure><h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</span><br></pre></td></tr></table></figure><h2 id="Math-ceil-和-Math-floor"><a href="#Math-ceil-和-Math-floor" class="headerlink" title="Math.ceil 和 Math.floor"></a>Math.ceil 和 Math.floor</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Math.ceil() === 向上取整，函数返回一个大于或等于给定数字的最小整数。</span><br><span class="line"></span><br><span class="line">Math.floor() === 向下取整，函数返回一个小于或等于给定数字的最大整数。</span><br></pre></td></tr></table></figure><h2 id="js-for-循环注意点"><a href="#js-for-循环注意点" class="headerlink" title="js for 循环注意点"></a>js for 循环注意点</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; <span class="number">5</span>, j &lt; <span class="number">9</span>; i++, j++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i, j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当判断语句含有多个语句时，以最后一个判断语句的值为准，因此上面的代码会执行 10 次。</span></span><br><span class="line"><span class="comment">// 当判断语句为空时，循环会一直进行。</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端面试 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS面试知识点总结(十六)</title>
      <link href="/49041/"/>
      <url>/49041/</url>
      
        <content type="html"><![CDATA[<h2 id="route-和-router-的区别？"><a href="#route-和-router-的区别？" class="headerlink" title="$route 和 $router 的区别？"></a>$route 和 $router 的区别？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数。而 $router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。</span><br></pre></td></tr></table></figure><h2 id="vue-常用的修饰符？"><a href="#vue-常用的修饰符？" class="headerlink" title="vue 常用的修饰符？"></a>vue 常用的修饰符？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.prevent: 提交事件不再重载页面；.stop: 阻止单击事件冒泡；.self: 当事件发生在该元素本身而不是子元素的时候会触发；</span><br></pre></td></tr></table></figure><h2 id="vue-中-key-值的作用？"><a href="#vue-中-key-值的作用？" class="headerlink" title="vue 中 key 值的作用？"></a>vue 中 key 值的作用？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vue 中 key 值的作用可以分为两种情况来考虑。</span><br><span class="line"></span><br><span class="line">第一种情况是 v-if 中使用 key。由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当我们使用 v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此我们可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 key 的作用是用来标识一个独立的元素。</span><br><span class="line"></span><br><span class="line">第二种情况是 v-for 中使用 key。用 v-for 更新已渲染过的元素列表时，它默认使用“就地复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，来以便 Vue 跟踪元素的身份，从而高效的实现复用。这个时候 key 的作用是为了高效的更新渲染虚拟 DOM。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000016344599">《Vue 面试中，经常会被问到的面试题 Vue 知识点整理》</a><br><a href="https://www.zhihu.com/question/61064119">《Vue2.0 v-for 中 :key 到底有什么用？》</a><br><a href="https://www.cnblogs.com/RainyBear/p/8563101.html">《vue 中 key 的作用》</a></p><h2 id="computed-和-watch-区别？"><a href="#computed-和-watch-区别？" class="headerlink" title="computed 和 watch 区别？"></a>computed 和 watch 区别？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">computed 是计算属性，依赖其他属性计算值，并且 computed 的值有缓存，只有当计算值变化才会返回内容。</span><br><span class="line"></span><br><span class="line">watch 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。</span><br></pre></td></tr></table></figure><h2 id="keep-alive-组件有什么作用？"><a href="#keep-alive-组件有什么作用？" class="headerlink" title="keep-alive 组件有什么作用？"></a>keep-alive 组件有什么作用？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果你需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 keep-alive 组件包裹需要保存的组件。</span><br></pre></td></tr></table></figure><h2 id="vue-中-mixin-和-mixins-区别？"><a href="#vue-中-mixin-和-mixins-区别？" class="headerlink" title="vue 中 mixin 和 mixins 区别？"></a>vue 中 mixin 和 mixins 区别？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mixin 用于全局混入，会影响到每个组件实例。</span><br><span class="line"></span><br><span class="line">mixins 应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 mixins 混入代码，比如上拉下拉加载数据这种逻辑等等。另外需要注意的是 mixins 混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc731b51882516c56ced6f">《前端面试之道》</a><br><a href="https://cn.vuejs.org/v2/guide/mixins.html">《混入》</a></p><h2 id="开发中常用的几种-Content-Type-？"><a href="#开发中常用的几种-Content-Type-？" class="headerlink" title="开发中常用的几种 Content-Type ？"></a>开发中常用的几种 Content-Type ？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL</span><br><span class="line">转码。</span><br><span class="line"></span><br><span class="line">（2）multipart/form-data</span><br><span class="line"></span><br><span class="line">该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。</span><br><span class="line"></span><br><span class="line">（3）application/json</span><br><span class="line"></span><br><span class="line">告诉服务器消息主体是序列化后的 JSON 字符串。</span><br><span class="line"></span><br><span class="line">（4）text/xml</span><br><span class="line"></span><br><span class="line">该种方式主要用来提交 XML 格式的数据。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://honglu.me/2015/07/13/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8DContent-Type/">《常用的几种 Content-Type》</a></p><h2 id="如何封装一个-javascript-的类型判断函数？"><a href="#如何封装一个-javascript-的类型判断函数？" class="headerlink" title="如何封装一个 javascript 的类型判断函数？"></a>如何封装一个 javascript 的类型判断函数？</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断数据是 null 的情况</span></span><br><span class="line">  <span class="keyword">if</span> (value === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value + <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断数据是引用类型的情况</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> valueClass = <span class="built_in">Object</span>.prototype.toString.call(value),</span><br><span class="line">      type = valueClass.split(<span class="string">&quot; &quot;</span>)[<span class="number">1</span>].split(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    type.pop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> type.join(<span class="string">&quot;&quot;</span>).toLowerCase();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 判断数据是基本数据类型的情况和函数的情况</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://github.com/mqyqingfeng/Blog/issues/28">《JavaScript 专题之类型判断(上)》</a></p><h2 id="如何判断一个对象是否为空对象？"><a href="#如何判断一个对象是否为空对象？" class="headerlink" title="如何判断一个对象是否为空对象？"></a>如何判断一个对象是否为空对象？</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkNullObj</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.keys(obj).length === <span class="number">0</span> &amp;&amp; <span class="built_in">Object</span>.getOwnPropertySymbols(obj).length === <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/FungLeo/article/details/78113661">《js 判断一个 object 对象是否为空》</a></p><h2 id="使用闭包实现每隔一秒打印-1-2-3-4"><a href="#使用闭包实现每隔一秒打印-1-2-3-4" class="headerlink" title="使用闭包实现每隔一秒打印 1,2,3,4"></a>使用闭包实现每隔一秒打印 1,2,3,4</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用闭包实现</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, i * <span class="number">1000</span>);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 let 块级作用域</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, i * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端面试 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS面试知识点总结(十五)</title>
      <link href="/48849/"/>
      <url>/48849/</url>
      
        <content type="html"><![CDATA[<h2 id="策略模式是什么？"><a href="#策略模式是什么？" class="headerlink" title="策略模式是什么？"></a>策略模式是什么？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">策略模式主要是用来将方法的实现和方法的调用分离开，外部通过不同的参数可以调用不同的策略。我主要在 MVP 模式解耦的时候</span><br><span class="line">用来将视图层的方法定义和方法调用分离。</span><br></pre></td></tr></table></figure><h2 id="代理模式是什么？"><a href="#代理模式是什么？" class="headerlink" title="代理模式是什么？"></a>代理模式是什么？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。比如说常见的事件代理。</span><br></pre></td></tr></table></figure><h2 id="中介者模式是什么？"><a href="#中介者模式是什么？" class="headerlink" title="中介者模式是什么？"></a>中介者模式是什么？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">中介者模式指的是，多个对象通过一个中介者进行交流，而不是直接进行交流，这样能够将通信的各个对象解耦。</span><br></pre></td></tr></table></figure><h2 id="适配器模式是什么？"><a href="#适配器模式是什么？" class="headerlink" title="适配器模式是什么？"></a>适配器模式是什么？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">适配器用来解决两个接口不兼容的情况，不需要改变已有的接口，通过包装一层的方式实现两个接口的正常协作。假如我们需要一种</span><br><span class="line">新的接口返回方式，但是老的接口由于在太多地方已经使用了，不能随意更改，这个时候就可以使用适配器模式。比如我们需要一种</span><br><span class="line">自定义的时间返回格式，但是我们又不能对 js 时间格式化的接口进行修改，这个时候就可以使用适配器模式。</span><br></pre></td></tr></table></figure><p>更多关于设计模式的资料可以参考：<br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc74186fb9a049ab0d0b6b">《前端面试之道》</a><br><a href="https://juejin.im/post/59df4f74f265da430f311909#heading-3">《JavaScript 设计模式》</a><br><a href="https://juejin.im/post/5afe6430518825428630bc4d">《JavaScript 中常见设计模式整理》</a></p><h2 id="观察者模式和发布订阅模式有什么不同？"><a href="#观察者模式和发布订阅模式有什么不同？" class="headerlink" title="观察者模式和发布订阅模式有什么不同？"></a>观察者模式和发布订阅模式有什么不同？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">发布订阅模式其实属于广义上的观察者模式</span><br><span class="line"></span><br><span class="line">在观察者模式中，观察者需要直接订阅目标事件。在目标发出内容改变的事件后，直接接收事件并作出响应。</span><br><span class="line"></span><br><span class="line">而在发布订阅模式中，发布者和订阅者之间多了一个调度中心。调度中心一方面从发布者接收事件，另一方面向订阅者发布事件，订阅者需要在调度中心中订阅事件。通过调度中心实现了发布者和订阅者关系的解耦。使用发布订阅者模式更利于我们代码的可维护性。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/23486749">《观察者模式和发布订阅模式有什么不同？》</a></p><h2 id="Vue-的生命周期是什么？"><a href="#Vue-的生命周期是什么？" class="headerlink" title="Vue 的生命周期是什么？"></a>Vue 的生命周期是什么？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vue 的生命周期指的是组件从创建到销毁的一系列的过程，被称为 Vue 的生命周期。通过提供的 Vue 在生命周期各个阶段的钩子函数，我们可以很好的在 Vue 的各个生命阶段实现一些操作。</span><br></pre></td></tr></table></figure><h2 id="Vue-的各个生命阶段是什么？"><a href="#Vue-的各个生命阶段是什么？" class="headerlink" title="Vue 的各个生命阶段是什么？"></a>Vue 的各个生命阶段是什么？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vue 一共有8个生命阶段，分别是创建前、创建后、加载前、加载后、更新前、更新后、销毁前和销毁后，每个阶段对应了一个生命周期的钩子函数。</span><br><span class="line"></span><br><span class="line">（1）beforeCreate 钩子函数，在实例初始化之后，在数据监听和事件配置之前触发。因此在这个事件中我们是获取不到 data 数据的。</span><br><span class="line"></span><br><span class="line">（2）created 钩子函数，在实例创建完成后触发，此时可以访问 data、methods 等属性。但这个时候组件还没有被挂载到页面中去，所以这个时候访问不到 $el 属性。一般我们可以在这个函数中进行一些页面初始化的工作，比如通过 ajax 请求数据来对页面进行初始化。</span><br><span class="line"></span><br><span class="line">（3）beforeMount 钩子函数，在组件被挂载到页面之前触发。在 beforeMount 之前，会找到对应的 template，并编译成 render 函数。</span><br><span class="line"></span><br><span class="line">（4）mounted 钩子函数，在组件挂载到页面之后触发。此时可以通过 DOM API 获取到页面中的 DOM 元素。</span><br><span class="line"></span><br><span class="line">（5）beforeUpdate 钩子函数，在响应式数据更新时触发，发生在虚拟 DOM 重新渲染和打补丁之前，这个时候我们可以对可能会被移除的元素做一些操作，比如移除事件监听器。</span><br><span class="line"></span><br><span class="line">（6）updated 钩子函数，虚拟 DOM 重新渲染和打补丁之后调用。</span><br><span class="line"></span><br><span class="line">（7）beforeDestroy 钩子函数，在实例销毁之前调用。一般在这一步我们可以销毁定时器、解绑全局事件等。</span><br><span class="line"></span><br><span class="line">（8）destroyed 钩子函数，在实例销毁之后调用，调用后，Vue 实例中的所有东西都会解除绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</span><br><span class="line"></span><br><span class="line">当我们使用 keep-alive 的时候，还有两个钩子函数，分别是 activated 和 deactivated 。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 actived 钩子函数。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/entry/5aee8fbb518825671952308c">《vue 生命周期深入》</a><br><a href="https://cn.vuejs.org/v2/guide/instance.html">《Vue 实例》</a></p><h2 id="Vue-组件间的参数传递方式？"><a href="#Vue-组件间的参数传递方式？" class="headerlink" title="Vue 组件间的参数传递方式？"></a>Vue 组件间的参数传递方式？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）父子组件间通信</span><br><span class="line"></span><br><span class="line">第一种方法是子组件通过 props 属性来接受父组件的数据，然后父组件在子组件上注册监听事件，子组件通过 emit 触发事</span><br><span class="line">件来向父组件发送数据。</span><br><span class="line"></span><br><span class="line">第二种是通过 ref 属性给子组件设置一个名字。父组件通过 $refs 组件名来获得子组件，子组件通过 $parent 获得父组</span><br><span class="line">件，这样也可以实现通信。</span><br><span class="line"></span><br><span class="line">第三种是使用 provider/inject，在父组件中通过 provider 提供变量，在子组件中通过 inject 来将变量注入到组件</span><br><span class="line">中。不论子组件有多深，只要调用了 inject 那么就可以注入 provider 中的数据。</span><br><span class="line"></span><br><span class="line">（2）兄弟组件间通信</span><br><span class="line"></span><br><span class="line">第一种是使用 eventBus 的方法，它的本质是通过创建一个空的 Vue 实例来作为消息传递的对象，通信的组件引入这个实</span><br><span class="line">例，通信的组件通过在这个实例上监听和触发事件，来实现消息的传递。</span><br><span class="line"></span><br><span class="line">第二种是通过 $parent.$refs 来获取到兄弟组件，也可以进行通信。</span><br><span class="line"></span><br><span class="line">（3）任意组件之间</span><br><span class="line"></span><br><span class="line">使用 eventBus ，其实就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候采用上面这一些方法可能不利于项目的维护。这个时候</span><br><span class="line">可以使用 vuex ，vuex 的思想就是将这一些公共的数据抽离出来，将它作为一个全局的变量来管理，然后其他组件就可以对这个</span><br><span class="line">公共数据进行读写操作，这样达到了解耦的目的。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/entry/5ba215ac5188255c6d0d8345">《VUE 组件之间数据传递全集》</a></p><h2 id="computed-和-watch-的差异？"><a href="#computed-和-watch-的差异？" class="headerlink" title="computed 和 watch 的差异？"></a>computed 和 watch 的差异？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）computed 是计算一个新的属性，并将该属性挂载到 Vue 实例上，而 watch 是监听已经存在且已挂载到 Vue 实例上的数据，所以用 watch 同样可以监听 computed 计算属性的变化。</span><br><span class="line"></span><br><span class="line">（2）computed 本质是一个惰性求值的观察者，具有缓存性，只有当依赖变化后，第一次访问 computed 属性，才会计算新的值。而 watch 则是当数据发生变化便会调用执行函数。</span><br><span class="line"></span><br><span class="line">（3）从使用场景上说，computed 适用一个数据被多个数据影响，而 watch 适用一个数据影响多个数据。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5b98c4da6fb9a05d353c5fd7">《做面试的不倒翁：浅谈 Vue 中 computed 实现原理》</a><br><a href="https://juejin.im/post/5af908ea5188254265399009">《深入理解 Vue 的 watch 实现原理及其实现方式》</a></p><h2 id="vue-router-中的导航钩子函数"><a href="#vue-router-中的导航钩子函数" class="headerlink" title="vue-router 中的导航钩子函数"></a>vue-router 中的导航钩子函数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）全局的钩子函数 beforeEach 和 afterEach</span><br><span class="line"></span><br><span class="line">beforeEach 有三个参数，to 代表要进入的路由对象，from 代表离开的路由对象。next 是一个必须要执行的函数，如果不传参数，那就执行下一个钩子函数，如果传入 false，则终止跳转，如果传入一个路径，则导航到对应的路由，如果传入 error ，则导航终止，error 传入错误的监听函数。</span><br><span class="line"></span><br><span class="line">（2）单个路由独享的钩子函数 beforeEnter，它是在路由配置上直接进行定义的。</span><br><span class="line"></span><br><span class="line">（3）组件内的导航钩子主要有这三种：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave。它们是直接在路由组</span><br><span class="line">件内部直接进行定义的。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%85%A8%E5%B1%80%E5%89%8D%E7%BD%AE%E5%AE%88%E5%8D%AB">《导航守卫》</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端面试 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS面试知识点总结(十四)</title>
      <link href="/32272/"/>
      <url>/32272/</url>
      
        <content type="html"><![CDATA[<h2 id="Set-和-WeakSet-结构？"><a href="#Set-和-WeakSet-结构？" class="headerlink" title="Set 和 WeakSet 结构？"></a>Set 和 WeakSet 结构？</h2><ul><li>1.ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</li><li>2.WeakSet 结构与 Set 类似，也是不重复的值的集合。但是 WeakSet 的成员只能是对象，而不能是其他类型的值。WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，</li></ul><h2 id="Map-和-WeakMap-结构？"><a href="#Map-和-WeakMap-结构？" class="headerlink" title="Map 和 WeakMap 结构？"></a>Map 和 WeakMap 结构？</h2><ul><li>1.Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</li><li>2.WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。但是 WeakMap 只接受对象作为键名（ null 除外），不接受其他类型的值作为键名。而且 WeakMap 的键名所指向的对象，不计入垃圾回收机制。</li></ul><h2 id="什么是-Proxy-？"><a href="#什么是-Proxy-？" class="headerlink" title="什么是 Proxy ？"></a>什么是 Proxy ？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”，即对编程语言进行编程。</span><br><span class="line"></span><br><span class="line">Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</span><br></pre></td></tr></table></figure><h2 id="Reflect-对象创建目的？"><a href="#Reflect-对象创建目的？" class="headerlink" title="Reflect 对象创建目的？"></a>Reflect 对象创建目的？</h2><ul><li>1.将 Object 对象的一些明显属于语言内部的方法（比如 Object.defineProperty，放到 Reflect 对象上。</li><li>2.修改某些 Object 方法的返回结果，让其变得更合理。</li><li>3.让 Object 操作都变成函数行为。</li><li>4.Reflect 对象的方法与 Proxy 对象的方法一一对应，只要是 Proxy 对象的方法，就能在 Reflect 对象上找到对应的方法。这就让 Proxy 对象可以方便地调用对应的 Reflect 方法，完成默认行为，作为修改行为的基础。也就是说，不管 Proxy 怎么修改默认行为，你总可以在 Reflect 上获取默认行为。</li></ul><h2 id="require-模块引入的查找方式？"><a href="#require-模块引入的查找方式？" class="headerlink" title="require 模块引入的查找方式？"></a>require 模块引入的查找方式？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当 Node 遇到 require(X) 时，按下面的顺序处理。</span><br><span class="line"></span><br><span class="line">（1）如果 X 是内置模块（比如 require(&#x27;http&#x27;)）</span><br><span class="line">　　a. 返回该模块。</span><br><span class="line">　　b. 不再继续执行。</span><br><span class="line"></span><br><span class="line">（2）如果 X 以 &quot;./&quot; 或者 &quot;/&quot; 或者 &quot;../&quot; 开头</span><br><span class="line">　　a. 根据 X 所在的父模块，确定 X 的绝对路径。</span><br><span class="line">　　b. 将 X 当成文件，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。</span><br><span class="line">    X</span><br><span class="line">    X.js</span><br><span class="line">    X.json</span><br><span class="line">    X.node</span><br><span class="line"></span><br><span class="line">　　c. 将 X 当成目录，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。</span><br><span class="line">    X/package.json（main字段）</span><br><span class="line">    X/index.js</span><br><span class="line">    X/index.json</span><br><span class="line">    X/index.node</span><br><span class="line"></span><br><span class="line">（3）如果 X 不带路径</span><br><span class="line">　　a. 根据 X 所在的父模块，确定 X 可能的安装目录。</span><br><span class="line">　　b. 依次在每个目录中，将 X 当成文件名或目录名加载。</span><br><span class="line"></span><br><span class="line">（4）抛出 &quot;not found&quot;</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2015/05/require.html">《require() 源码解读》</a></p><h2 id="什么是-Promise-对象，什么是-Promises-A-规范？"><a href="#什么是-Promise-对象，什么是-Promises-A-规范？" class="headerlink" title="什么是 Promise 对象，什么是 Promises/A+ 规范？"></a>什么是 Promise 对象，什么是 Promises/A+ 规范？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Promise 对象是异步编程的一种解决方案，最早由社区提出。Promises/A+ 规范是 JavaScript Promise 的标准，规定了一个 Promise 所必须具有的特性。</span><br><span class="line"></span><br><span class="line">Promise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。一个 Promise 实例有三种状态，分别是 pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者 rejected 状态，并且状态一经改变，就凝固了，无法再被改变了。状态的改变是通过 resolve() 和 reject() 函数来实现的，我们</span><br><span class="line">可以在异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://www.ituring.com.cn/article/66566">《Promises/A+ 规范》</a><br><a href="http://es6.ruanyifeng.com/#docs/promise#Promise-resolve">《Promise》</a></p><h2 id="手写一个-Promise"><a href="#手写一个-Promise" class="headerlink" title="手写一个 Promise"></a>手写一个 Promise</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&quot;pending&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> RESOLVED = <span class="string">&quot;resolved&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 保存初始化状态</span></span><br><span class="line">  <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化状态</span></span><br><span class="line">  <span class="built_in">this</span>.state = PENDING;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于保存 resolve 或者 rejected 传入的值</span></span><br><span class="line">  <span class="built_in">this</span>.value = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于保存 resolve 的回调函数</span></span><br><span class="line">  <span class="built_in">this</span>.resolvedCallbacks = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于保存 reject 的回调函数</span></span><br><span class="line">  <span class="built_in">this</span>.rejectedCallbacks = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 状态转变为 resolved 方法</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断传入元素是否为 Promise 值，如果是，则状态改变必须等待前一个状态改变后再进行改变</span></span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">      <span class="keyword">return</span> value.then(resolve, reject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证代码的执行顺序为本轮事件循环的末尾</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 只有状态为 pending 时才能转变，</span></span><br><span class="line">      <span class="keyword">if</span> (self.state === PENDING) &#123;</span><br><span class="line">        <span class="comment">// 修改状态</span></span><br><span class="line">        self.state = RESOLVED;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置传入的值</span></span><br><span class="line">        self.value = value;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行回调函数</span></span><br><span class="line">        self.resolvedCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">          callback(value);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 状态转变为 rejected 方法</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 保证代码的执行顺序为本轮事件循环的末尾</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 只有状态为 pending 时才能转变</span></span><br><span class="line">      <span class="keyword">if</span> (self.state === PENDING) &#123;</span><br><span class="line">        <span class="comment">// 修改状态</span></span><br><span class="line">        self.state = REJECTED;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置传入的值</span></span><br><span class="line">        self.value = value;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行回调函数</span></span><br><span class="line">        self.rejectedCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">          callback(value);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将两个方法传入函数执行</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    fn(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// 遇到错误时，捕获错误，执行 reject 函数</span></span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 首先判断两个参数是否为函数类型，因为这两个参数是可选参数</span></span><br><span class="line">  onResolved =</span><br><span class="line">    <span class="keyword">typeof</span> onResolved === <span class="string">&quot;function&quot;</span></span><br><span class="line">      ? onResolved</span><br><span class="line">      : <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> value;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">  onRejected =</span><br><span class="line">    <span class="keyword">typeof</span> onRejected === <span class="string">&quot;function&quot;</span></span><br><span class="line">      ? onRejected</span><br><span class="line">      : <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">throw</span> error;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是等待状态，则将函数加入对应列表中</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.state === PENDING) &#123;</span><br><span class="line">    <span class="built_in">this</span>.resolvedCallbacks.push(onResolved);</span><br><span class="line">    <span class="built_in">this</span>.rejectedCallbacks.push(onRejected);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果状态已经凝固，则直接执行对应状态的函数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.state === RESOLVED) &#123;</span><br><span class="line">    onResolved(<span class="built_in">this</span>.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.state === REJECTED) &#123;</span><br><span class="line">    onRejected(<span class="built_in">this</span>.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="如何检测浏览器所支持的最小字体大小？"><a href="#如何检测浏览器所支持的最小字体大小？" class="headerlink" title="如何检测浏览器所支持的最小字体大小？"></a>如何检测浏览器所支持的最小字体大小？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用 JS 设置 DOM 的字体为某一个值，然后再取出来，如果值设置成功，就说明支持。</span><br></pre></td></tr></table></figure><h2 id="怎么做-JS-代码-Error-统计？"><a href="#怎么做-JS-代码-Error-统计？" class="headerlink" title="怎么做 JS 代码 Error 统计？"></a>怎么做 JS 代码 Error 统计？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error 统计使用浏览器的 window.error 事件。</span><br></pre></td></tr></table></figure><h2 id="单例模式模式是什么？"><a href="#单例模式模式是什么？" class="headerlink" title="单例模式模式是什么？"></a>单例模式模式是什么？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">单例模式保证了全局只有一个实例来被访问。比如说常用的如弹框组件的实现和全局状态的实现。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端面试 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS面试知识点总结(十三)</title>
      <link href="/48209/"/>
      <url>/48209/</url>
      
        <content type="html"><![CDATA[<h2 id="使用-Object-defineProperty-来进行数据劫持有什么缺点？"><a href="#使用-Object-defineProperty-来进行数据劫持有什么缺点？" class="headerlink" title="使用 Object.defineProperty() 来进行数据劫持有什么缺点？"></a>使用 Object.defineProperty() 来进行数据劫持有什么缺点？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有一些对属性的操作，使用这种方法无法拦截，比如说通过下标方式修改数组数据或者给对象新增属性，vue 内部通过重写函数解决了这个问题。在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用 Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为这是 ES6 的语法。</span><br></pre></td></tr></table></figure><h2 id="什么是-Virtual-DOM？为什么-Virtual-DOM-比原生-DOM-快？"><a href="#什么是-Virtual-DOM？为什么-Virtual-DOM-比原生-DOM-快？" class="headerlink" title="什么是 Virtual DOM？为什么 Virtual DOM 比原生 DOM 快？"></a>什么是 Virtual DOM？为什么 Virtual DOM 比原生 DOM 快？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我对 Virtual DOM 的理解是，</span><br><span class="line"></span><br><span class="line">首先对我们将要插入到文档中的 DOM 树结构进行分析，使用 js 对象将其表示出来，比如一个元素对象，包含 TagName、props 和 Children 这些属性。然后我们将这个 js 对象树给保存下来，最后再将 DOM 片段插入到文档中。</span><br><span class="line"></span><br><span class="line">当页面的状态发生改变，我们需要对页面的 DOM 的结构进行调整的时候，我们首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的的差异。</span><br><span class="line"></span><br><span class="line">最后将记录的有差异的地方应用到真正的 DOM 树中去，这样视图就更新了。</span><br><span class="line"></span><br><span class="line">我认为 Virtual DOM 这种方法对于我们需要有大量的 DOM 操作的时候，能够很好的提高我们的操作效率，通过在操作前确定需要做的最小修改，尽可能的减少 DOM 操作带来的重流和重绘的影响。其实 Virtual DOM 并不一定比我们真实的操作 DOM 要快，这种方法的目的是为了提高我们开发时的可维护性，在任意的情况下，都能保证一个尽量小的性能消耗去进行操作。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc72e6e51d45054f664dbf">《Virtual DOM》</a><br><a href="https://github.com/y8n/blog/issues/5">《理解 Virtual DOM》</a><br><a href="https://github.com/livoras/blog/issues/13">《深度剖析：如何实现一个 Virtual DOM 算法》</a><br><a href="https://www.zhihu.com/question/31809713/answer/53544875">《网上都说操作真实 DOM 慢，但测试结果却比 React 更快，为什么？》</a></p><h2 id="如何比较两个-DOM-树的差异？"><a href="#如何比较两个-DOM-树的差异？" class="headerlink" title="如何比较两个 DOM 树的差异？"></a>如何比较两个 DOM 树的差异？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">两个树的完全 diff 算法的时间复杂度为 O(n^3) ，但是在前端中，我们很少会跨层级的移动元素，所以我们只需要比较同一层级的元素进行比较，这样就可以将算法的时间复杂度降低为 O(n)。</span><br><span class="line"></span><br><span class="line">算法首先会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个序号。在深度遍历的时候，每遍历到一个节点，我们就将这个节点和新的树中的节点进行比较，如果有差异，则将这个差异记录到一个对象中。</span><br><span class="line"></span><br><span class="line">在对列表元素进行对比的时候，由于 TagName 是重复的，所以我们不能使用这个来对比。我们需要给每一个子节点加上一个 key，列表对比的时候使用 key 来进行比较，这样我们才能够复用老的 DOM 树上的节点。</span><br></pre></td></tr></table></figure><h2 id="什么是-requestAnimationFrame-？"><a href="#什么是-requestAnimationFrame-？" class="headerlink" title="什么是 requestAnimationFrame ？"></a>什么是 requestAnimationFrame ？</h2><p>详细资料可以参考：<br><a href="https://juejin.im/post/5a82f0626fb9a06358657c9c">《你需要知道的 requestAnimationFrame》</a><br><a href="https://www.zhangxinxu.com/wordpress/2013/09/css3-animation-requestanimationframe-tween-%E5%8A%A8%E7%94%BB%E7%AE%97%E6%B3%95/">《CSS3 动画那么强，requestAnimationFrame 还有毛线用？》</a></p><h2 id="谈谈你对-webpack-的看法"><a href="#谈谈你对-webpack-的看法" class="headerlink" title="谈谈你对 webpack 的看法"></a>谈谈你对 webpack 的看法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我当时使用 webpack 的一个最主要原因是为了简化页面依赖的管理，并且通过将其打包为一个文件来降低页面加载时请求的资源</span><br><span class="line">数。</span><br><span class="line"></span><br><span class="line">我认为 webpack 的主要原理是，它将所有的资源都看成是一个模块，并且把页面逻辑当作一个整体，通过一个给定的入口文件，webpack 从这个文件开始，找到所有的依赖文件，将各个依赖文件模块通过 loader 和 plugins 处理后，然后打包在一起，最后输出一个浏览器可识别的 JS 文件。</span><br><span class="line"></span><br><span class="line">Webpack 具有四个核心的概念，分别是 Entry（入口）、Output（输出）、loader 和 Plugins（插件）。</span><br><span class="line"></span><br><span class="line">Entry 是 webpack 的入口起点，它指示 webpack 应该从哪个模块开始着手，来作为其构建内部依赖图的开始。</span><br><span class="line"></span><br><span class="line">Output 属性告诉 webpack 在哪里输出它所创建的打包文件，也可指定打包文件的名称，默认位置为 ./dist。</span><br><span class="line"></span><br><span class="line">loader 可以理解为 webpack 的编译器，它使得 webpack 可以处理一些非 JavaScript 文件。在对 loader 进行配置的时候，test 属性，标志有哪些后缀的文件应该被处理，是一个正则表达式。use 属性，指定 test 类型的文件应该使用哪个 loader 进行预处理。常用的 loader 有 css-loader、style-loader 等。</span><br><span class="line"></span><br><span class="line">插件可以用于执行范围更广的任务，包括打包、优化、压缩、搭建服务器等等，要使用一个插件，一般是先使用 npm 包管理器进行安装，然后在配置文件中引入，最后将其实例化后传递给 plugins 数组属性。</span><br><span class="line"></span><br><span class="line">使用 webpack 的确能够提供我们对于项目的管理，但是它的缺点就是调试和配置起来太麻烦了。但现在 webpack4.0 的免配置一定程度上解决了这个问题。但是我感觉就是对我来说，就是一个黑盒，很多时候出现了问题，没有办法很好的定位。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5b38d27451882574d87aa5d5#heading-0">《不聊 webpack 配置，来说说它的原理》</a><br><a href="https://juejin.im/entry/5b5724d05188251aa01647fd">《前端工程化——构建工具选型：grunt、gulp、webpack》</a><br><a href="https://juejin.im/post/5afa9cd0f265da0b981b9af9#heading-0">《浅入浅出 webpack》</a><br><a href="https://juejin.im/entry/5ae5c8c9f265da0b9f400d8e">《前端构建工具发展及其比较》</a></p><h2 id="offsetWidth-offsetHeight-clientWidth-clientHeight-与-scrollWidth-scrollHeight-的区别？"><a href="#offsetWidth-offsetHeight-clientWidth-clientHeight-与-scrollWidth-scrollHeight-的区别？" class="headerlink" title="offsetWidth/offsetHeight,clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别？"></a>offsetWidth/offsetHeight,clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clientWidth/clientHeight 返回的是元素的内部宽度，它的值只包含 content + padding，如果有滚动条，不包含滚动条。</span><br><span class="line">clientTop 返回的是上边框的宽度。</span><br><span class="line">clientLeft 返回的左边框的宽度。</span><br><span class="line"></span><br><span class="line">offsetWidth/offsetHeight 返回的是元素的布局宽度，它的值包含 content + padding + border 包含了滚动条。</span><br><span class="line">offsetTop 返回的是当前元素相对于其 offsetParent 元素的顶部的距离。</span><br><span class="line">offsetLeft 返回的是当前元素相对于其 offsetParent 元素的左部的距离。</span><br><span class="line"></span><br><span class="line">scrollWidth/scrollHeight 返回值包含 content + padding + 溢出内容的尺寸。</span><br><span class="line">scrollTop 属性返回的是一个元素的内容垂直滚动的像素数。</span><br><span class="line">scrollLeft 属性返回的是元素滚动条到元素左边的距离。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5bc9366d5188255c4834e75a">《最全的获取元素宽高及位置的方法》</a><br><a href="http://www.ruanyifeng.com/blog/2009/09/find_element_s_position_using_javascript.html">《用 Javascript 获取页面元素的位置》</a></p><h2 id="谈一谈你理解的函数式编程？"><a href="#谈一谈你理解的函数式编程？" class="headerlink" title="谈一谈你理解的函数式编程？"></a>谈一谈你理解的函数式编程？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">简单说，&quot;函数式编程&quot;是一种&quot;编程范式&quot;（programming paradigm），也就是如何编写程序的方法论。</span><br><span class="line"></span><br><span class="line">它具有以下特性：闭包和高阶函数、惰性计算、递归、函数是&quot;第一等公民&quot;、只用&quot;表达式&quot;。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2012/04/functional_programming.html">《函数式编程初探》</a></p><h2 id="异步编程的实现方式？"><a href="#异步编程的实现方式？" class="headerlink" title="异步编程的实现方式？"></a>异步编程的实现方式？</h2><p>相关资料：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">回调函数</span><br><span class="line">优点：简单、容易理解</span><br><span class="line">缺点：不利于维护，代码耦合高</span><br><span class="line"></span><br><span class="line">事件监听（采用时间驱动模式，取决于某个事件是否发生）：</span><br><span class="line">优点：容易理解，可以绑定多个事件，每个事件可以指定多个回调函数</span><br><span class="line">缺点：事件驱动型，流程不够清晰</span><br><span class="line"></span><br><span class="line">发布/订阅（观察者模式）</span><br><span class="line">类似于事件监听，但是可以通过‘消息中心’，了解现在有多少发布者，多少订阅者</span><br><span class="line"></span><br><span class="line">Promise 对象</span><br><span class="line">优点：可以利用 then 方法，进行链式写法；可以书写错误时的回调函数；</span><br><span class="line">缺点：编写和理解，相对比较难</span><br><span class="line"></span><br><span class="line">Generator 函数</span><br><span class="line">优点：函数体内外的数据交换、错误处理机制</span><br><span class="line">缺点：流程管理不方便</span><br><span class="line"></span><br><span class="line">async 函数</span><br><span class="line">优点：内置执行器、更好的语义、更广的适用性、返回的是 Promise、结构清晰。</span><br><span class="line">缺点：错误处理机制</span><br></pre></td></tr></table></figure><p>回答：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">js 中的异步机制可以分为以下几种：</span><br><span class="line"></span><br><span class="line">第一种最常见的是使用回调函数的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。</span><br><span class="line"></span><br><span class="line">第二种是 Promise 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。</span><br><span class="line"></span><br><span class="line">第三种是使用 generator 的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部我们还可以将执行权转移回来。当我们遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕的时候我们再将执行权给转移回来。因此我们在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式我们需要考虑的问题是何时将函数的控制权转移回来，因此我们需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。</span><br><span class="line"></span><br><span class="line">第四种是使用 async 函数的形式，async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此我们可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。</span><br></pre></td></tr></table></figure><h2 id="Js-动画与-CSS-动画区别及相应实现"><a href="#Js-动画与-CSS-动画区别及相应实现" class="headerlink" title="Js 动画与 CSS 动画区别及相应实现"></a>Js 动画与 CSS 动画区别及相应实现</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CSS3 的动画的优点</span><br><span class="line"></span><br><span class="line">在性能上会稍微好一些，浏览器会对 CSS3 的动画做一些优化</span><br><span class="line">代码相对简单</span><br><span class="line"></span><br><span class="line">缺点</span><br><span class="line"></span><br><span class="line">在动画控制上不够灵活</span><br><span class="line">兼容性不好</span><br><span class="line"></span><br><span class="line">JavaScript 的动画正好弥补了这两个缺点，控制能力很强，可以单帧的控制、变换，同时写得好完全可以兼容 IE6，并且功能强大。对于一些复杂控制的动画，使用 javascript 会比较靠谱。而在实现一些小的交互动效的时候，就多考虑考虑 CSS 吧</span><br></pre></td></tr></table></figure><h2 id="get-请求传参长度的误区"><a href="#get-请求传参长度的误区" class="headerlink" title="get 请求传参长度的误区"></a>get 请求传参长度的误区</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">误区：我们经常说 get 请求参数的大小存在限制，而 post 请求的参数大小是无限制的。</span><br><span class="line"></span><br><span class="line">实际上 HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对 get 请求参数的限制是来源与浏览器或web 服务器，浏览器或 web 服务器限制了 url 的长度。为了明确这个概念，我们必须再次强调下面几点:</span><br></pre></td></tr></table></figure><ul><li>1.HTTP 协议未规定 GET 和 POST 的长度限制</li><li>2.GET 的最大长度显示是因为浏览器和 web 服务器限制了 URI 的长度</li><li>3.不同的浏览器和 WEB 服务器，限制的最大长度不一样</li><li>4.要支持 IE，则最大长度为 2083byte，若只支持 Chrome，则最大长度 8182byte</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端面试 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS面试知识点总结(十二)</title>
      <link href="/31888/"/>
      <url>/31888/</url>
      
        <content type="html"><![CDATA[<h2 id="使用-Object-defineProperty-来进行数据劫持有什么缺点？"><a href="#使用-Object-defineProperty-来进行数据劫持有什么缺点？" class="headerlink" title="使用 Object.defineProperty() 来进行数据劫持有什么缺点？"></a>使用 Object.defineProperty() 来进行数据劫持有什么缺点？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有一些对属性的操作，使用这种方法无法拦截，比如说通过下标方式修改数组数据或者给对象新增属性，vue 内部通过重写函数解决了这个问题。在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用 Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为这是 ES6 的语法。</span><br></pre></td></tr></table></figure><h2 id="什么是-Virtual-DOM？为什么-Virtual-DOM-比原生-DOM-快？"><a href="#什么是-Virtual-DOM？为什么-Virtual-DOM-比原生-DOM-快？" class="headerlink" title="什么是 Virtual DOM？为什么 Virtual DOM 比原生 DOM 快？"></a>什么是 Virtual DOM？为什么 Virtual DOM 比原生 DOM 快？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我对 Virtual DOM 的理解是，</span><br><span class="line"></span><br><span class="line">首先对我们将要插入到文档中的 DOM 树结构进行分析，使用 js 对象将其表示出来，比如一个元素对象，包含 TagName、props 和 Children 这些属性。然后我们将这个 js 对象树给保存下来，最后再将 DOM 片段插入到文档中。</span><br><span class="line"></span><br><span class="line">当页面的状态发生改变，我们需要对页面的 DOM 的结构进行调整的时候，我们首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的的差异。</span><br><span class="line"></span><br><span class="line">最后将记录的有差异的地方应用到真正的 DOM 树中去，这样视图就更新了。</span><br><span class="line"></span><br><span class="line">我认为 Virtual DOM 这种方法对于我们需要有大量的 DOM 操作的时候，能够很好的提高我们的操作效率，通过在操作前确定需要做的最小修改，尽可能的减少 DOM 操作带来的重流和重绘的影响。其实 Virtual DOM 并不一定比我们真实的操作 DOM 要快，这种方法的目的是为了提高我们开发时的可维护性，在任意的情况下，都能保证一个尽量小的性能消耗去进行操作。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc72e6e51d45054f664dbf">《Virtual DOM》</a><br><a href="https://github.com/y8n/blog/issues/5">《理解 Virtual DOM》</a><br><a href="https://github.com/livoras/blog/issues/13">《深度剖析：如何实现一个 Virtual DOM 算法》</a><br><a href="https://www.zhihu.com/question/31809713/answer/53544875">《网上都说操作真实 DOM 慢，但测试结果却比 React 更快，为什么？》</a></p><h2 id="如何比较两个-DOM-树的差异？"><a href="#如何比较两个-DOM-树的差异？" class="headerlink" title="如何比较两个 DOM 树的差异？"></a>如何比较两个 DOM 树的差异？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">两个树的完全 diff 算法的时间复杂度为 O(n^3) ，但是在前端中，我们很少会跨层级的移动元素，所以我们只需要比较同一层级的元素进行比较，这样就可以将算法的时间复杂度降低为 O(n)。</span><br><span class="line"></span><br><span class="line">算法首先会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个序号。在深度遍历的时候，每遍历到一个节点，我们就将这个节点和新的树中的节点进行比较，如果有差异，则将这个差异记录到一个对象中。</span><br><span class="line"></span><br><span class="line">在对列表元素进行对比的时候，由于 TagName 是重复的，所以我们不能使用这个来对比。我们需要给每一个子节点加上一个 key，列表对比的时候使用 key 来进行比较，这样我们才能够复用老的 DOM 树上的节点。</span><br></pre></td></tr></table></figure><h2 id="什么是-requestAnimationFrame-？"><a href="#什么是-requestAnimationFrame-？" class="headerlink" title="什么是 requestAnimationFrame ？"></a>什么是 requestAnimationFrame ？</h2><p>详细资料可以参考：<br><a href="https://juejin.im/post/5a82f0626fb9a06358657c9c">《你需要知道的 requestAnimationFrame》</a><br><a href="https://www.zhangxinxu.com/wordpress/2013/09/css3-animation-requestanimationframe-tween-%E5%8A%A8%E7%94%BB%E7%AE%97%E6%B3%95/">《CSS3 动画那么强，requestAnimationFrame 还有毛线用？》</a></p><h2 id="谈谈你对-webpack-的看法"><a href="#谈谈你对-webpack-的看法" class="headerlink" title="谈谈你对 webpack 的看法"></a>谈谈你对 webpack 的看法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我当时使用 webpack 的一个最主要原因是为了简化页面依赖的管理，并且通过将其打包为一个文件来降低页面加载时请求的资源</span><br><span class="line">数。</span><br><span class="line"></span><br><span class="line">我认为 webpack 的主要原理是，它将所有的资源都看成是一个模块，并且把页面逻辑当作一个整体，通过一个给定的入口文件，webpack 从这个文件开始，找到所有的依赖文件，将各个依赖文件模块通过 loader 和 plugins 处理后，然后打包在一起，最后输出一个浏览器可识别的 JS 文件。</span><br><span class="line"></span><br><span class="line">Webpack 具有四个核心的概念，分别是 Entry（入口）、Output（输出）、loader 和 Plugins（插件）。</span><br><span class="line"></span><br><span class="line">Entry 是 webpack 的入口起点，它指示 webpack 应该从哪个模块开始着手，来作为其构建内部依赖图的开始。</span><br><span class="line"></span><br><span class="line">Output 属性告诉 webpack 在哪里输出它所创建的打包文件，也可指定打包文件的名称，默认位置为 ./dist。</span><br><span class="line"></span><br><span class="line">loader 可以理解为 webpack 的编译器，它使得 webpack 可以处理一些非 JavaScript 文件。在对 loader 进行配置的时候，test 属性，标志有哪些后缀的文件应该被处理，是一个正则表达式。use 属性，指定 test 类型的文件应该使用哪个 loader 进行预处理。常用的 loader 有 css-loader、style-loader 等。</span><br><span class="line"></span><br><span class="line">插件可以用于执行范围更广的任务，包括打包、优化、压缩、搭建服务器等等，要使用一个插件，一般是先使用 npm 包管理器进行安装，然后在配置文件中引入，最后将其实例化后传递给 plugins 数组属性。</span><br><span class="line"></span><br><span class="line">使用 webpack 的确能够提供我们对于项目的管理，但是它的缺点就是调试和配置起来太麻烦了。但现在 webpack4.0 的免配置一定程度上解决了这个问题。但是我感觉就是对我来说，就是一个黑盒，很多时候出现了问题，没有办法很好的定位。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5b38d27451882574d87aa5d5#heading-0">《不聊 webpack 配置，来说说它的原理》</a><br><a href="https://juejin.im/entry/5b5724d05188251aa01647fd">《前端工程化——构建工具选型：grunt、gulp、webpack》</a><br><a href="https://juejin.im/post/5afa9cd0f265da0b981b9af9#heading-0">《浅入浅出 webpack》</a><br><a href="https://juejin.im/entry/5ae5c8c9f265da0b9f400d8e">《前端构建工具发展及其比较》</a></p><h2 id="offsetWidth-offsetHeight-clientWidth-clientHeight-与-scrollWidth-scrollHeight-的区别？"><a href="#offsetWidth-offsetHeight-clientWidth-clientHeight-与-scrollWidth-scrollHeight-的区别？" class="headerlink" title="offsetWidth/offsetHeight,clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别？"></a>offsetWidth/offsetHeight,clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clientWidth/clientHeight 返回的是元素的内部宽度，它的值只包含 content + padding，如果有滚动条，不包含滚动条。</span><br><span class="line">clientTop 返回的是上边框的宽度。</span><br><span class="line">clientLeft 返回的左边框的宽度。</span><br><span class="line"></span><br><span class="line">offsetWidth/offsetHeight 返回的是元素的布局宽度，它的值包含 content + padding + border 包含了滚动条。</span><br><span class="line">offsetTop 返回的是当前元素相对于其 offsetParent 元素的顶部的距离。</span><br><span class="line">offsetLeft 返回的是当前元素相对于其 offsetParent 元素的左部的距离。</span><br><span class="line"></span><br><span class="line">scrollWidth/scrollHeight 返回值包含 content + padding + 溢出内容的尺寸。</span><br><span class="line">scrollTop 属性返回的是一个元素的内容垂直滚动的像素数。</span><br><span class="line">scrollLeft 属性返回的是元素滚动条到元素左边的距离。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5bc9366d5188255c4834e75a">《最全的获取元素宽高及位置的方法》</a><br><a href="http://www.ruanyifeng.com/blog/2009/09/find_element_s_position_using_javascript.html">《用 Javascript 获取页面元素的位置》</a></p><h2 id="谈一谈你理解的函数式编程？"><a href="#谈一谈你理解的函数式编程？" class="headerlink" title="谈一谈你理解的函数式编程？"></a>谈一谈你理解的函数式编程？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">简单说，&quot;函数式编程&quot;是一种&quot;编程范式&quot;（programming paradigm），也就是如何编写程序的方法论。</span><br><span class="line"></span><br><span class="line">它具有以下特性：闭包和高阶函数、惰性计算、递归、函数是&quot;第一等公民&quot;、只用&quot;表达式&quot;。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2012/04/functional_programming.html">《函数式编程初探》</a></p><h2 id="异步编程的实现方式？"><a href="#异步编程的实现方式？" class="headerlink" title="异步编程的实现方式？"></a>异步编程的实现方式？</h2><p>相关资料：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">回调函数</span><br><span class="line">优点：简单、容易理解</span><br><span class="line">缺点：不利于维护，代码耦合高</span><br><span class="line"></span><br><span class="line">事件监听（采用时间驱动模式，取决于某个事件是否发生）：</span><br><span class="line">优点：容易理解，可以绑定多个事件，每个事件可以指定多个回调函数</span><br><span class="line">缺点：事件驱动型，流程不够清晰</span><br><span class="line"></span><br><span class="line">发布/订阅（观察者模式）</span><br><span class="line">类似于事件监听，但是可以通过‘消息中心’，了解现在有多少发布者，多少订阅者</span><br><span class="line"></span><br><span class="line">Promise 对象</span><br><span class="line">优点：可以利用 then 方法，进行链式写法；可以书写错误时的回调函数；</span><br><span class="line">缺点：编写和理解，相对比较难</span><br><span class="line"></span><br><span class="line">Generator 函数</span><br><span class="line">优点：函数体内外的数据交换、错误处理机制</span><br><span class="line">缺点：流程管理不方便</span><br><span class="line"></span><br><span class="line">async 函数</span><br><span class="line">优点：内置执行器、更好的语义、更广的适用性、返回的是 Promise、结构清晰。</span><br><span class="line">缺点：错误处理机制</span><br></pre></td></tr></table></figure><p>回答：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">js 中的异步机制可以分为以下几种：</span><br><span class="line"></span><br><span class="line">第一种最常见的是使用回调函数的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。</span><br><span class="line"></span><br><span class="line">第二种是 Promise 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。</span><br><span class="line"></span><br><span class="line">第三种是使用 generator 的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部我们还可以将执行权转移回来。当我们遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕的时候我们再将执行权给转移回来。因此我们在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式我们需要考虑的问题是何时将函数的控制权转移回来，因此我们需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。</span><br><span class="line"></span><br><span class="line">第四种是使用 async 函数的形式，async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此我们可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。</span><br></pre></td></tr></table></figure><h2 id="Js-动画与-CSS-动画区别及相应实现"><a href="#Js-动画与-CSS-动画区别及相应实现" class="headerlink" title="Js 动画与 CSS 动画区别及相应实现"></a>Js 动画与 CSS 动画区别及相应实现</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CSS3 的动画的优点</span><br><span class="line"></span><br><span class="line">在性能上会稍微好一些，浏览器会对 CSS3 的动画做一些优化</span><br><span class="line">代码相对简单</span><br><span class="line"></span><br><span class="line">缺点</span><br><span class="line"></span><br><span class="line">在动画控制上不够灵活</span><br><span class="line">兼容性不好</span><br><span class="line"></span><br><span class="line">JavaScript 的动画正好弥补了这两个缺点，控制能力很强，可以单帧的控制、变换，同时写得好完全可以兼容 IE6，并且功能强大。对于一些复杂控制的动画，使用 javascript 会比较靠谱。而在实现一些小的交互动效的时候，就多考虑考虑 CSS 吧</span><br></pre></td></tr></table></figure><h2 id="get-请求传参长度的误区"><a href="#get-请求传参长度的误区" class="headerlink" title="get 请求传参长度的误区"></a>get 请求传参长度的误区</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">误区：我们经常说 get 请求参数的大小存在限制，而 post 请求的参数大小是无限制的。</span><br><span class="line"></span><br><span class="line">实际上 HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对 get 请求参数的限制是来源与浏览器或web 服务器，浏览器或 web 服务器限制了 url 的长度。为了明确这个概念，我们必须再次强调下面几点:</span><br></pre></td></tr></table></figure><ul><li>1.HTTP 协议未规定 GET 和 POST 的长度限制</li><li>2.GET 的最大长度显示是因为浏览器和 web 服务器限制了 URI 的长度</li><li>3.不同的浏览器和 WEB 服务器，限制的最大长度不一样</li><li>4.要支持 IE，则最大长度为 2083byte，若只支持 Chrome，则最大长度 8182byte</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端面试 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS面试知识点总结(十一)</title>
      <link href="/32208/"/>
      <url>/32208/</url>
      
        <content type="html"><![CDATA[<h2 id="toPrecision-和-toFixed-和-Math-round-的区别？"><a href="#toPrecision-和-toFixed-和-Math-round-的区别？" class="headerlink" title="toPrecision 和 toFixed 和 Math.round 的区别？"></a>toPrecision 和 toFixed 和 Math.round 的区别？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">toPrecision 用于处理精度，精度是从左至右第一个不为 0 的数开始数起。</span><br><span class="line">toFixed 是对小数点后指定位数取整，从小数点开始数起。</span><br><span class="line">Math.round 是将一个数字四舍五入到一个整数。</span><br></pre></td></tr></table></figure><h2 id="什么是-XSS-攻击？如何防范-XSS-攻击？"><a href="#什么是-XSS-攻击？如何防范-XSS-攻击？" class="headerlink" title="什么是 XSS 攻击？如何防范 XSS 攻击？"></a>什么是 XSS 攻击？如何防范 XSS 攻击？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。</span><br><span class="line"></span><br><span class="line">XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。</span><br><span class="line"></span><br><span class="line">XSS 一般分为存储型、反射型和 DOM 型。</span><br><span class="line"></span><br><span class="line">存储型指的是恶意代码提交到了网站的数据库中，当用户请求数据的时候，服务器将其拼接为 HTML 后返回给了用户，从而导致了恶意代码的执行。</span><br><span class="line"></span><br><span class="line">反射型指的是攻击者构建了特殊的 URL，当服务器接收到请求后，从 URL 中获取数据，拼接到 HTML 后返回，从而导致了恶意代码的执行。</span><br><span class="line"></span><br><span class="line">DOM 型指的是攻击者构建了特殊的 URL，用户打开网站后，js 脚本从 URL 中获取数据，从而导致了恶意代码的执行。</span><br><span class="line"></span><br><span class="line">XSS 攻击的预防可以从两个方面入手，一个是恶意代码提交的时候，一个是浏览器执行恶意代码的时候。</span><br><span class="line"></span><br><span class="line">对于第一个方面，如果我们对存入数据库的数据都进行的转义处理，但是一个数据可能在多个地方使用，有的地方可能不需要转义，由于我们没有办法判断数据最后的使用场景，所以直接在输入端进行恶意代码的处理，其实是不太可靠的。</span><br><span class="line"></span><br><span class="line">因此我们可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回。另一种是对需要插入到 HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，我们对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。</span><br><span class="line"></span><br><span class="line">还有一些方式，比如使用 CSP ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。</span><br><span class="line"></span><br><span class="line">还可以对一些敏感信息进行保护，比如 cookie 使用 http-only ，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5bad9140e51d450e935c6d64">《前端安全系列（一）：如何防止 XSS 攻击？》</a></p><h2 id="什么是-CSP？"><a href="#什么是-CSP？" class="headerlink" title="什么是 CSP？"></a>什么是 CSP？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。</span><br><span class="line"></span><br><span class="line">通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式 &lt;meta</span><br><span class="line">http-equiv=&quot;Content-Security-Policy&quot;&gt;</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP">《内容安全策略（CSP）》</a><br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc721851882516c33430a2">《前端面试之道》</a></p><h2 id="什么是-CSRF-攻击？如何防范-CSRF-攻击？"><a href="#什么是-CSRF-攻击？如何防范-CSRF-攻击？" class="headerlink" title="什么是 CSRF 攻击？如何防范 CSRF 攻击？"></a>什么是 CSRF 攻击？如何防范 CSRF 攻击？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CSRF 攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被</span><br><span class="line">攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。</span><br><span class="line"></span><br><span class="line">CSRF 攻击的本质是利用了 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。</span><br><span class="line"></span><br><span class="line">一般的 CSRF 攻击类型有三种：</span><br><span class="line"></span><br><span class="line">第一种是 GET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提</span><br><span class="line">交。</span><br><span class="line"></span><br><span class="line">第二种是 POST 类型的 CSRF 攻击，比如说构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。</span><br><span class="line"></span><br><span class="line">第三种是链接类型的 CSRF 攻击，比如说在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。</span><br><span class="line"></span><br><span class="line">CSRF 可以用下面几种方法来防护：</span><br><span class="line"></span><br><span class="line">第一种是同源检测的方法，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止。这种方式的缺点是有些情况下 referer 可以被伪造。还有就是我们这种方法同时把搜索引擎的链接也给屏蔽了，所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。</span><br><span class="line"></span><br><span class="line">第二种方法是使用 CSRF Token 来进行验证，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果我们的请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况我们可以通过改变 token 的构建方式来解决。</span><br><span class="line"></span><br><span class="line">第三种方式使用双重 Cookie 验证的办法，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。</span><br><span class="line"></span><br><span class="line">第四种方式是使用在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5bc009996fb9a05d0a055192">《前端安全系列之二：如何防止 CSRF 攻击？》</a><br><a href="https://www.jianshu.com/p/1f9c71850299">《[ HTTP 趣谈] origin, referer 和 host 区别》</a></p><h2 id="什么是-Samesite-Cookie-属性？"><a href="#什么是-Samesite-Cookie-属性？" class="headerlink" title="什么是 Samesite Cookie 属性？"></a>什么是 Samesite Cookie 属性？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Samesite Cookie 表示同站 cookie，避免 cookie 被第三方所利用。</span><br><span class="line"></span><br><span class="line">将 Samesite 设为 strict ，这种称为严格模式，表示这个 cookie 在任何情况下都不可能作为第三方 cookie。</span><br><span class="line"></span><br><span class="line">将 Samesite 设为 Lax ，这种模式称为宽松模式，如果这个请求是个 GET 请求，并且这个请求改变了当前页面或者打开了新的页面，那么这个 cookie 可以作为第三方 cookie，其余情况下都不能作为第三方 cookie。</span><br><span class="line"></span><br><span class="line">使用这种方法的缺点是，因为它不支持子域，所以子域没有办法与主域共享登录信息，每次转入子域的网站，都回重新登录。还有一个问题就是它的兼容性不够好。</span><br></pre></td></tr></table></figure><h2 id="什么是点击劫持？如何防范点击劫持？"><a href="#什么是点击劫持？如何防范点击劫持？" class="headerlink" title="什么是点击劫持？如何防范点击劫持？"></a>什么是点击劫持？如何防范点击劫持？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">点击劫持是一种视觉欺骗的攻击手段，攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。</span><br><span class="line"></span><br><span class="line">我们可以在 http 相应头中设置 X-FRAME-OPTIONS 来防御用 iframe 嵌套的点击劫持攻击。通过不同的值，可以规定页面在特</span><br><span class="line">定的一些情况才能作为 iframe 来使用。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.jianshu.com/p/251704d8ff18">《web 安全之–点击劫持攻击与防御技术简介》</a></p><h2 id="SQL-注入攻击？"><a href="#SQL-注入攻击？" class="headerlink" title="SQL 注入攻击？"></a>SQL 注入攻击？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SQL 注入攻击指的是攻击者在 HTTP 请求中注入恶意的 SQL 代码，服务器使用参数构建数据库 SQL 命令时，恶意 SQL 被一起构</span><br><span class="line">造，破坏原有 SQL 结构，并在数据库中执行，达到编写程序时意料之外结果的攻击行为。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5bd5b820e51d456f72531fa8">《Web 安全漏洞之 SQL 注入》</a><br><a href="http://blog.720ui.com/2016/security_web/#SQL%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB">《如何防范常见的 Web 攻击》</a></p><h2 id="什么是-MVVM？比之-MVC-有什么区别？什么又是-MVP-？"><a href="#什么是-MVVM？比之-MVC-有什么区别？什么又是-MVP-？" class="headerlink" title="什么是 MVVM？比之 MVC 有什么区别？什么又是 MVP ？"></a>什么是 MVVM？比之 MVC 有什么区别？什么又是 MVP ？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化我们的开发效率。</span><br><span class="line"></span><br><span class="line">比如说我们实验室在以前项目开发的时候，使用单页应用时，往往一个路由页面对应了一个脚本文件，所有的页面逻辑都在一个脚本文件里。页面的渲染、数据的获取，对用户事件的响应所有的应用逻辑都混合在一起，这样在开发简单项目时，可能看不出什么问题，当时一旦项目变得复杂，那么整个文件就会变得冗长，混乱，这样对我们的项目开发和后期的项目维护是非常不利的。</span><br><span class="line"></span><br><span class="line">MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。并且 View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Co</span><br><span class="line">ntroller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。</span><br><span class="line"></span><br><span class="line">MVP 模式与 MVC 唯一不同的在于 Presenter 和 Controller。在 MVC 模式中我们使用观察者模式，来实现当 Model 层数据发生变化的时候，通知 View 层的更新。这样 View 层和 Model 层耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。MVP 的模式通过使用 Presenter 来实现对 View 层和 Model 层的解耦。MVC 中的</span><br><span class="line">Controller 只知道 Model 的接口，因此它没有办法控制 View 层的更新，MVP 模式中，View 层的接口暴露给了 Presenter 因此我们可以在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新。这样就实现了对 View 和 Model 的解耦，Presenter 还包含了其他的响应逻辑。</span><br><span class="line"></span><br><span class="line">MVVM 模式中的 VM，指的是 ViewModel，它和 MVP 的思想其实是相同的，不过它通过双向的数据绑定，将 View 和 Model 的同步更新给自动化了。当 Model 发生变化的时候，ViewModel 就会自动更新；ViewModel 变化了，View 也会更新。这样就将 Presenter 中的工作给自动化了。我了解过一点双向数据绑定的原理，比如 vue 是通过使用数据劫持和发布订阅者模式来实现的这一功</span><br><span class="line">能。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/593021272f301e0058273468">《浅析前端开发中的 MVC/MVP/MVVM 模式》</a><br><a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html">《MVC，MVP 和 MVVM 的图示》</a><br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc72e6e51d45054f664dbf">《MVVM》</a><br><a href="https://segmentfault.com/a/1190000015310674">《一篇文章了解架构模式：MVC/MVP/MVVM》</a></p><h2 id="vue-双向数据绑定原理？"><a href="#vue-双向数据绑定原理？" class="headerlink" title="vue 双向数据绑定原理？"></a>vue 双向数据绑定原理？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vue 通过使用双向数据绑定，来实现了 View 和 Model 的同步更新。vue 的双向数据绑定主要是通过使用数据劫持和发布订阅者模式来实现的。</span><br><span class="line"></span><br><span class="line">首先我们通过 Object.defineProperty() 方法来对 Model 数据各个属性添加访问器属性，以此来实现数据的劫持，因此当 Model 中的数据发生变化的时候，我们可以通过配置的 setter 和 getter 方法来实现对 View 层数据更新的通知。</span><br><span class="line"></span><br><span class="line">数据在 html 模板中一共有两种绑定情况，一种是使用 v-model 来对 value 值进行绑定，一种是作为文本绑定，在对模板引擎进行解析的过程中。</span><br><span class="line"></span><br><span class="line">如果遇到元素节点，并且属性值包含 v-model 的话，我们就从 Model 中去获取 v-model 所对应的属性的值，并赋值给元素的 value 值。然后给这个元素设置一个监听事件，当 View 中元素的数据发生变化的时候触发该事件，通知 Model 中的对应的属性的值进行更新。</span><br><span class="line"></span><br><span class="line">如果遇到了绑定的文本节点，我们使用 Model 中对应的属性的值来替换这个文本。对于文本节点的更新，我们使用了发布订阅者模式，属性作为一个主题，我们为这个节点设置一个订阅者对象，将这个订阅者对象加入这个属性主题的订阅者列表中。当 Model 层数据发生改变的时候，Model 作为发布者向主题发出通知，主题收到通知再向它的所有订阅者推送，订阅者收到通知后更改自己的数</span><br><span class="line">据。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://www.cnblogs.com/kidney/p/6052935.html?utm_source=gold_browser_extension">《Vue.js 双向绑定的实现原理》</a></p><h2 id="Object-defineProperty-介绍？"><a href="#Object-defineProperty-介绍？" class="headerlink" title="Object.defineProperty 介绍？"></a>Object.defineProperty 介绍？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object.defineProperty 函数一共有三个参数，第一个参数是需要定义属性的对象，第二个参数是需要定义的属性，第三个是该属性描述符。</span><br><span class="line"></span><br><span class="line">一个属性的描述符有四个属性，分别是 value 属性的值，writable 属性是否可写，enumerable 属性是否可枚举，configurable 属性是否可配置修改。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">《Object.defineProperty()》</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端面试 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS面试知识点总结(十)</title>
      <link href="/48401/"/>
      <url>/48401/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍一下-js-的节流与防抖？"><a href="#介绍一下-js-的节流与防抖？" class="headerlink" title="介绍一下 js 的节流与防抖？"></a>介绍一下 js 的节流与防抖？</h2><p>相关知识点：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数防抖： 在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数节流： 规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数防抖的实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="built_in">this</span>,</span><br><span class="line">      args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果此时存在定时器的话，则取消之前的定时器重新记时</span></span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">      timer = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置定时器，使事件间隔指定事件后执行</span></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数节流的实现;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> preTime = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="built_in">this</span>,</span><br><span class="line">      args = <span class="built_in">arguments</span>,</span><br><span class="line">      nowTime = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果两次时间间隔超过了指定时间，则执行函数。</span></span><br><span class="line">    <span class="keyword">if</span> (nowTime - preTime &gt;= delay) &#123;</span><br><span class="line">      preTime = <span class="built_in">Date</span>.now();</span><br><span class="line">      <span class="keyword">return</span> fn.apply(context, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回答：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。</span><br><span class="line"></span><br><span class="line">函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5a35ed25f265da431d3cc1b1">《轻松理解 JS 函数节流和函数防抖》</a><br><a href="https://juejin.im/post/5aa60b0e518825556b6c6d1a">《JavaScript 事件节流和事件防抖》</a><br><a href="https://juejin.im/entry/5b1d2d54f265da6e2545bfa4">《JS 的防抖与节流》</a></p><h2 id="Object-is-与原来的比较操作符-“-”、“-”-的区别？"><a href="#Object-is-与原来的比较操作符-“-”、“-”-的区别？" class="headerlink" title="Object.is() 与原来的比较操作符 “===”、“==” 的区别？"></a>Object.is() 与原来的比较操作符 “===”、“==” 的区别？</h2><p>相关知识点：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">两等号判等，会在比较时进行类型转换。</span><br><span class="line">三等号判等（判断严格），比较时不进行隐式类型转换，（类型不同则会返回false）。</span><br><span class="line"></span><br><span class="line">Object.is 在三等号判等的基础上特别处理了 NaN 、-0 和 +0 ，保证 -0 和 +0 不再相同，但 Object.is(NaN, NaN) 会返回 true.</span><br><span class="line"></span><br><span class="line">Object.is 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。</span><br></pre></td></tr></table></figure><p>回答：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用双等号进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较。</span><br><span class="line"></span><br><span class="line">使用三等号进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false。</span><br><span class="line"></span><br><span class="line">使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 认定为是相等的。</span><br></pre></td></tr></table></figure><h2 id="escape-encodeURI-encodeURIComponent-有什么区别？"><a href="#escape-encodeURI-encodeURIComponent-有什么区别？" class="headerlink" title="escape,encodeURI,encodeURIComponent 有什么区别？"></a>escape,encodeURI,encodeURIComponent 有什么区别？</h2><p>相关知识点：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">escape 和 encodeURI 都属于 Percent-encoding，基本功能都是把 URI 非法字符转化成合法字符，转化后形式类似「%*」。</span><br><span class="line">它们的根本区别在于，escape 在处理 0xff 之外字符的时候，是直接使用字符的 unicode 在前面加上一个「%u」，而 encode URI 则是先进行 UTF-8，再在 UTF-8 的每个字节码前加上一个「%」；在处理 0xff 以内字符时，编码方式是一样的（都是「%XX」，XX 为字符的 16 进制 unicode，同时也是字符的 UTF-8），只是范围（即哪些字符编码哪些字符不编码）不一样。</span><br></pre></td></tr></table></figure><p>回答：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">encodeURI 是对整个 URI 进行转义，将 URI 中的非法字符转换为合法字符，所以对于一些在 URI 中有特殊意义的字符不会进行转义。</span><br><span class="line"></span><br><span class="line">encodeURIComponent 是对 URI 的组成部分进行转义，所以一些特殊字符也会得到转义。</span><br><span class="line"></span><br><span class="line">escape 和 encodeURI 的作用相同，不过它们对于 unicode 编码为 0xff 之外字符的时候会有区别，escape 是直接在字符的 unicode 编码前加上 %u，而 encodeURI 首先会将字符转换为 UTF-8 的格式，再在每个字节前加上 %。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/21861899">《escape,encodeURI,encodeURIComponent 有什么区别?》</a></p><h2 id="Unicode-和-UTF-8-之间的关系？"><a href="#Unicode-和-UTF-8-之间的关系？" class="headerlink" title="Unicode 和 UTF-8 之间的关系？"></a>Unicode 和 UTF-8 之间的关系？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Unicode 是一种字符集合，现在可容纳 100 多万个字符。每个字符对应一个不同的 Unicode 编码，它只规定了符号的二进制代码，却没有规定这个二进制代码在计算机中如何编码传输。</span><br><span class="line"></span><br><span class="line">UTF-8 是一种对 Unicode 的编码方式，它是一种变长的编码方式，可以用 1~4 个字节来表示一个字符。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.51cto.com/polaris/377468">《字符编码详解》</a><br><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html">《字符编码笔记：ASCII，Unicode 和 UTF-8》</a></p><h2 id="js-的事件循环是什么？"><a href="#js-的事件循环是什么？" class="headerlink" title="js 的事件循环是什么？"></a>js 的事件循环是什么？</h2><p>相关知识点：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">事件队列是一个存储着待执行任务的队列，其中的任务严格按照时间先后顺序执行，排在队头的任务将会率先执行，而排在队尾的任务会最后执行。事件队列每次仅执行一个任务，在该任务执行完毕之后，再执行下一个任务。执行栈则是一个类似于函数调用栈的运行容器，当执行栈为空时，JS 引擎便检查事件队列，如果不为空的话，事件队列便将第一个任务压入执行栈中运行。</span><br></pre></td></tr></table></figure><p>回答：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">因为 js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当异步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。</span><br><span class="line"></span><br><span class="line">微任务包括了 promise 的回调、node 中的 process.nextTick 、对 Dom 变化监听的 MutationObserver。</span><br><span class="line"></span><br><span class="line">宏任务包括了 script 脚本的执行、setTimeout ，setInterval ，setImmediate 一类的定时事件，还有如 I/O 操作、UI 渲</span><br><span class="line">染等。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5afbc62151882542af04112d">《浏览器事件循环机制（event loop）》</a><br><a href="https://zhuanlan.zhihu.com/p/33058983">《详解 JavaScript 中的 Event Loop（事件循环）机制》</a><br><a href="http://www.ruanyifeng.com/blog/2013/10/event_loop.html">《什么是 Event Loop？》</a><br><a href="https://juejin.im/post/59e85eebf265da430d571f89">《这一次，彻底弄懂 JavaScript 执行机制》</a></p><h2 id="js-中的深浅拷贝实现？"><a href="#js-中的深浅拷贝实现？" class="headerlink" title="js 中的深浅拷贝实现？"></a>js 中的深浅拷贝实现？</h2><p>相关资料：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 浅拷贝的实现;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowCopy</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 只拷贝对象</span></span><br><span class="line">  <span class="keyword">if</span> (!object || <span class="keyword">typeof</span> object !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据 object 的类型判断是新建一个数组还是对象</span></span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="built_in">Array</span>.isArray(object) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历 object，并且判断是 object 的属性才拷贝</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">    <span class="keyword">if</span> (object.hasOwnProperty(key)) &#123;</span><br><span class="line">      newObject[key] = object[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 深拷贝的实现;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!object || <span class="keyword">typeof</span> object !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span> object;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="built_in">Array</span>.isArray(object) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">    <span class="keyword">if</span> (object.hasOwnProperty(key)) &#123;</span><br><span class="line">      newObject[key] = deepCopy(object[key]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回答：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">浅拷贝指的是将一个对象的属性值复制到另一个对象，如果有的属性的值为引用类型的话，那么会将这个引用的地址复制给对象，因此两个对象会有同一个引用类型的引用。浅拷贝可以使用  Object.assign 和展开运算符来实现。</span><br><span class="line"></span><br><span class="line">深拷贝相对浅拷贝而言，如果遇到属性值为引用类型的时候，它新建一个引用类型并将对应的值复制给它，因此对象获得的一个新的引用类型而不是一个原有类型的引用。深拷贝对于一些对象可以使用 JSON 的两个函数来实现，但是由于 JSON 的对象格式比 js 的对象格式更加严格，所以如果属性值里边出现函数或者 Symbol 类型的值时，会转换失败。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://github.com/mqyqingfeng/Blog/issues/32">《JavaScript 专题之深浅拷贝》</a><br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bed40d951882545f73004f6">《前端面试之道》</a></p><h2 id="手写-call、apply-及-bind-函数"><a href="#手写-call、apply-及-bind-函数" class="headerlink" title="手写 call、apply 及 bind 函数"></a>手写 call、apply 及 bind 函数</h2><p>相关资料：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// call函数实现</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断调用对象</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">&quot;type error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取参数</span></span><br><span class="line">  <span class="keyword">let</span> args = [...arguments].slice(<span class="number">1</span>),</span><br><span class="line">    result = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断 context 是否传入，如果未传入则设置为 window</span></span><br><span class="line">  context = context || <span class="built_in">window</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将调用函数设为对象的方法</span></span><br><span class="line">  context.fn = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用函数</span></span><br><span class="line">  result = context.fn(...args);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将属性删除</span></span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// apply 函数实现</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断调用对象是否为函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断 context 是否存在，如果未传入则为 window</span></span><br><span class="line">  context = context || <span class="built_in">window</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将函数设为对象的方法</span></span><br><span class="line">  context.fn = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">    result = context.fn(...arguments[<span class="number">1</span>]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = context.fn();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将属性删除</span></span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bind 函数实现</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断调用对象是否为函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取参数</span></span><br><span class="line">  <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>),</span><br><span class="line">    fn = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 根据调用方式，传入不同绑定值</span></span><br><span class="line">    <span class="keyword">return</span> fn.apply(</span><br><span class="line">      <span class="built_in">this</span> <span class="keyword">instanceof</span> Fn ? <span class="built_in">this</span> : context,</span><br><span class="line">      args.concat(...arguments)</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>回答：</p><p>call 函数的实现步骤：</p><ul><li>1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>2.判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li><li>3.处理传入的参数，截取第一个参数后的所有参数。</li><li>4.将函数作为上下文对象的一个属性。</li><li>5.使用上下文对象来调用这个方法，并保存返回结果。</li><li>6.删除刚才新增的属性。</li><li>7.返回结果。</li></ul><p>apply 函数的实现步骤：</p><ul><li>1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>2.判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li><li>3.将函数作为上下文对象的一个属性。</li><li>4.判断参数值是否传入</li><li>4.使用上下文对象来调用这个方法，并保存返回结果。</li><li>5.删除刚才新增的属性</li><li>6.返回结果</li></ul><p>bind 函数的实现步骤：</p><ul><li>1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>2.保存当前函数的引用，获取其余传入参数值。</li><li>3.创建一个函数返回</li><li>4.函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。</li></ul><p>详细资料可以参考：<br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdd0d8e6fb9a04a044073fe">《手写 call、apply 及 bind 函数》</a><br><a href="https://github.com/mqyqingfeng/Blog/issues/11">《JavaScript 深入之 call 和 apply 的模拟实现》</a></p><h2 id="函数柯里化的实现"><a href="#函数柯里化的实现" class="headerlink" title="函数柯里化的实现"></a>函数柯里化的实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn, args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取函数需要的参数长度</span></span><br><span class="line">  <span class="keyword">let</span> length = fn.length;</span><br><span class="line"></span><br><span class="line">  args = args || [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> subArgs = args.slice(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接得到现有的所有参数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">      subArgs.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断参数的长度是否已经满足函数所需参数的长度</span></span><br><span class="line">    <span class="keyword">if</span> (subArgs.length &gt;= length) &#123;</span><br><span class="line">      <span class="comment">// 如果满足，执行函数</span></span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="built_in">this</span>, subArgs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果不满足，递归返回科里化的函数，等待参数的传入</span></span><br><span class="line">      <span class="keyword">return</span> curry.call(<span class="built_in">this</span>, fn, subArgs);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6 实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fn.length &lt;= args.length ? fn(...args) : curry.bind(<span class="literal">null</span>, fn, ...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://github.com/mqyqingfeng/Blog/issues/42">《JavaScript 专题之函数柯里化》</a></p><h2 id="为什么-0-1-0-2-0-3？如何解决这个问题？"><a href="#为什么-0-1-0-2-0-3？如何解决这个问题？" class="headerlink" title="为什么 0.1 + 0.2 != 0.3？如何解决这个问题？"></a>为什么 0.1 + 0.2 != 0.3？如何解决这个问题？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当计算机计算 0.1+0.2 的时候，实际上计算的是这两个数字在计算机里所存储的二进制，0.1 和 0.2 在转换为二进制表示的时候会出现位数无限循环的情况。js 中是以 64 位双精度格式来存储数字的，只有 53 位的有效数字，超过这个长度的位数会被截取掉这样就造成了精度丢失的问题。这是第一个会造成精度丢失的地方。在对两个以 64 位双精度格式的数据进行计算的时候，首先会进行对阶的处理，对阶指的是将阶码对齐，也就是将小数点的位置对齐后，再进行计算，一般是小阶向大阶对齐，因此小阶的数在对齐的过程中，有效数字会向右移动，移动后超过有效位数的位会被截取掉，这是第二个可能会出现精度丢失的地方。当两个数据阶码对齐后，进行相加运算后，得到的结果可能会超过 53 位有效数字，因此超过的位数也会被截取掉，这是可能发生精度丢失的第三个地方。</span><br><span class="line"></span><br><span class="line">对于这样的情况，我们可以将其转换为整数后再进行运算，运算后再转换为对应的小数，以这种方式来解决这个问题。</span><br><span class="line"></span><br><span class="line">我们还可以将两个数相加的结果和右边相减，如果相减的结果小于一个极小数，那么我们就可以认定结果是相等的，这个极小数可以</span><br><span class="line">使用 es6 的 Number.EPSILON</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/Lixuanshengchao/article/details/82049191">《十进制的 0.1 为什么不能用二进制很好的表示？》</a><br><a href="https://blog.csdn.net/zhengyanan815/article/details/78550073">《十进制浮点数转成二进制》</a><br><a href="http://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html">《浮点数的二进制表示》</a><br><a href="https://juejin.im/post/5b372f106fb9a00e6714aa21">《js 浮点数存储精度丢失原理》</a><br><a href="https://juejin.im/post/594a31d0a0bb9f006b0b2624">《浮点数精度之谜》</a><br><a href="https://github.com/camsong/blog/issues/9">《JavaScript 浮点数陷阱及解法》</a><br><a href="https://juejin.im/post/5bd2f10a51882555e072d0c4">《0.1+0.2 !== 0.3？》</a><br><a href="https://juejin.im/entry/59cdd7fb6fb9a00a600f8eef">《JavaScript 中奇特的~运算符》</a></p><h2 id="原码、反码和补码的介绍"><a href="#原码、反码和补码的介绍" class="headerlink" title="原码、反码和补码的介绍"></a>原码、反码和补码的介绍</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原码是计算机中对数字的二进制的定点表示方法，最高位表示符号位，其余位表示数值位。优点是易于分辨，缺点是不能够直接参与运算。</span><br><span class="line"></span><br><span class="line">正数的反码和其原码一样；负数的反码，符号位为1，数值部分按原码取反。</span><br><span class="line">如 [+7]原 = 00000111，[+7]反 = 00000111； [-7]原 = 10000111，[-7]反 = 11111000。</span><br><span class="line"></span><br><span class="line">正数的补码和其原码一样；负数的补码为其反码加1。</span><br><span class="line"></span><br><span class="line">例如 [+7]原 = 00000111，[+7]反 = 00000111，[+7]补 = 00000111；</span><br><span class="line">[-7]原 = 10000111，[-7]反 = 11111000，[-7]补 = 11111001</span><br><span class="line"></span><br><span class="line">之所以在计算机中使用补码来表示负数的原因是，这样可以将加法运算扩展到所有的数值计算上，因此在数字电路中我们只需要考虑加法器的设计就行了，而不用再为减法设置新的数字电路。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2009/08/twos_complement.html">《关于 2 的补码》</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端面试 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS面试知识点总结(九)</title>
      <link href="/5788/"/>
      <url>/5788/</url>
      
        <content type="html"><![CDATA[<h2 id="哪些操作会造成内存泄漏？"><a href="#哪些操作会造成内存泄漏？" class="headerlink" title="哪些操作会造成内存泄漏？"></a>哪些操作会造成内存泄漏？</h2><p>相关知识点：</p><ul><li>1.意外的全局变量</li><li>2.被遗忘的计时器或回调函数</li><li>3.脱离 DOM 的引用</li><li>4.闭包</li></ul><p>回答：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一种情况是我们由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</span><br><span class="line"></span><br><span class="line">第二种情况是我们设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留</span><br><span class="line">在内存中，而无法被回收。</span><br><span class="line"></span><br><span class="line">第三种情况是我们获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回</span><br><span class="line">收。</span><br><span class="line"></span><br><span class="line">第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2017/04/memory-leak.html">《JavaScript 内存泄漏教程》</a><br><a href="https://jinlong.github.io/2016/05/01/4-Types-of-Memory-Leaks-in-JavaScript-and-How-to-Get-Rid-Of-Them/">《4 类 JavaScript 内存泄漏及如何避免》</a><br><a href="https://juejin.im/entry/5a64366c6fb9a01c9332c706">《杜绝 js 中四种内存泄漏类型的发生》</a><br><a href="https://segmentfault.com/a/1190000008901861">《javascript 典型内存泄漏及 chrome 的排查方法》</a></p><h2 id="需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？"><a href="#需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？" class="headerlink" title="需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？"></a>需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过使用 pushState + ajax 实现浏览器无刷新前进后退，当一次 ajax 调用成功后我们将一条 state 记录加入到 history</span><br><span class="line">对象中。一条 state 记录包含了 url、title 和 content 属性，在 popstate 事件中可以获取到这个 state 对象，我们可</span><br><span class="line">以使用 content 来传递数据。最后我们通过对 window.onpopstate 事件监听来响应浏览器的前进后退操作。</span><br><span class="line"></span><br><span class="line">使用 pushState 来实现有两个问题，一个是打开首页时没有记录，我们可以使用 replaceState 来将首页的记录替换，另一个问</span><br><span class="line">题是当一个页面刷新的时候，仍然会向服务器端请求数据，因此如果请求的 url 需要后端的配合将其重定向到一个页面。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://blog.chenxu.me/post/detail?id=ed4f0732-897f-48e4-9d4f-821e82f17fad">《pushState + ajax 实现浏览器无刷新前进后退》</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/History_API">《Manipulating the browser history》</a></p><h2 id="如何判断当前脚本运行在浏览器还是-node-环境中？（阿里）"><a href="#如何判断当前脚本运行在浏览器还是-node-环境中？（阿里）" class="headerlink" title="如何判断当前脚本运行在浏览器还是 node 环境中？（阿里）"></a>如何判断当前脚本运行在浏览器还是 node 环境中？（阿里）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typeof window === &#x27;undefined&#x27; ? &#x27;node&#x27; : &#x27;browser&#x27;;</span><br><span class="line"></span><br><span class="line">通过判断当前环境的 window 对象类型是否为 undefined，如果是undefined，则说明当前脚本运行在node环境，否则说明运行在window环境。</span><br></pre></td></tr></table></figure><h2 id="把-script-标签放在页面的最底部的-body-封闭之前和封闭之后有什么区别？浏览器会如何解析它们？"><a href="#把-script-标签放在页面的最底部的-body-封闭之前和封闭之后有什么区别？浏览器会如何解析它们？" class="headerlink" title="把 script 标签放在页面的最底部的 body 封闭之前和封闭之后有什么区别？浏览器会如何解析它们？"></a>把 script 标签放在页面的最底部的 body 封闭之前和封闭之后有什么区别？浏览器会如何解析它们？</h2><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/20027966">《为什么把 script 标签放在 body 结束标签之后 html 结束标签之前？》</a><br><a href="https://zhuanlan.zhihu.com/p/30558018">《从 Chrome 源码看浏览器如何加载资源》</a></p><h2 id="移动端的点击事件的有延迟，时间是多久，为什么会有？-怎么解决这个延时？"><a href="#移动端的点击事件的有延迟，时间是多久，为什么会有？-怎么解决这个延时？" class="headerlink" title="移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？"></a>移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">移动端点击有 300ms 的延迟是因为移动端会有双击缩放的这个操作，因此浏览器在 click 之后要等待 300ms，看用户有没有下一次点击，来判断这次操作是不是双击。</span><br></pre></td></tr></table></figure><p>有三种办法来解决这个问题：</p><ul><li>1.通过 meta 标签禁用网页的缩放。</li><li>2.通过 meta 标签将网页的 viewport 设置为 ideal viewport。</li><li>3.调用一些 js 库，比如 FastClick</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">click 延时问题还可能引起点击穿透的问题，就是如果我们在一个元素上注册了 touchStart 的监听事件，这个事件会将这个元素隐藏掉，我们发现当这个元素隐藏后，触发了这个元素下的一个元素的点击事件，这就是点击穿透。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5b3cc9836fb9a04f9a5cb0e0">《移动端 300ms 点击延迟和点击穿透》</a></p><h2 id="什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？"><a href="#什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？" class="headerlink" title="什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？"></a>什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）什么是前端路由？</span><br><span class="line"></span><br><span class="line">前端路由就是把不同路由对应不同的内容或页面的任务交给前端来做，之前是通过服务端根据 url 的不同返回不同的页面实现的。</span><br><span class="line"></span><br><span class="line">（2）什么时候使用前端路由？</span><br><span class="line"></span><br><span class="line">在单页面应用，大部分页面结构不变，只改变部分内容的使用</span><br><span class="line"></span><br><span class="line">（3）前端路由有什么优点和缺点？</span><br><span class="line"></span><br><span class="line">优点：用户体验好，不需要每次都从服务器全部获取，快速展现给用户</span><br><span class="line"></span><br><span class="line">缺点：单页面无法记住之前滚动的位置，无法在前进，后退的时候记住滚动的位置</span><br><span class="line"></span><br><span class="line">前端路由一共有两种实现方式，一种是通过 hash 的方式，一种是通过使用 pushState 的方式。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://segmentfault.com/q/1010000005336260">《什么是“前端路由”》</a><br><a href="https://github.com/kaola-fed/blog/issues/137">《浅谈前端路由》 </a><br><a href="https://www.zhihu.com/question/53064386">《前端路由是什么东西？》</a></p><h2 id="如何测试前端代码么？-知道-BDD-TDD-Unit-Test-么？-知道怎么测试你的前端工程么-mocha-sinon-jasmin-qUnit-？"><a href="#如何测试前端代码么？-知道-BDD-TDD-Unit-Test-么？-知道怎么测试你的前端工程么-mocha-sinon-jasmin-qUnit-？" class="headerlink" title="如何测试前端代码么？ 知道 BDD, TDD, Unit Test 么？ 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)？"></a>如何测试前端代码么？ 知道 BDD, TDD, Unit Test 么？ 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)？</h2><p>详细资料可以参考：<br><a href="https://juejin.im/post/5b2da89cf265da597f1c7cab">《浅谈前端单元测试》</a></p><h2 id="检测浏览器版本版本有哪些方式？"><a href="#检测浏览器版本版本有哪些方式？" class="headerlink" title="检测浏览器版本版本有哪些方式？"></a>检测浏览器版本版本有哪些方式？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">检测浏览器版本一共有两种方式：</span><br><span class="line"></span><br><span class="line">一种是检测 window.navigator.userAgent 的值，但这种方式很不可靠，因为 userAgent 可以被改写，并且早期的浏览器如 ie，会通过伪装自己的 userAgent 的值为 Mozilla 来躲过服务器的检测。</span><br><span class="line"></span><br><span class="line">第二种方式是功能检测，根据每个浏览器独有的特性来进行判断，如 ie 下独有的 ActiveXObject。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.jianshu.com/p/d99f4ca385ac">《JavaScript 判断浏览器类型》</a></p><h2 id="什么是-Polyfill-？"><a href="#什么是-Polyfill-？" class="headerlink" title="什么是 Polyfill ？"></a>什么是 Polyfill ？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Polyfill 指的是用于实现浏览器并不支持的原生 API 的代码。</span><br><span class="line"></span><br><span class="line">比如说 querySelectorAll 是很多现代浏览器都支持的原生 Web API，但是有些古老的浏览器并不支持，那么假设有人写了一段代码来实现这个功能使这些浏览器也支持了这个功能，那么这就可以成为一个 Polyfill。</span><br><span class="line"></span><br><span class="line">一个 shim 是一个库，有自己的 API，而不是单纯实现原生不支持的 API。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000002593432">《Web 开发中的“黑话”》</a><br><a href="https://juejin.im/post/5a579bc7f265da3e38496ba1">《Polyfill 为何物》</a></p><h2 id="使用-JS-实现获取文件扩展名？"><a href="#使用-JS-实现获取文件扩展名？" class="headerlink" title="使用 JS 实现获取文件扩展名？"></a>使用 JS 实现获取文件扩展名？</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String.lastIndexOf() 方法返回指定值（本例中的&#x27;.&#x27;）在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于 &#x27;filename&#x27; 和 &#x27;.hiddenfile&#x27; ，lastIndexOf 的返回值分别为 0 和 -1 无符号右移操作符(&gt;&gt;&gt;) 将 -1 转换为 4294967295 ，将 -2 转换为 4294967294 ，这个方法可以保证边缘情况时文件名不变。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// String.prototype.slice() 从上面计算的索引处提取文件的扩展名。如果索引比文件名的长度大，结果为&quot;&quot;。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFileExtension</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> filename.slice(((filename.lastIndexOf(<span class="string">&quot;.&quot;</span>) - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">0</span>) + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000004993946">《如何更有效的获取文件扩展名》</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端面试 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS面试知识点总结(八)</title>
      <link href="/54877/"/>
      <url>/54877/</url>
      
        <content type="html"><![CDATA[<h2 id="DOM-操作——怎样添加、移除、移动、复制、创建和查找节点？"><a href="#DOM-操作——怎样添加、移除、移动、复制、创建和查找节点？" class="headerlink" title="DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？"></a>DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？</h2><p>（1）创建新节点</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">createDocumentFragment(node);</span><br><span class="line">createElement(node);</span><br><span class="line">createTextNode(text);</span><br></pre></td></tr></table></figure><p>（2）添加、移除、替换、插入</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">appendChild(node)</span><br><span class="line">removeChild(node)</span><br><span class="line">replaceChild(<span class="keyword">new</span>,old)</span><br><span class="line">insertBefore(<span class="keyword">new</span>,old)</span><br></pre></td></tr></table></figure><p>（3）查找</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getElementById();</span><br><span class="line">getElementsByName();</span><br><span class="line">getElementsByTagName();</span><br><span class="line">getElementsByClassName();</span><br><span class="line">querySelector();</span><br><span class="line">querySelectorAll();</span><br></pre></td></tr></table></figure><p>（4）属性操作</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getAttribute(key);</span><br><span class="line">setAttribute(key, value);</span><br><span class="line">hasAttribute(key);</span><br><span class="line">removeAttribute(key);</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model/Introduction#DOM_interfaces">《DOM 概述》</a><br><a href="https://harttle.land/2015/10/01/javascript-dom-api.html">《原生 JavaScript 的 DOM 操作汇总》</a><br><a href="https://microzz.com/2017/04/06/jsdom/">《原生 JS 中 DOM 节点相关 API 合集》</a></p><h2 id="innerHTML-与-outerHTML-的区别？"><a href="#innerHTML-与-outerHTML-的区别？" class="headerlink" title="innerHTML 与 outerHTML 的区别？"></a>innerHTML 与 outerHTML 的区别？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于这样一个 HTML 元素：&lt;div&gt;content&lt;br/&gt;&lt;/div&gt;。</span><br><span class="line"></span><br><span class="line">innerHTML：内部 HTML，content&lt;br/&gt;；</span><br><span class="line">outerHTML：外部 HTML，&lt;div&gt;content&lt;br/&gt;&lt;/div&gt;；</span><br><span class="line">innerText：内部文本，content ；</span><br><span class="line">outerText：内部文本，content ；</span><br></pre></td></tr></table></figure><h2 id="call-和-apply-的区别？"><a href="#call-和-apply-的区别？" class="headerlink" title=".call() 和 .apply() 的区别？"></a>.call() 和 .apply() 的区别？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">它们的作用一模一样，区别仅在于传入参数的形式的不同。</span><br><span class="line"></span><br><span class="line">apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。</span><br><span class="line"></span><br><span class="line">call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/entry/58d0a7b22f301e007e5a15ae">《apply、call 的区别和用途》</a></p><h2 id="JavaScript-类数组对象的定义？"><a href="#JavaScript-类数组对象的定义？" class="headerlink" title="JavaScript 类数组对象的定义？"></a>JavaScript 类数组对象的定义？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。</span><br><span class="line"></span><br><span class="line">常见的类数组对象有 arguments 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length</span><br><span class="line">属性值，代表可接收的参数个数。</span><br></pre></td></tr></table></figure><p>常见的类数组转换为数组的方法有这样几种：</p><p>（1）通过 call 调用数组的 slice 方法来实现转换</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.slice.call(arrayLike);</span><br></pre></td></tr></table></figure><p>（2）通过 call 调用数组的 splice 方法来实现转换</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.splice.call(arrayLike, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>（3）通过 apply 调用数组的 concat 方法来实现转换</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.concat.apply([], arrayLike);</span><br></pre></td></tr></table></figure><p>（4）通过 Array.from 方法来实现转换</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(arrayLike);</span><br></pre></td></tr></table></figure><p>详细的资料可以参考：<br><a href="https://github.com/mqyqingfeng/Blog/issues/14">《JavaScript 深入之类数组对象与 arguments》</a><br><a href="https://segmentfault.com/a/1190000000415572">《javascript 类数组》</a><br><a href="https://blog.lxxyx.cn/2016/05/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E7%B1%BB%E6%95%B0%E7%BB%84/">《深入理解 JavaScript 类数组》</a></p><h2 id="数组和对象有哪些原生方法，列举一下？"><a href="#数组和对象有哪些原生方法，列举一下？" class="headerlink" title="数组和对象有哪些原生方法，列举一下？"></a>数组和对象有哪些原生方法，列举一下？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。</span><br><span class="line"></span><br><span class="line">数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。</span><br><span class="line"></span><br><span class="line">数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。</span><br><span class="line"></span><br><span class="line">数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。</span><br><span class="line"></span><br><span class="line">数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。</span><br><span class="line"></span><br><span class="line">数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法</span><br><span class="line"></span><br><span class="line">数组归并方法 reduce() 和 reduceRight() 方法</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8BArray%E8%AF%A6%E8%A7%A3.html">《JavaScript 深入理解之 Array 类型详解》</a></p><h2 id="数组的-fill-方法？"><a href="#数组的-fill-方法？" class="headerlink" title="数组的 fill 方法？"></a>数组的 fill 方法？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。</span><br><span class="line">fill 方法接受三个参数 value，start 以及 end，start 和 end 参数是可选的，其默认值分别为 0 和 this 对象的 length 属性值。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/fill">《Array.prototype.fill()》</a></p><h2 id="的长度？"><a href="#的长度？" class="headerlink" title="[,,,] 的长度？"></a>[,,,] 的长度？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">尾后逗号 （有时叫做“终止逗号”）在向 JavaScript 代码添加元素、参数、属性时十分有用。如果你想要添加新的属性，并且上一行已经使用了尾后逗号，你可以仅仅添加新的一行，而不需要修改上一行。这使得版本控制更加清晰，以及代码维护麻烦更少。</span><br><span class="line"></span><br><span class="line">JavaScript 一开始就支持数组字面值中的尾后逗号，随后向对象字面值（ECMAScript 5）中添加了尾后逗号。最近（ECMAS</span><br><span class="line">cript 2017），又将其添加到函数参数中。但是 JSON 不支持尾后逗号。</span><br><span class="line"></span><br><span class="line">如果使用了多于一个尾后逗号，会产生间隙。 带有间隙的数组叫做稀疏数组（密致数组没有间隙）。稀疏数组的长度为逗号的数</span><br><span class="line">量。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Trailing_commas">《尾后逗号》</a></p><h2 id="JavaScript-中的作用域与变量声明提升？"><a href="#JavaScript-中的作用域与变量声明提升？" class="headerlink" title="JavaScript 中的作用域与变量声明提升？"></a>JavaScript 中的作用域与变量声明提升？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">变量提升的表现是，无论我们在函数中何处位置声明的变量，好像都被提升到了函数的首部，我们可以在变量声明前访问到而不会报错。</span><br><span class="line"></span><br><span class="line">造成变量声明提升的本质原因是 js 引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象。当我们访问一个变量时，我们会到当前执行上下文中的作用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象，这个变量对象是执行上下文的一个属性，它包含了函数的形参、所有的函数和变量声明，这个对象的是在代码解析的时候创建的。这就是会出现变量声明提升的根本原因。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1.html">《JavaScript 深入理解之变量对象》</a></p><h2 id="如何编写高性能的-Javascript-？"><a href="#如何编写高性能的-Javascript-？" class="headerlink" title="如何编写高性能的 Javascript ？"></a>如何编写高性能的 Javascript ？</h2><ul><li>1.使用位运算代替一些简单的四则运算。</li><li>2.避免使用过深的嵌套循环。</li><li>3.不要使用未定义的变量。</li><li>4.当需要多次访问数组长度时，可以用变量保存起来，避免每次都会去进行属性查找。</li></ul><p>详细资料可以参考：<br><a href="https://zhuanlan.zhihu.com/p/34780474">《如何编写高性能的 Javascript？》</a></p><h2 id="简单介绍一下-V8-引擎的垃圾回收机制"><a href="#简单介绍一下-V8-引擎的垃圾回收机制" class="headerlink" title="简单介绍一下 V8 引擎的垃圾回收机制"></a>简单介绍一下 V8 引擎的垃圾回收机制</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v8 的垃圾回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另一个是不死的对象会活得更久。基于这个假说，v8 引擎将内存分为了新生代和老生代。</span><br><span class="line"></span><br><span class="line">新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代。</span><br><span class="line"></span><br><span class="line">新生代被分为 From 和 To 两个空间，To 一般是闲置的。当 From 空间满了的时候会执行 Scavenge 算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行。这个算法分为三步：</span><br><span class="line"></span><br><span class="line">（1）首先检查 From 空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。如果不满足条件则移动 To 空间。</span><br><span class="line"></span><br><span class="line">（2）如果对象不存活，则释放对象的空间。</span><br><span class="line"></span><br><span class="line">（3）最后将 From 空间和 To 空间角色进行交换。</span><br><span class="line"></span><br><span class="line">新生代对象晋升到老生代有两个条件：</span><br><span class="line"></span><br><span class="line">（1）第一个是判断是对象否已经经过一次 Scavenge 回收。若经历过，则将对象从 From 空间复制到老生代中；若没有经历，则复制到 To 空间。</span><br><span class="line"></span><br><span class="line">（2）第二个是 To 空间的内存使用占比是否超过限制。当对象从 From 空间复制到 To 空间时，若 To 空间使用超过 25%，则对象直接晋升到老生代中。设置 25% 的原因主要是因为算法结束后，两个空间结束后会交换位置，如果 To 空间的内存太小，会影响后续的内存分配。</span><br><span class="line"></span><br><span class="line">老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以了解决内存碎片的问题引入了标记压缩法。</span><br><span class="line"></span><br><span class="line">由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。 为了解决这个问题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.jianshu.com/p/b8ed21e8a4fb">《深入理解 V8 的垃圾回收原理》</a><br><a href="https://zhuanlan.zhihu.com/p/23992332">《JavaScript 中的垃圾回收》</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端面试 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS面试知识点总结(七)</title>
      <link href="/53789/"/>
      <url>/53789/</url>
      
        <content type="html"><![CDATA[<h2 id="服务器代理转发时，该如何处理-cookie？"><a href="#服务器代理转发时，该如何处理-cookie？" class="headerlink" title="服务器代理转发时，该如何处理 cookie？"></a>服务器代理转发时，该如何处理 cookie？</h2><p>详细资料可以参考：<br><a href="https://www.jianshu.com/p/5eab0f83e3b4">《深入浅出 Nginx》</a></p><h2 id="简单谈一下-cookie-？"><a href="#简单谈一下-cookie-？" class="headerlink" title="简单谈一下 cookie ？"></a>简单谈一下 cookie ？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我的理解是 cookie 是服务器提供的一种用于维护会话状态信息的数据，通过服务器发送到浏览器，浏览器保存在本地，当下一次有同源的请求时，将保存的 cookie 值添加到请求头部，发送给服务端。这可以用来实现记录用户登录状态等功能。cookie 一般可以存储 4k 大小的数据，并且只能够被同源的网页所共享访问。</span><br><span class="line"></span><br><span class="line">服务器端可以使用 Set-Cookie 的响应头部来配置 cookie 信息。一条cookie 包括了9个属性值 name、value、expires、domain、path、secure、HttpOnly、SameSite、Priority。其中 name 和 value 分别是 cookie 的名字和值。expires 指定了 cookie 失效的时间，domain 是域名、path是路径，domain 和 path 一起限制了 cookie 能够被哪些 url 访问。secure 规定了 cookie 只能在确保安全的情况下传输，HttpOnly 规定了这个 cookie 只能被服务器访问，不能使用 js 脚本访问。SameSite 属性用来限制第三方 cookie，可以有效防止 CSRF 攻击，从而减少安全风险。Priority 是 chrome 的提案，定义了三种优先级，当 cookie 数量超出时低优先级的 cookie 会被优先清除。</span><br><span class="line"></span><br><span class="line">在发生 xhr 的跨域请求的时候，即使是同源下的 cookie，也不会被自动添加到请求头部，除非显示地规定。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies">《HTTP cookies》 </a><br><a href="https://segmentfault.com/a/1190000004556040">《聊一聊 cookie》 </a></p><h2 id="模块化开发怎么做？"><a href="#模块化开发怎么做？" class="headerlink" title="模块化开发怎么做？"></a>模块化开发怎么做？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我对模块的理解是，一个模块是实现一个特定功能的一组方法。在最开始的时候，js 只实现一些简单的功能，所以并没有模块的概念</span><br><span class="line">，但随着程序越来越复杂，代码的模块化开发变得越来越重要。</span><br><span class="line"></span><br><span class="line">由于函数具有独立作用域的特点，最原始的写法是使用函数来作为模块，几个函数作为一个模块，但是这种方式容易造成全局变量的污</span><br><span class="line">染，并且模块间没有联系。</span><br><span class="line"></span><br><span class="line">后面提出了对象写法，通过将函数作为一个对象的方法来实现，这样解决了直接使用函数作为模块的一些缺点，但是这种办法会暴露所</span><br><span class="line">有的所有的模块成员，外部代码可以修改内部属性的值。</span><br><span class="line"></span><br><span class="line">现在最常用的是立即执行函数的写法，通过利用闭包来实现模块私有作用域的建立，同时不会对全局作用域造成污染。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5ab378c46fb9a028ce7b824f">《浅谈模块化开发》</a><br><a href="http://www.ruanyifeng.com/blog/2012/10/javascript_module.html">《Javascript 模块化编程（一）：模块的写法》</a><br><a href="https://juejin.im/post/5aaa37c8f265da23945f365c">《前端模块化：CommonJS，AMD，CMD，ES6》</a><br><a href="http://es6.ruanyifeng.com/#docs/module">《Module 的语法》</a></p><h2 id="js-的几种模块规范？"><a href="#js-的几种模块规范？" class="headerlink" title="js 的几种模块规范？"></a>js 的几种模块规范？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">js 中现在比较成熟的有四种模块加载方案。</span><br><span class="line"></span><br><span class="line">第一种是 CommonJS 方案，它通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是</span><br><span class="line">服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式</span><br><span class="line">加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。</span><br><span class="line"></span><br><span class="line">第二种是 AMD 方案，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定</span><br><span class="line">义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范。</span><br><span class="line"></span><br><span class="line">第三种是 CMD 方案，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和 require.js</span><br><span class="line">的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。参考60</span><br><span class="line"></span><br><span class="line">第四种方案是 ES6 提出的方案，使用 import 和 export 的形式来导入导出模块。这种方案和上面三种方案都不同。参考 61。</span><br></pre></td></tr></table></figure><h2 id="AMD-和-CMD-规范的区别？"><a href="#AMD-和-CMD-规范的区别？" class="headerlink" title="AMD 和 CMD 规范的区别？"></a>AMD 和 CMD 规范的区别？</h2><p>它们之间的主要区别有两个方面。</p><p>（1）第一个方面是在模块定义时对依赖的处理不同。AMD 推崇依赖前置，在定义模块的时候就要声明其依赖的模块。而 CMD 推崇<br>就近依赖，只有在用到某个模块的时候再去 require。</p><p>（2）第二个方面是对依赖模块的执行时机处理不同。首先 AMD 和 CMD 对于模块的加载方式都是异步加载，不过它们的区别在于<br>模块的执行时机，AMD 在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致。而 CMD<br>在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 require 语句<br>的时候才执行对应的模块，这样模块的执行顺序就和我们书写的顺序保持一致了。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CMD</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&quot;./a&quot;</span>);</span><br><span class="line">  a.doSomething();</span><br><span class="line">  <span class="comment">// 此处略去 100 行</span></span><br><span class="line">  <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&quot;./b&quot;</span>); <span class="comment">// 依赖可以就近书写</span></span><br><span class="line">  b.doSomething();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// AMD 默认推荐</span></span><br><span class="line">define([<span class="string">&quot;./a&quot;</span>, <span class="string">&quot;./b&quot;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 依赖必须一开始就写好</span></span><br><span class="line">  a.doSomething();</span><br><span class="line">  <span class="comment">// 此处略去 100 行</span></span><br><span class="line">  b.doSomething();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.im/post/5a422b036fb9a045211ef789">《前端模块化，AMD 与 CMD 的区别》</a></p><h2 id="ES6-模块与-CommonJS-模块、AMD、CMD-的差异。"><a href="#ES6-模块与-CommonJS-模块、AMD、CMD-的差异。" class="headerlink" title="ES6 模块与 CommonJS 模块、AMD、CMD 的差异。"></a>ES6 模块与 CommonJS 模块、AMD、CMD 的差异。</h2><ul><li><p>1.CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。</p></li><li><p>2.CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。CommonJS 模块就是对象，即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p></li></ul><h2 id="requireJS-的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何-缓存的？）"><a href="#requireJS-的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何-缓存的？）" class="headerlink" title="requireJS 的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？）"></a>requireJS 的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">require.js 的核心原理是通过动态创建 script 脚本来异步引入模块，然后对每个脚本的 load 事件进行监听，如果每个脚本都加载完成了，再调用回调函数。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://github.com/HRFE/blog/issues/10">《requireJS 的用法和原理分析》</a><br><a href="https://zhuanlan.zhihu.com/p/55039478">《requireJS 的核心原理是什么？》</a><br><a href="https://www.cnblogs.com/dong-xu/p/7160919.html">《从 RequireJs 源码剖析脚本加载原理》</a><br><a href="https://www.jianshu.com/p/5a39535909e4">《requireJS 原理分析》</a></p><h2 id="JS-模块加载器的轮子怎么造，也就是如何实现一个模块加载器？"><a href="#JS-模块加载器的轮子怎么造，也就是如何实现一个模块加载器？" class="headerlink" title="JS 模块加载器的轮子怎么造，也就是如何实现一个模块加载器？"></a>JS 模块加载器的轮子怎么造，也就是如何实现一个模块加载器？</h2><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/21157540">《JS 模块加载器加载原理是怎么样的？》</a></p><h2 id="ECMAScript6-怎么写-class，为什么会出现-class-这种东西"><a href="#ECMAScript6-怎么写-class，为什么会出现-class-这种东西" class="headerlink" title="ECMAScript6 怎么写 class，为什么会出现 class 这种东西?"></a>ECMAScript6 怎么写 class，为什么会出现 class 这种东西?</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在我看来 ES6 新添加的 class 只是为了补充 js 中缺少的一些面向对象语言的特性，但本质上来说它只是一种语法糖，不是一个新的东西，其背后还是原型继承的思想。通过加入 class 可以有利于我们更好的组织代码。</span><br><span class="line"></span><br><span class="line">在 class 中添加的方法，其实是添加在类的原型上的。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/29789315">《ECMAScript 6 实现了 class，对 JavaScript 前端开发有什么意义？》</a><br><a href="http://es6.ruanyifeng.com/#docs/class">《Class 的基本语法》</a></p><h2 id="documen-write-和-innerHTML-的区别？"><a href="#documen-write-和-innerHTML-的区别？" class="headerlink" title="documen.write 和 innerHTML 的区别？"></a>documen.write 和 innerHTML 的区别？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.write 的内容会代替整个文档内容，会重写整个页面。</span><br><span class="line"></span><br><span class="line">innerHTML 的内容只是替代指定元素的内容，只会重写页面中的部分内容。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.nowcoder.com/questionTerminal/2c5d8105b2694d85b06eff85e871cf50">《简述 document.write 和 innerHTML 的区别。》</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端面试 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS面试知识点总结(六)</title>
      <link href="/4828/"/>
      <url>/4828/</url>
      
        <content type="html"><![CDATA[<h2 id="Javascript-中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？"><a href="#Javascript-中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？" class="headerlink" title="Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？"></a>Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hasOwnProperty</span><br><span class="line"></span><br><span class="line">所有继承了 Object 的对象都会继承到 hasOwnProperty 方法。这个方法可以用来检测一个对象是否含有特定的自身属性，和</span><br><span class="line">in 运算符不同，该方法会忽略掉那些从原型链上继承到的属性。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty">《Object.prototype.hasOwnProperty()》</a></p><h2 id="对于-JSON-的了解？"><a href="#对于-JSON-的了解？" class="headerlink" title="对于 JSON 的了解？"></a>对于 JSON 的了解？</h2><p>相关知识点：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JSON 是一种数据交换格式，基于文本，优于轻量，用于交换数据。</span><br><span class="line"></span><br><span class="line">JSON 可以表示数字、布尔值、字符串、null、数组（值的有序序列），以及由这些值（或数组、对象）所组成的对象（字符串与</span><br><span class="line">值的映射）。</span><br><span class="line"></span><br><span class="line">JSON 使用 JavaScript 语法，但是 JSON 格式仅仅是一个文本。文本可以被任何编程语言读取及作为数据格式传递。</span><br></pre></td></tr></table></figure><p>回答：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。</span><br><span class="line"></span><br><span class="line">在项目开发中，我们使用 JSON 作为前后端数据交换的方式。在前端我们通过将一个符合 JSON 格式的数据结构序列化为 JSON 字符串，然后将它传递到后端，后端通过 JSON 格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。</span><br><span class="line"></span><br><span class="line">因为 JSON 的语法是基于 js 的，因此很容易将 JSON 和 js 中的对象弄混，但是我们应该注意的是 JSON 和 js 中的对象不是一回事，JSON 中对象格式更加严格，比如说在 JSON 中属性值不能为函数，不能出现 NaN 这样的属性值等，因此大多数的 js 对象是不符合 JSON 对象的格式的。</span><br><span class="line"></span><br><span class="line">在 js 中提供了两个函数来实现 js 数据结构和 JSON 格式的转换处理，一个是 JSON.stringify 函数，通过传入一个符合 JSON 格式的数据结构，将其转换为一个 JSON 字符串。如果传入的数据结构不符合 JSON 格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，我们可以调用这个函数将数据对象转化为 JSON 格式的字符串。</span><br><span class="line"></span><br><span class="line">另一个函数 JSON.parse() 函数，这个函数用来将 JSON 格式的字符串转换为一个 js 数据结构，如果传入的字符串不是标准的 JSON 格式的字符串的话，将会抛出错误。当我们从后端接收到 JSON 格式的字符串时，我们可以通过这个方法来将其解析为一个 js 数据结构，以此来进行数据的访问。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://my.oschina.net/u/3284240/blog/874368">《深入了解 JavaScript 中的 JSON 》</a></p><h2 id="forEach-call-quot-quot-function-a-a-style-outline-quot-1px-solid-quot-Math-random-1-lt-lt-24-toString-16-能解释一下这段代码的意思吗？"><a href="#forEach-call-quot-quot-function-a-a-style-outline-quot-1px-solid-quot-Math-random-1-lt-lt-24-toString-16-能解释一下这段代码的意思吗？" class="headerlink" title="[].forEach.call($$(&quot;*&quot;),function(a){a.style.outline=&quot;1px solid #&quot;+(~~(Math.random()*(1&lt;&lt;24))).toString(16)}) 能解释一下这段代码的意思吗？"></a><code>[].forEach.call($$(&quot;*&quot;),function(a)&#123;a.style.outline=&quot;1px solid #&quot;+(~~(Math.random()*(1&lt;&lt;24))).toString(16)&#125;)</code> 能解释一下这段代码的意思吗？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）选取页面所有 DOM 元素。在浏览器的控制台中可以使用$$()方法来获取页面中相应的元素，这是现代浏览器提供的一个命令行 API 相当于 document.querySelectorAll 方法。</span><br><span class="line"></span><br><span class="line">（2）循环遍历 DOM 元素</span><br><span class="line"></span><br><span class="line">（3）给元素添加 outline 。由于渲染的 outline 是不在 CSS 盒模型中的，所以为元素添加 outline 并不会影响元素的大小和页面的布局。</span><br><span class="line"></span><br><span class="line">（4）生成随机颜色函数。Math.random()*(1&lt;&lt;24) 可以得到 0~2^24 - 1 之间的随机数，因为得到的是一个浮点数，但我们只需要整数部分，使用取反操作符 ~ 连续两次取反获得整数部分，然后再用 toString(16) 的方式，转换为一个十六进制的字符串。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://2008winstar.iteye.com/blog/2128290">《通过一行代码学 JavaScript》</a></p><h2 id="js-延迟加载的方式有哪些？"><a href="#js-延迟加载的方式有哪些？" class="headerlink" title="js 延迟加载的方式有哪些？"></a>js 延迟加载的方式有哪些？</h2><p>相关知识点：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">js 延迟加载，也就是等页面加载完成之后再加载 JavaScript 文件。 js 延迟加载有助于提高页面加载速度。</span><br></pre></td></tr></table></figure><p>一般有以下几种方式：</p><ul><li>defer 属性</li><li>async 属性</li><li>动态创建 DOM 方式</li><li>使用 setTimeout 延迟方法</li><li>让 JS 最后加载</li></ul><p>回答：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">js 的加载、解析和执行会阻塞页面的渲染过程，因此我们希望 js 脚本能够尽可能的延迟加载，提高页面的渲染速度。</span><br><span class="line"></span><br><span class="line">我了解到的几种方式是：</span><br><span class="line"></span><br><span class="line">第一种方式是我们一般采用的是将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。</span><br><span class="line"></span><br><span class="line">第二种方式是给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。</span><br><span class="line"></span><br><span class="line">第三种方式是给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。</span><br><span class="line"></span><br><span class="line">第四种方式是动态创建 DOM 标签的方式，我们可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/meijory/article/details/76389762">《JS 延迟加载的几种方式》</a><br><a href="http://www.w3school.com.cn/html5/att_script_async.asp">《HTML 5 <code>&lt;script&gt;</code> <code>async</code> 属性》</a></p><h2 id="Ajax-是什么-如何创建一个-Ajax？"><a href="#Ajax-是什么-如何创建一个-Ajax？" class="headerlink" title="Ajax 是什么? 如何创建一个 Ajax？"></a>Ajax 是什么? 如何创建一个 Ajax？</h2><p>相关知识点：</p><p>2005 年 2 月，AJAX 这个词第一次正式提出，它是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的<br>异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。</p><p>具体来说，AJAX 包括以下几个步骤。</p><ul><li>1.创建 XMLHttpRequest 对象，也就是创建一个异步调用对象</li><li>2.创建一个新的 HTTP 请求，并指定该 HTTP 请求的方法、URL 及验证信息</li><li>3.设置响应 HTTP 请求状态变化的函数</li><li>4.发送 HTTP 请求</li><li>5.获取异步调用返回的数据</li><li>6.使用 JavaScript 和 DOM 实现局部刷新</li></ul><p>一般实现：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SERVER_URL = <span class="string">&quot;/server&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Http 请求</span></span><br><span class="line">xhr.open(<span class="string">&quot;GET&quot;</span>, SERVER_URL, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置状态监听函数</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.readyState !== <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当请求成功时</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">    handle(<span class="built_in">this</span>.response);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="built_in">this</span>.statusText);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置请求失败时的监听函数</span></span><br><span class="line">xhr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="built_in">this</span>.statusText);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置请求头信息</span></span><br><span class="line">xhr.responseType = <span class="string">&quot;json&quot;</span>;</span><br><span class="line">xhr.setRequestHeader(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送 Http 请求</span></span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// promise 封装实现：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getJSON</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个 promise 对象</span></span><br><span class="line">  <span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建一个 http 请求</span></span><br><span class="line">    xhr.open(<span class="string">&quot;GET&quot;</span>, url, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置状态的监听函数</span></span><br><span class="line">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.readyState !== <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 当请求成功或失败时，改变 promise 的状态</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">        resolve(<span class="built_in">this</span>.response);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="built_in">this</span>.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置错误监听函数</span></span><br><span class="line">    xhr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="built_in">this</span>.statusText));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置响应的数据类型</span></span><br><span class="line">    xhr.responseType = <span class="string">&quot;json&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置请求头信息</span></span><br><span class="line">    xhr.setRequestHeader(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送 http 请求</span></span><br><span class="line">    xhr.send(<span class="literal">null</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回答：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我对 ajax 的理解是，它是一种异步通信的方法，通过直接由 js 脚本向服务器发起 http 通信，然后根据服务器返回的数据，更新网页的相应部分，而不用刷新整个页面的一种方法。</span><br><span class="line"></span><br><span class="line">创建一个 ajax 有这样几个步骤</span><br><span class="line"></span><br><span class="line">首先是创建一个 XMLHttpRequest 对象。</span><br><span class="line"></span><br><span class="line">然后在这个对象上使用 open 方法创建一个 http 请求，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。</span><br><span class="line"></span><br><span class="line">在发起请求前，我们可以为这个对象添加一些信息和监听函数。比如说我们可以通过 setRequestHeader 方法来为请求添加头信息。我们还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，我们可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候我们可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候我们就可以通过 response 中的数据来对页面进行更新了。</span><br><span class="line"></span><br><span class="line">当对象的属性和监听函数设置完成后，最后我们调用 sent 方法来向服务器发起请求，可以传入参数作为发送的数据体。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://wangdoc.com/javascript/bom/xmlhttprequest.html">《XMLHttpRequest 对象》</a><br><a href="https://juejin.im/post/5acde23c5188255cb32e7e76">《从 ajax 到 fetch、axios》</a><br><a href="https://juejin.im/post/5c160937f265da61180199b2">《Fetch 入门》</a><br><a href="https://segmentfault.com/a/1190000003810652">《传统 Ajax 已死，Fetch 永生》</a></p><h2 id="谈一谈浏览器的缓存机制？"><a href="#谈一谈浏览器的缓存机制？" class="headerlink" title="谈一谈浏览器的缓存机制？"></a>谈一谈浏览器的缓存机制？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">浏览器的缓存机制指的是通过在一段时间内保留已接收到的 web 资源的一个副本，如果在资源的有效时间内，发起了对这个资源的再一次请求，那么浏览器会直接使用缓存的副本，而不是向服务器发起请求。使用 web 缓存可以有效地提高页面的打开速度，减少不必要的网络带宽的消耗。</span><br><span class="line"></span><br><span class="line">web 资源的缓存策略一般由服务器来指定，可以分为两种，分别是强缓存策略和协商缓存策略。</span><br><span class="line"></span><br><span class="line">使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。强缓存策略可以通过两种方式来设置，分别是 http 头信息中的 Expires 属性和 Cache-Control 属性。</span><br><span class="line"></span><br><span class="line">服务器通过在响应头中添加 Expires 属性，来指定资源的过期时间。在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求。这个时间是一个绝对时间，它是服务器的时间，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。</span><br><span class="line"></span><br><span class="line">Expires 是 http1.0 中的方式，因为它的一些缺点，在 http 1.1 中提出了一个新的头部属性就是 Cache-Control 属性，</span><br><span class="line">它提供了对资源的缓存的更精确的控制。它有很多不同的值，常用的比如我们可以通过设置 max-age 来指定资源能够被缓存的时间</span><br><span class="line">的大小，这是一个相对的时间，它会根据这个时间的大小和资源第一次请求时的时间来计算出资源过期的时间，因此相对于 Expires</span><br><span class="line">来说，这种方式更加有效一些。常用的还有比如 private ，用来规定资源只能被客户端缓存，不能够代理服务器所缓存。还有如 n</span><br><span class="line">o-store ，用来指定资源不能够被缓存，no-cache 代表该资源能够被缓存，但是立即失效，每次都需要向服务器发起请求。</span><br><span class="line"></span><br><span class="line">一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方式一起使用时，Cache-Control 的优先级要高于 Expires 。</span><br><span class="line"></span><br><span class="line">使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个 304 状态，让浏览器使用本地的缓存副本。</span><br><span class="line">如果资源发生了修改，则返回修改后的资源。协商缓存也可以通过两种方式来设置，分别是 http 头信息中的 Etag 和 Last-Modified 属性。</span><br><span class="line"></span><br><span class="line">服务器通过在响应头中添加 Last-Modified 属性来指出资源最后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加一个 If-Modified-Since 的属性，属性值为上一次资源返回时的 Last-Modified 的值。当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改。如果资源没有修改，那么返回 304 状态，让客户端使用本地的缓存。如果资源已经被修改了，则返回修改后的资源。使用这种方法有一个缺点，就是 Last-Modified 标注的最后修改时间只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，那么文件已将改变了但是 Last-Modified 却没有改变，</span><br><span class="line">这样会造成缓存命中的不准确。</span><br><span class="line"></span><br><span class="line">因为 Last-Modified 的这种可能发生的不准确性，http 中提供了另外一种方式，那就是 Etag 属性。服务器在返回资源的时候，在头信息中添加了 Etag 属性，这个属性是资源生成的唯一标识符，当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时，浏览器会在请求头中添加一个 If-None-Match 属性，这个属性的值就是上次返回的资源的 Etag 的值。服务接收到请求后会根据这个值来和资源当前的 Etag 的值来进行比较，以此来判断资源是否发生改变，是否需要返回资源。通过这种方式，比 Last-Modified 的方式更加精确。</span><br><span class="line"></span><br><span class="line">当 Last-Modified 和 Etag 属性同时出现的时候，Etag 的优先级更高。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的 Last-Modified 应该保持一致，因为每个服务器上 Etag 的值都不一样，因此在考虑负载平衡时，最好不要设置 Etag 属性。</span><br><span class="line"></span><br><span class="line">强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则浏览器返回最新的资源给浏览器。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000012573337">《浅谈浏览器缓存》</a><br><a href="https://juejin.im/post/5b9346dcf265da0aac6fbe57#heading-3">《前端优化：浏览器缓存技术介绍》</a><br><a href="https://www.web-tinker.com/article/21221.html">《请求头中的 Cache-Control》</a><br><a href="https://juejin.im/post/5c2d6c9ae51d450cf4195a08">《Cache-Control 字段值详解》</a></p><h2 id="Ajax-解决浏览器缓存问题？"><a href="#Ajax-解决浏览器缓存问题？" class="headerlink" title="Ajax 解决浏览器缓存问题？"></a>Ajax 解决浏览器缓存问题？</h2><ul><li><p>1.在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader(“If-Modified-Since”,”0”)。</p></li><li><p>2.在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader(“Cache-Control”,”no-cache”)。</p></li><li><p>3.在 URL 后面加上一个随机数： “fresh=” + Math.random();。</p></li><li><p>4.在 URL 后面加上时间戳：”nowtime=” + new Date().getTime();。</p></li><li><p>5.如果是使用 jQuery，直接这样就可以了$.ajaxSetup({cache:false})。这样页面的所有 ajax 都会执行这条语句就是不需要保存缓存记录。</p></li></ul><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/cwzqianduan/p/8632009.html">《Ajax 中浏览器的缓存问题解决方法》</a><br><a href="https://segmentfault.com/a/1190000012573337">《浅谈浏览器缓存》</a></p><h2 id="同步和异步的区别？"><a href="#同步和异步的区别？" class="headerlink" title="同步和异步的区别？"></a>同步和异步的区别？</h2><p>相关知识点：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">同步，可以理解为在执行完一个函数或方法之后，一直等待系统返回值或消息，这时程序是处于阻塞的，只有接收到返回的值或消息后才往下执行其他的命令。  </span><br><span class="line"></span><br><span class="line">异步，执行完函数或方法后，不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程。 </span><br></pre></td></tr></table></figure><p>回答：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">同步指的是当一个进程在执行某个请求的时候，如果这个请求需要等待一段时间才能返回，那么这个进程会一直等待下去，直到消息返</span><br><span class="line">回为止再继续向下执行。</span><br><span class="line"></span><br><span class="line">异步指的是当一个进程在执行某个请求的时候，如果这个请求需要等待一段时间才能返回，这个时候进程会继续往下执行，不会阻塞等</span><br><span class="line">待消息的返回，当消息返回时系统再通知进程进行处理。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/tennysonsky/article/details/45111623">《同步和异步的区别》</a></p><h2 id="什么是浏览器的同源政策？"><a href="#什么是浏览器的同源政策？" class="headerlink" title="什么是浏览器的同源政策？"></a>什么是浏览器的同源政策？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我对浏览器的同源政策的理解是，一个域下的 js 脚本在未经允许的情况下，不能够访问另一个域的内容。这里的同源的指的是两个</span><br><span class="line">域的协议、域名、端口号必须相同，否则则不属于同一个域。</span><br><span class="line"></span><br><span class="line">同源政策主要限制了三个方面</span><br><span class="line"></span><br><span class="line">第一个是当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。</span><br><span class="line"></span><br><span class="line">第二个是当前域下的 js 脚本不能够操作访问操作其他域下的 DOM。</span><br><span class="line"></span><br><span class="line">第三个是当前域下 ajax 无法发送跨域请求。</span><br><span class="line"></span><br><span class="line">同源政策的目的主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者</span><br><span class="line">script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。</span><br></pre></td></tr></table></figure><h2 id="如何解决跨域问题？"><a href="#如何解决跨域问题？" class="headerlink" title="如何解决跨域问题？"></a>如何解决跨域问题？</h2><p>相关知识点：</p><ul><li><ol><li>通过 jsonp 跨域</li></ol></li><li><ol start="2"><li>document.domain + iframe 跨域</li></ol></li><li><ol start="3"><li>location.hash + iframe</li></ol></li><li><ol start="4"><li>window.name + iframe 跨域</li></ol></li><li><ol start="5"><li>postMessage 跨域</li></ol></li><li><ol start="6"><li>跨域资源共享（CORS)</li></ol></li><li><ol start="7"><li>nginx 代理跨域</li></ol></li><li><ol start="8"><li>nodejs 中间件代理跨域</li></ol></li><li><ol start="9"><li>WebSocket 协议跨域</li></ol></li></ul><p>回答：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">解决跨域的方法我们可以根据我们想要实现的目的来划分。</span><br><span class="line"></span><br><span class="line">首先我们如果只是想要实现主域名下的不同子域名的跨域操作，我们可以使用设置 document.domain 来解决。</span><br><span class="line"></span><br><span class="line">（1）将 document.domain 设置为主域名，来实现相同子域名的跨域操作，这个时候主域名下的 cookie 就能够被子域名所访问。同时如果文档中含有主域名相同，子域名不同的 iframe 的话，我们也可以对这个 iframe 进行操作。</span><br><span class="line"></span><br><span class="line">如果是想要解决不同跨域窗口间的通信问题，比如说一个页面想要和页面的中的不同源的 iframe 进行通信的问题，我们可以使用 location.hash 或者 window.name 或者 postMessage 来解决。</span><br><span class="line"></span><br><span class="line">（2）使用 location.hash 的方法，我们可以在主页面动态的修改 iframe 窗口的 hash 值，然后在 iframe 窗口里实现监听函数来实现这样一个单向的通信。因为在 iframe 是没有办法访问到不同源的父级窗口的，所以我们不能直接修改父级窗口的 hash 值来实现通信，我们可以在 iframe 中再加入一个 iframe ，这个 iframe 的内容是和父级页面同源的，所以我们可以 window.parent.parent 来修改最顶级页面的 src，以此来实现双向通信。</span><br><span class="line"></span><br><span class="line">（3）使用 window.name 的方法，主要是基于同一个窗口中设置了 window.name 后不同源的页面也可以访问，所以不同源的子页面可以首先在 window.name 中写入数据，然后跳转到一个和父级同源的页面。这个时候级页面就可以访问同源的子页面中 window.name 中的数据了，这种方式的好处是可以传输的数据量大。</span><br><span class="line"></span><br><span class="line">（4）使用 postMessage 来解决的方法，这是一个 h5 中新增的一个 api。通过它我们可以实现多窗口间的信息传递，通过获取到指定窗口的引用，然后调用 postMessage 来发送信息，在窗口中我们通过对 message 信息的监听来接收信息，以此来实现不同源间的信息交换。</span><br><span class="line"></span><br><span class="line">如果是像解决 ajax 无法提交跨域请求的问题，我们可以使用 jsonp、cors、websocket 协议、服务器代理来解决问题。</span><br><span class="line"></span><br><span class="line">（5）使用 jsonp 来实现跨域请求，它的主要原理是通过动态构建 script  标签来实现跨域请求，因为浏览器对 script 标签的引入没有跨域的访问限制 。通过在请求的 url 后指定一个回调函数，然后服务器在返回数据的时候，构建一个 json 数据的包装，这个包装就是回调函数，然后返回给前端，前端接收到数据后，因为请求的是脚本文件，所以会直接执行，这样我们先前定义好的回调函数就可以被调用，从而实现了跨域请求的处理。这种方式只能用于 get 请求。</span><br><span class="line"></span><br><span class="line">（6）使用 CORS 的方式，CORS 是一个 W3C 标准，全称是&quot;跨域资源共享&quot;。CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，因此我们只需要在服务器端配置就行。浏览器将 CORS 请求分成两类：简单请求和非简单请求。对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是会在头信息之中，增加一个 Origin 字段。Origin 字段用来说明本次请求来自哪个源。服务器根据这个值，决定是否同意这次请求。对于如果 Origin 指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含 Access-Control-Allow-Origin 字段，就知道出错了，从而抛出一个错误，ajax 不会收到响应信息。如果成功的话会包含一些以 Access-Control- 开头的字段。</span><br><span class="line"></span><br><span class="line">非简单请求，浏览器会先发出一次预检请求，来判断该域名是否在服务器的白名单中，如果收到肯定回复后才会发起请求。</span><br><span class="line"></span><br><span class="line">（7）使用 websocket 协议，这个协议没有同源限制。</span><br><span class="line"></span><br><span class="line">（8）使用服务器来代理跨域的访问请求，就是有跨域的请求操作时发送请求给后端，让后端代为请求，然后最后将获取的结果发返回。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000011145364">《前端常见跨域解决方案（全）》</a><br><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html">《浏览器同源政策及其规避方法》</a><br><a href="https://juejin.im/entry/59feae9df265da43094488f6">《跨域，你需要知道的全在这里》</a><br><a href="https://www.zhihu.com/question/31592553">《为什么 form 表单提交没有跨域问题，但 ajax 提交有跨域问题？》</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端面试 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS面试知识点总结(五)</title>
      <link href="/5020/"/>
      <url>/5020/</url>
      
        <content type="html"><![CDATA[<h2 id="写一个通用的事件侦听器函数。"><a href="#写一个通用的事件侦听器函数。" class="headerlink" title="写一个通用的事件侦听器函数。"></a>写一个通用的事件侦听器函数。</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> EventUtils = &#123;</span><br><span class="line">  <span class="comment">// 视能力分别使用dom0||dom2||IE方式 来绑定事件</span></span><br><span class="line">  <span class="comment">// 添加事件</span></span><br><span class="line">  <span class="attr">addEvent</span>: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element.addEventListener) &#123;</span><br><span class="line">      element.addEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</span><br><span class="line">      element.attachEvent(<span class="string">&quot;on&quot;</span> + type, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">&quot;on&quot;</span> + type] = handler;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移除事件</span></span><br><span class="line">  <span class="attr">removeEvent</span>: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element.removeEventListener) &#123;</span><br><span class="line">      element.removeEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.detachEvent) &#123;</span><br><span class="line">      element.detachEvent(<span class="string">&quot;on&quot;</span> + type, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">&quot;on&quot;</span> + type] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取事件目标</span></span><br><span class="line">  <span class="attr">getTarget</span>: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> event.target || event.srcElement;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取 event 对象的引用，取到事件的所有信息，确保随时能使用 event</span></span><br><span class="line">  <span class="attr">getEvent</span>: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> event || <span class="built_in">window</span>.event;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 阻止事件（主要是事件冒泡，因为 IE 不支持事件捕获）</span></span><br><span class="line">  <span class="attr">stopPropagation</span>: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.stopPropagation) &#123;</span><br><span class="line">      event.stopPropagation();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取消事件的默认行为</span></span><br><span class="line">  <span class="attr">preventDefault</span>: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.preventDefault) &#123;</span><br><span class="line">      event.preventDefault();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      event.returnValue = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000006934031#articleHeader6">《JS 事件模型》</a></p><h2 id="事件是什么？IE-与火狐的事件机制有什么区别？-如何阻止冒泡？"><a href="#事件是什么？IE-与火狐的事件机制有什么区别？-如何阻止冒泡？" class="headerlink" title="事件是什么？IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？"></a>事件是什么？IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？</h2><ul><li><p>1.事件是用户操作网页时发生的交互动作，比如 click/move， 事件除了用户触发的动作外，还可以是文档加载，窗口滚动和大小调整。事件被封装成一个 event 对象，包含了该事件发生时的所有相关信息（ event 的属性）以及可以对事件进行的操作（ event 的方法）。</p></li><li><p>2.事件处理机制：IE 支持事件冒泡、Firefox 同时支持两种事件模型，也就是：事件冒泡和事件捕获。</p></li><li><p>3.event.stopPropagation() 或者 ie 下的方法 event.cancelBubble = true;</p></li></ul><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/lvdabao/p/3265870.html">《Javascript 事件模型系列（一）事件及事件的三种模型》</a><br><a href="https://blog.csdn.net/wuseyukui/article/details/13771493">《Javascript 事件模型：事件捕获和事件冒泡》</a></p><h2 id="三种事件模型是什么？"><a href="#三种事件模型是什么？" class="headerlink" title="三种事件模型是什么？"></a>三种事件模型是什么？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">事件是用户操作网页时发生的交互动作或者网页本身的一些操作，现代浏览器一共有三种事件模型。</span><br><span class="line"></span><br><span class="line">第一种事件模型是最早的 DOM0 级模型，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实</span><br><span class="line">现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。这种方式是所有浏览器都兼容的。</span><br><span class="line"></span><br><span class="line">第二种事件模型是 IE 事件模型，在该事件模型中，一次事件共有两个过程，事件处理阶段，和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。</span><br><span class="line"></span><br><span class="line">第三种是 DOM2 级事件模型，在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是 addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/u013217071/article/details/77613706">《一个 DOM 元素绑定多个事件时，先执行冒泡还是捕获》</a></p><h2 id="事件委托是什么？"><a href="#事件委托是什么？" class="headerlink" title="事件委托是什么？"></a>事件委托是什么？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">事件委托本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到</span><br><span class="line">目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。</span><br><span class="line"></span><br><span class="line">使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理我们还可以实现事件的动态绑定，比如说新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://zhuanlan.zhihu.com/p/26536815">《JavaScript 事件委托详解》</a></p><h2 id="“1”-“2”-“3”-map-parseInt-答案是多少？"><a href="#“1”-“2”-“3”-map-parseInt-答案是多少？" class="headerlink" title="[“1”, “2”, “3”].map(parseInt) 答案是多少？"></a>[“1”, “2”, “3”].map(parseInt) 答案是多少？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">parseInt() 函数能解析一个字符串，并返回一个整数，需要两个参数 (val, radix)，其中 radix 表示要解析的数字的基数。（该值介于 2 ~ 36 之间，并且字符串中的数字不能大于 radix 才能正确返回数字结果值）。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">此处 map 传了 3 个参数 (element, index, array)，默认第三个参数被忽略掉，因此三次传入的参数分别为 &quot;1-0&quot;, &quot;2-1&quot;, &quot;3-2&quot;</span><br><span class="line"></span><br><span class="line">因为字符串的值不能大于基数，因此后面两次调用均失败，返回 NaN ，第一次基数为 0 ，按十进制解析返回 1。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/justjavac/article/details/19473199">《为什么 [“1”, “2”, “3”].map(parseInt) 返回 [1,NaN,NaN]？》</a></p><h2 id="什么是闭包，为什么要用它？"><a href="#什么是闭包，为什么要用它？" class="headerlink" title="什么是闭包，为什么要用它？"></a>什么是闭包，为什么要用它？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以</span><br><span class="line">访问到当前函数的局部变量。</span><br><span class="line"></span><br><span class="line">闭包有两个常用的用途。</span><br><span class="line"></span><br><span class="line">闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包函数，从而在外</span><br><span class="line">部访问到函数内部的变量，可以使用这种方法来创建私有变量。</span><br><span class="line"></span><br><span class="line">函数的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以</span><br><span class="line">这个变量对象不会被回收。</span><br><span class="line"></span><br><span class="line">其实闭包的本质就是作用域链的一个特殊的应用，只要了解了作用域链的创建过程，就能够理解闭包的实现原理。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E9%97%AD%E5%8C%85.html">《JavaScript 深入理解之闭包》</a></p><h2 id="javascript-代码中的-“use-strict”-是什么意思-使用它区别是什么？"><a href="#javascript-代码中的-“use-strict”-是什么意思-使用它区别是什么？" class="headerlink" title="javascript 代码中的 “use strict”; 是什么意思 ? 使用它区别是什么？"></a>javascript 代码中的 “use strict”; 是什么意思 ? 使用它区别是什么？</h2><p>相关知识点：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use strict 是一种 ECMAscript5 添加的（严格）运行模式，这种模式使得 Javascript 在更严格的条件下运行。</span><br><span class="line"></span><br><span class="line">设立&quot;严格模式&quot;的目的，主要有以下几个：</span><br></pre></td></tr></table></figure><ul><li>消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为;</li><li>消除代码运行的一些不安全之处，保证代码运行的安全；</li><li>提高编译器效率，增加运行速度；</li><li>为未来新版本的 Javascript 做好铺垫。</li></ul><p>区别：</p><ul><li>1.禁止使用 with 语句。</li><li>2.禁止 this 关键字指向全局对象。</li><li>3.对象不能有重名的属性。</li></ul><p>回答：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use strict 指的是严格运行模式，在这种模式对 js 的使用添加了一些限制。比如说禁止 this 指向全局对象，还有禁止使</span><br><span class="line">用 with 语句等。设立严格模式的目的，主要是为了消除代码使用中的一些不安全的使用方式，也是为了消除 js 语法本身的一</span><br><span class="line">些不合理的地方，以此来减少一些运行时的怪异的行为。同时使用严格运行模式也能够提高编译的效率，从而提高代码的运行速度。</span><br><span class="line">我认为严格模式代表了 js 一种更合理、更安全、更严谨的发展方向。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html">《Javascript 严格模式详解》</a></p><h2 id="如何判断一个对象是否属于某个类？"><a href="#如何判断一个对象是否属于某个类？" class="headerlink" title="如何判断一个对象是否属于某个类？"></a>如何判断一个对象是否属于某个类？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一种方式是使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</span><br><span class="line"></span><br><span class="line">第二种方式可以通过对象的 constructor 属性来判断，对象的 constructor 属性指向该对象的构造函数，但是这种方式不是很安全，因为 constructor 属性可以被改写。</span><br><span class="line"></span><br><span class="line">第三种方式，如果需要判断的是某个内置的引用类型的话，可以使用 Object.prototype.toString() 方法来打印对象的</span><br><span class="line">[[Class]] 属性来进行判断。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/haitunmin/article/details/78418522">《js 判断一个对象是否属于某一类》</a></p><h2 id="instanceof-的作用？"><a href="#instanceof-的作用？" class="headerlink" title="instanceof 的作用？"></a>instanceof 的作用？</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</span></span><br><span class="line"><span class="comment">// 实现：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceof</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> proto = <span class="built_in">Object</span>.getPrototypeOf(left), <span class="comment">// 获取对象的原型</span></span><br><span class="line">    prototype = right.prototype; <span class="comment">// 获取构造函数的 prototype 对象</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断构造函数的 prototype 对象是否在对象的原型链上</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!proto) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (proto === prototype) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    proto = <span class="built_in">Object</span>.getPrototypeOf(proto);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof">《instanceof》</a></p><h2 id="new-操作符具体干了什么呢？如何实现？"><a href="#new-操作符具体干了什么呢？如何实现？" class="headerlink" title="new 操作符具体干了什么呢？如何实现？"></a>new 操作符具体干了什么呢？如何实现？</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// （1）首先创建了一个新的空对象</span></span><br><span class="line"><span class="comment">// （2）设置原型，将对象的原型设置为函数的 prototype 对象。</span></span><br><span class="line"><span class="comment">// （3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）</span></span><br><span class="line"><span class="comment">// （4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objectFactory</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="literal">null</span>,</span><br><span class="line">    <span class="title">constructor</span> = <span class="title">Array</span>.<span class="title">prototype</span>.<span class="title">shift</span>.<span class="title">call</span>(<span class="params"><span class="built_in">arguments</span></span>),</span><br><span class="line">    <span class="title">result</span> = <span class="title">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 参数判断</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title">constructor</span> !== &quot;<span class="title">function</span>&quot;) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">&quot;type error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 新建一个空对象，对象的原型为构造函数的 prototype 对象</span></span><br><span class="line">  newObject = <span class="built_in">Object</span>.create(<span class="title">constructor</span>.<span class="title">prototype</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 this 指向新建对象，并执行函数</span></span><br><span class="line">  result = <span class="title">constructor</span>.<span class="title">apply</span>(<span class="params">newObject, <span class="built_in">arguments</span></span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断返回对象</span></span><br><span class="line">  <span class="keyword">let</span> flag =</span><br><span class="line">    result &amp;&amp; (<span class="keyword">typeof</span> result === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> result === <span class="string">&quot;function&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断返回结果</span></span><br><span class="line">  <span class="keyword">return</span> flag ? result : newObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line"><span class="comment">// objectFactory(构造函数, 初始化参数);</span></span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000008576048">《new 操作符具体干了什么？》</a><br><a href="https://github.com/mqyqingfeng/Blog/issues/13">《JavaScript 深入之 new 的模拟实现》</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端面试 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS面试知识点总结(四)</title>
      <link href="/54109/"/>
      <url>/54109/</url>
      
        <content type="html"><![CDATA[<h2 id="常用正则表达式"><a href="#常用正则表达式" class="headerlink" title="常用正则表达式"></a>常用正则表达式</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// （1）匹配 16 进制颜色值</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （2）匹配日期，如 yyyy-mm-dd 格式</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[0-9]&#123;4&#125;-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （3）匹配 qq 号</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[1-9][0-9]&#123;4,10&#125;$/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （4）手机号码正则</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^1[34578]\d&#123;9&#125;$/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （5）用户名正则</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[a-zA-Z\$][a-zA-Z0-9_\$]&#123;4,16&#125;$/</span>;</span><br></pre></td></tr></table></figure><h2 id="生成随机数的各种方法？"><a href="#生成随机数的各种方法？" class="headerlink" title="生成随机数的各种方法？"></a>生成随机数的各种方法？</h2><p><a href="http://www.hangge.com/blog/cache/detail_1872.html">《JS - 生成随机数的方法汇总（不同范围、类型的随机数）》</a></p><h2 id="如何实现数组的随机排序？"><a href="#如何实现数组的随机排序？" class="headerlink" title="如何实现数组的随机排序？"></a>如何实现数组的随机排序？</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// （1）使用数组 sort 方法对数组元素随机排序，让 Math.random() 出来的数与 0.5 比较，如果大于就返回 1 交换位置，如果小于就返回 -1，不交换位置。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomSort</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.random() &gt; <span class="number">0.5</span> ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  缺点：每个元素被派到新数组的位置不是随机的，原因是 sort() 方法是依次比较的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （2）随机从原数组抽取一个元素，加入到新数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (arr.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> randomIndex = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * arr.length);</span><br><span class="line">    result.push(arr[randomIndex]);</span><br><span class="line">    arr.splice(randomIndex, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （3）随机交换数组内的元素（洗牌算法类似）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> index,</span><br><span class="line">    randomIndex,</span><br><span class="line">    temp,</span><br><span class="line">    len = arr.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; len; index++) &#123;</span><br><span class="line">    randomIndex = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (len - index)) + index;</span><br><span class="line"></span><br><span class="line">    temp = arr[index];</span><br><span class="line">    arr[index] = arr[randomIndex];</span><br><span class="line">    arr[randomIndex] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> length = array.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(array) || length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; length - <span class="number">1</span>; index++) &#123;</span><br><span class="line">    <span class="keyword">let</span> randomIndex = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (length - index)) + index;</span><br><span class="line"></span><br><span class="line">    [array[index], array[randomIndex]] = [array[randomIndex], array[index]];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://gaohaoyang.github.io/2016/10/16/shuffle-algorithm/#top">《Fisher and Yates 的原始版》</a><br><a href="https://www.zhihu.com/question/32303195">《javascript 实现数组随机排序?》</a><br><a href="https://www.w3cplus.com/javascript/how-to-randomize-shuffle-a-javascript-array.html">《JavaScript 学习笔记：数组随机排序》</a></p><h2 id="javascript-创建对象的几种方式？"><a href="#javascript-创建对象的几种方式？" class="headerlink" title="javascript 创建对象的几种方式？"></a>javascript 创建对象的几种方式？</h2><blockquote><p>我们一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。但 js<br>  和一般的面向对象的语言不同，在 ES6 之前它没有类的概念。但是我们可以使用函数来进行模拟，从而产生出可复用的对象<br>  创建方式，我了解到的方式有这么几种：<br>  （1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。<br>  （2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么我们就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此我们可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此我们可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次我们都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。<br>  （3）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此我们可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。<br>  （4）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此我们可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。<br>  （5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。<br>  （6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。</p></blockquote><h2 id="JavaScript-继承的几种实现方式？"><a href="#JavaScript-继承的几种实现方式？" class="headerlink" title="JavaScript 继承的几种实现方式？"></a>JavaScript 继承的几种实现方式？</h2><blockquote><p>我了解的 js 中实现继承的几种方式有：<br>  （1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。<br>  （2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。<br>  （3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。<br>  （4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。<br>  （5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是我们的自定义类型时。缺点是没有办法实现函数的复用。<br>  （6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。</p></blockquote><h2 id="寄生式组合继承的实现？"><a href="#寄生式组合继承的实现？" class="headerlink" title="寄生式组合继承的实现？"></a>寄生式组合继承的实现？</h2>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;My name is &quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, grade</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="built_in">this</span>, name);</span><br><span class="line">  <span class="built_in">this</span>.grade = grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype = <span class="built_in">Object</span>.create(Person.prototype);</span><br><span class="line">Student.prototype.constructor = Student;</span><br><span class="line"></span><br><span class="line">Student.prototype.sayMyGrade = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;My grade is &quot;</span> + <span class="built_in">this</span>.grade + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Javascript-的作用域链？"><a href="#Javascript-的作用域链？" class="headerlink" title="Javascript 的作用域链？"></a>Javascript 的作用域链？</h2><blockquote><p>作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和<br>  函数。<br>  作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前<br>  端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。<br>  当我们查找一个变量时，如果当前执行环境中没有找到，我们可以沿着作用域链向后查找。<br>  作用域链的创建过程跟执行上下文的建立有关….</p></blockquote><h2 id="谈谈-This-对象的理解。"><a href="#谈谈-This-对象的理解。" class="headerlink" title="谈谈 This 对象的理解。"></a>谈谈 This 对象的理解。</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模</span><br><span class="line">式来判断。</span><br></pre></td></tr></table></figure><ul><li><p>1.第一种是函数调用模式，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。</p></li><li><p>2.第二种是方法调用模式，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。</p></li><li><p>3.第三种是构造器调用模式，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。</p></li><li><p>4.第四种是 apply 、 call 和 bind 调用模式，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这四种方式，使用构造器调用模式的优先级最高，然后是 apply 、 call 和 bind 调用模式，然后是方法调用模式，然后</span><br><span class="line">是函数调用模式。</span><br></pre></td></tr></table></figure><h2 id="eval-是做什么的？"><a href="#eval-是做什么的？" class="headerlink" title="eval 是做什么的？"></a>eval 是做什么的？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">它的功能是把对应的字符串解析成 JS 代码并运行。</span><br><span class="line"></span><br><span class="line">应该避免使用 eval，不安全，非常耗性能（2次，一次解析成 js 语句，一次执行）。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval">《eval()》</a></p><h2 id="什么是-DOM-和-BOM？"><a href="#什么是-DOM-和-BOM？" class="headerlink" title="什么是 DOM 和 BOM？"></a>什么是 DOM 和 BOM？</h2><blockquote><p>DOM 指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。<br>BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM<br>的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）<br>对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 locati<br>on 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对<br>象的子对象。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端面试 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS面试知识点总结(三)</title>
      <link href="/4380/"/>
      <url>/4380/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是假值对象？"><a href="#什么是假值对象？" class="headerlink" title="什么是假值对象？"></a>什么是假值对象？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">浏览器在某些特定情况下，在常规 JavaScript 语法基础上自己创建了一些外来值，这些就是“假值对象”。假值对象看起来和</span><br><span class="line">普通对象并无二致（都有属性，等等），但将它们强制类型转换为布尔值时结果为 false 最常见的例子是 document.all，它</span><br><span class="line">是一个类数组对象，包含了页面上的所有元素，由 DOM（而不是 JavaScript 引擎）提供给 JavaScript 程序使用。</span><br></pre></td></tr></table></figure><h2 id="操作符的作用？"><a href="#操作符的作用？" class="headerlink" title="~ 操作符的作用？"></a>~ 操作符的作用？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~ 返回 2 的补码，并且 ~ 会将数字转换为 32 位整数，因此我们可以使用 ~ 来进行取整操作。</span><br><span class="line"></span><br><span class="line">~x 大致等同于 -(x+1)。</span><br></pre></td></tr></table></figure><h2 id="解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？"><a href="#解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？" class="headerlink" title="解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？"></a>解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">解析允许字符串（如 parseInt() ）中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停止。而转换（如 Nu</span><br><span class="line">mber ()）不允许出现非数字字符，否则会失败并返回 NaN。</span><br></pre></td></tr></table></figure><h2 id="操作符什么时候用于字符串的拼接？"><a href="#操作符什么时候用于字符串的拼接？" class="headerlink" title="+ 操作符什么时候用于字符串的拼接？"></a><code>+</code> 操作符什么时候用于字符串的拼接？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">根据 ES5 规范 11.6.1 节，如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+ 将进行拼接操作。如果其</span><br><span class="line">中一个操作数是对象（包括数组），则首先对其调用 ToPrimitive 抽象操作，该抽象操作再调用 [[DefaultValue]]，以</span><br><span class="line">数字作为上下文。如果不能转换为字符串，则会将其转换为数字类型来进行计算。</span><br><span class="line"></span><br><span class="line">简单来说就是，如果 + 的其中一个操作数是字符串（或者通过以上步骤最终得到字符串），则执行字符串拼接，否则执行数字</span><br><span class="line">加法。</span><br><span class="line"></span><br><span class="line">那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字。</span><br></pre></td></tr></table></figure><h2 id="什么情况下会发生布尔值的隐式强制类型转换？"><a href="#什么情况下会发生布尔值的隐式强制类型转换？" class="headerlink" title="什么情况下会发生布尔值的隐式强制类型转换？"></a>什么情况下会发生布尔值的隐式强制类型转换？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1） if (..) 语句中的条件判断表达式。</span><br><span class="line">（2） for ( .. ; .. ; .. ) 语句中的条件判断表达式（第二个）。</span><br><span class="line">（3） while (..) 和 do..while(..) 循环中的条件判断表达式。</span><br><span class="line">（4） ? : 中的条件判断表达式。</span><br><span class="line">（5） 逻辑运算符 ||（逻辑或）和 &amp;&amp;（逻辑与）左边的操作数（作为条件判断表达式）。</span><br></pre></td></tr></table></figure><h2 id="和-amp-amp-操作符的返回值？"><a href="#和-amp-amp-操作符的返回值？" class="headerlink" title="|| 和 &amp;&amp; 操作符的返回值？"></a>|| 和 &amp;&amp; 操作符的返回值？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|| 和 &amp;&amp; 首先会对第一个操作数执行条件判断，如果其不是布尔值就先进行 ToBoolean 强制类型转换，然后再执行条件</span><br><span class="line">判断。</span><br><span class="line"></span><br><span class="line">对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。</span><br><span class="line"></span><br><span class="line">&amp;&amp; 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。</span><br><span class="line"></span><br><span class="line">|| 和 &amp;&amp; 返回它们其中一个操作数的值，而非条件判断的结果</span><br></pre></td></tr></table></figure><h2 id="Symbol-值的强制类型转换？"><a href="#Symbol-值的强制类型转换？" class="headerlink" title="Symbol 值的强制类型转换？"></a>Symbol 值的强制类型转换？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ES6 允许从符号到字符串的显式强制类型转换，然而隐式强制类型转换会产生错误。</span><br><span class="line"></span><br><span class="line">Symbol 值不能够被强制类型转换为数字（显式和隐式都会产生错误），但可以被强制类型转换为布尔值（显式和隐式结果</span><br><span class="line">都是 true ）。</span><br></pre></td></tr></table></figure><h2 id="操作符的强制类型转换规则？"><a href="#操作符的强制类型转换规则？" class="headerlink" title="== 操作符的强制类型转换规则？"></a>== 操作符的强制类型转换规则？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）字符串和数字之间的相等比较，将字符串转换为数字之后再进行比较。</span><br><span class="line"></span><br><span class="line">（2）其他类型和布尔类型之间的相等比较，先将布尔值转换为数字后，再应用其他规则进行比较。</span><br><span class="line"></span><br><span class="line">（3）null 和 undefined 之间的相等比较，结果为真。其他值和它们进行比较都返回假值。</span><br><span class="line"></span><br><span class="line">（4）对象和非对象之间的相等比较，对象先调用 ToPrimitive 抽象操作后，再进行比较。</span><br><span class="line"></span><br><span class="line">（5）如果一个操作值为 NaN ，则相等比较返回 false（ NaN 本身也不等于 NaN ）。</span><br><span class="line"></span><br><span class="line">（6）如果两个操作值都是对象，则比较它们是不是指向同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true，否则，返回 false。</span><br></pre></td></tr></table></figure><h2 id="如何将字符串转化为数字，例如-‘12-3b’"><a href="#如何将字符串转化为数字，例如-‘12-3b’" class="headerlink" title="如何将字符串转化为数字，例如 ‘12.3b’?"></a>如何将字符串转化为数字，例如 ‘12.3b’?</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）使用 Number() 方法，前提是所包含的字符串不包含不合法字符。</span><br><span class="line"></span><br><span class="line">（2）使用 parseInt() 方法，parseInt() 函数可解析一个字符串，并返回一个整数。还可以设置要解析的数字的基数。当基数的值为 0，或没有设置该参数时，parseInt() 会根据 string 来判断数字的基数。</span><br><span class="line"></span><br><span class="line">（3）使用 parseFloat() 方法，该函数解析一个字符串参数并返回一个浮点数。</span><br><span class="line"></span><br><span class="line">（4）使用 + 操作符的隐式转换，前提是所包含的字符串不包含不合法字符。</span><br></pre></td></tr></table></figure><h2 id="如何将浮点数点左边的数每三位添加一个逗号，如-12000000-11-转化为『12-000-000-11』"><a href="#如何将浮点数点左边的数每三位添加一个逗号，如-12000000-11-转化为『12-000-000-11』" class="headerlink" title="如何将浮点数点左边的数每三位添加一个逗号，如 12000000.11 转化为『12,000,000.11』?"></a>如何将浮点数点左边的数每三位添加一个逗号，如 12000000.11 转化为『12,000,000.11』?</h2>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">format</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> number &amp;&amp; number.replace(<span class="regexp">/(?!^)(?=(\d&#123;3&#125;)+\.)/g</span>, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">format1</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Intl</span>.NumberFormat().format(number)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法三</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">format2</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> number.toLocaleString(<span class="string">&#x27;en&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端面试 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS面试知识点总结(二)</title>
      <link href="/53725/"/>
      <url>/53725/</url>
      
        <content type="html"><![CDATA[<h2 id="js-获取原型的方法？"><a href="#js-获取原型的方法？" class="headerlink" title="js 获取原型的方法？"></a>js 获取原型的方法？</h2><ul><li>p.__proto__</li><li>p.constructor.prototype</li><li>Object.getPrototypeOf(p)</li></ul><h2 id="在-js-中不同进制数字的表示方式"><a href="#在-js-中不同进制数字的表示方式" class="headerlink" title="在 js 中不同进制数字的表示方式"></a>在 js 中不同进制数字的表示方式</h2><ul><li><p>以 0X、0x 开头的表示为十六进制。</p></li><li><p>以 0、0O、0o 开头的表示为八进制。</p></li><li><p>以 0B、0b 开头的表示为二进制格式。</p></li></ul><h2 id="js-中整数的安全范围是多少？"><a href="#js-中整数的安全范围是多少？" class="headerlink" title="js 中整数的安全范围是多少？"></a>js 中整数的安全范围是多少？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">安全整数指的是，在这个范围内的整数转化为二进制存储的时候不会出现精度丢失，能够被“安全”呈现的最大整数是 2^53 - 1，</span><br><span class="line">即9007199254740991，在 ES6 中被定义为 Number.MAX_SAFE_INTEGER。最小整数是-9007199254740991，在 ES6 中</span><br><span class="line">被定义为 Number.MIN_SAFE_INTEGER。</span><br><span class="line"></span><br><span class="line">如果某次计算的结果得到了一个超过 JavaScript 数值范围的值，那么这个值会被自动转换为特殊的 Infinity 值。如果某次</span><br><span class="line">计算返回了正或负的 Infinity 值，那么该值将无法参与下一次的计算。判断一个数是不是有穷的，可以使用 isFinite 函数</span><br><span class="line">来判断。</span><br></pre></td></tr></table></figure><h2 id="typeof-NaN-的结果是什么？"><a href="#typeof-NaN-的结果是什么？" class="headerlink" title="typeof NaN 的结果是什么？"></a>typeof NaN 的结果是什么？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NaN 意指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出</span><br><span class="line">数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。</span><br><span class="line"></span><br><span class="line">typeof NaN; // &quot;number&quot;</span><br><span class="line"></span><br><span class="line">NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x === x 不成立）的值。而 NaN != NaN</span><br><span class="line">为 true。</span><br></pre></td></tr></table></figure><h2 id="isNaN-和-Number-isNaN-函数的区别？"><a href="#isNaN-和-Number-isNaN-函数的区别？" class="headerlink" title="isNaN 和 Number.isNaN 函数的区别？"></a>isNaN 和 Number.isNaN 函数的区别？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会</span><br><span class="line">返回 true ，会影响 NaN 的判断。</span><br><span class="line"></span><br><span class="line">函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，这种方法对于 NaN 的判断更为</span><br><span class="line">准确。</span><br></pre></td></tr></table></figure><h2 id="Array-构造函数只有一个参数值时的表现？"><a href="#Array-构造函数只有一个参数值时的表现？" class="headerlink" title="Array 构造函数只有一个参数值时的表现？"></a>Array 构造函数只有一个参数值时的表现？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Array 构造函数只带一个数字参数的时候，该参数会被作为数组的预设长度（length），而非只充当数组中的一个元素。这样</span><br><span class="line">创建出来的只是一个空数组，只不过它的 length 属性被设置成了指定的值。</span><br><span class="line"></span><br><span class="line">构造函数 Array(..) 不要求必须带 new 关键字。不带时，它会被自动补上。</span><br></pre></td></tr></table></figure><h2 id="其他值到字符串的转换规则？"><a href="#其他值到字符串的转换规则？" class="headerlink" title="其他值到字符串的转换规则？"></a>其他值到字符串的转换规则？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">规范的 9.8 节中定义了抽象操作 ToString ，它负责处理非字符串到字符串的强制类型转换。</span><br><span class="line"></span><br><span class="line">（1）Null 和 Undefined 类型 ，null 转换为 &quot;null&quot;，undefined 转换为 &quot;undefined&quot;，</span><br><span class="line"></span><br><span class="line">（2）Boolean 类型，true 转换为 &quot;true&quot;，false 转换为 &quot;false&quot;。</span><br><span class="line"></span><br><span class="line">（3）Number 类型的值直接转换，不过那些极小和极大的数字会使用指数形式。</span><br><span class="line"></span><br><span class="line">（4）Symbol 类型的值直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误。</span><br><span class="line"></span><br><span class="line">（5）对普通对象来说，除非自行定义 toString() 方法，否则会调用 toString()（Object.prototype.toString()）</span><br><span class="line">    来返回内部属性 [[Class]] 的值，如&quot;[object Object]&quot;。如果对象有自己的 toString() 方法，字符串化时就会</span><br><span class="line">    调用该方法并使用其返回值。</span><br></pre></td></tr></table></figure><h2 id="其他值到数字值的转换规则？"><a href="#其他值到数字值的转换规则？" class="headerlink" title="其他值到数字值的转换规则？"></a>其他值到数字值的转换规则？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有时我们需要将非数字值当作数字来使用，比如数学运算。为此 ES5 规范在 9.3 节定义了抽象操作 ToNumber。</span><br><span class="line"></span><br><span class="line">（1）Undefined 类型的值转换为 NaN。</span><br><span class="line"></span><br><span class="line">（2）Null 类型的值转换为 0。</span><br><span class="line"></span><br><span class="line">（3）Boolean 类型的值，true 转换为 1，false 转换为 0。</span><br><span class="line"></span><br><span class="line">（4）String 类型的值转换如同使用 Number() 函数进行转换，如果包含非数字值则转换为 NaN，空字符串为 0。</span><br><span class="line"></span><br><span class="line">（5）Symbol 类型的值不能转换为数字，会报错。</span><br><span class="line"></span><br><span class="line">（6）对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。</span><br><span class="line"></span><br><span class="line">为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先（通过内部操作 DefaultValue）检查该值是否有valueOf() 方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值（如果存在）来进行强制类型转换。</span><br><span class="line"></span><br><span class="line">如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。</span><br></pre></td></tr></table></figure><h2 id="其他值到布尔类型的值的转换规则？"><a href="#其他值到布尔类型的值的转换规则？" class="headerlink" title="其他值到布尔类型的值的转换规则？"></a>其他值到布尔类型的值的转换规则？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ES5 规范 9.2 节中定义了抽象操作 ToBoolean，列举了布尔强制类型转换所有可能出现的结果。</span><br><span class="line"></span><br><span class="line">以下这些是假值：</span><br><span class="line">• undefined</span><br><span class="line">• null</span><br><span class="line">• false</span><br><span class="line">• +0、-0 和 NaN</span><br><span class="line">• &quot;&quot;</span><br><span class="line"></span><br><span class="line">假值的布尔强制类型转换结果为 false。从逻辑上说，假值列表以外的都应该是真值。</span><br></pre></td></tr></table></figure><h2 id="和-的-valueOf-和-toString-的结果是什么？"><a href="#和-的-valueOf-和-toString-的结果是什么？" class="headerlink" title="{} 和 [] 的 valueOf 和 toString 的结果是什么？"></a>{} 和 [] 的 valueOf 和 toString 的结果是什么？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#125; 的 valueOf 结果为 &#123;&#125; ，toString 的结果为 &quot;[object Object]&quot;</span><br><span class="line"></span><br><span class="line">[] 的 valueOf 结果为 [] ，toString 的结果为 &quot;&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端面试 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS面试知识点总结 (一)</title>
      <link href="/53408/"/>
      <url>/53408/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍-js-的基本数据类型"><a href="#介绍-js-的基本数据类型" class="headerlink" title="介绍 js 的基本数据类型"></a>介绍 js 的基本数据类型</h2><blockquote><p>js 一共有六种基本数据类型，分别是 Undefined、Null、Boolean、Number、String，还有在 ES6 中新增的 Symbol 和 ES10 中新增的 BigInt 类型。Symbol 代表创建后独一无二且不可变的数据类型，它的出现我认为主要是为了解决可能出现的全局变量冲突的问题。BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。</p></blockquote><h2 id="JavaScript-有几种类型的值"><a href="#JavaScript-有几种类型的值" class="headerlink" title="JavaScript 有几种类型的值"></a>JavaScript 有几种类型的值</h2><blockquote><p>js 可以分为两种类型的值，一种是基本数据类型，一种是复杂数据类型。<br>  基本数据类型….（参考1）复杂数据类型指的是 Object 类型，所有其他的如 Array、Date 等数据类型都可以理解为 Object 类型的子类。两种类型间的主要区别是它们的存储位置不同，基本数据类型的值直接保存在栈中，而复杂数据类型的值保存在堆中，通过使用在栈中保存对应的指针来获取堆中的值。</p></blockquote><h2 id="什么是堆？什么是栈"><a href="#什么是堆？什么是栈" class="headerlink" title="什么是堆？什么是栈"></a>什么是堆？什么是栈</h2><blockquote><p>堆和栈的概念存在于数据结构中和操作系统内存中。<br>  在数据结构中，栈中数据的存取方式为先进后出。而堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。完全<br>  二叉树是堆的一种实现方式。在操作系统中，内存被分为栈区和堆区。栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。堆区内存一般由程序员分配释放，若程序员不释放，程序结束时可能由垃圾回收机制回收。</p></blockquote><h2 id="内部属性-Class-是什么"><a href="#内部属性-Class-是什么" class="headerlink" title="内部属性 [[Class]] 是什么"></a>内部属性 [[Class]] 是什么</h2>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">所有 <span class="keyword">typeof</span> 返回值为 <span class="string">&quot;object&quot;</span> 的对象（如数组）都包含一个内部属性 [[Class]]（我们可以把它看作一个内部的分类，而非</span><br><span class="line">传统的面向对象意义上的类）。这个属性无法直接访问，一般通过 <span class="built_in">Object</span>.prototype.toString(..) 来查看。例如：</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call( [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] );</span><br><span class="line"><span class="comment">// &quot;[object Array]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call( <span class="regexp">/regex-literal/i</span> );</span><br><span class="line"><span class="comment">// &quot;[object RegExp]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们自己创建的类就不会有这份特殊待遇，因为 toString() 找不到 toStringTag 属性时只好返回默认的 Object 标签</span></span><br><span class="line"><span class="comment">// 默认情况类的[[Class]]返回[object Object]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class1</span> </span>&#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> Class1()); <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="comment">// 需要定制[[Class]]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class2</span> </span>&#123;</span><br><span class="line">  get [<span class="built_in">Symbol</span>.toStringTag]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Class2&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> Class2()); <span class="comment">// &quot;[object Class2]&quot;</span></span><br></pre></td></tr></table></figure><h2 id="介绍-js-有哪些内置对象"><a href="#介绍-js-有哪些内置对象" class="headerlink" title="介绍 js 有哪些内置对象"></a>介绍 js 有哪些内置对象</h2><blockquote><p>js 中的内置对象主要指的是在程序执行前存在全局作用域里的由 js 定义的一些全局值属性、函数和用来实例化其他对象的构造函<br>  数对象。一般我们经常用到的如全局变量值 NaN、undefined，全局函数如 parseInt()、parseFloat() 用来实例化对象的构<br>  造函数如 <code>Date</code>、<code>Object</code> 等，还有提供数学计算的单体内置对象如 Math 对象。</p></blockquote><h2 id="undefined-与-undeclared-的区别"><a href="#undefined-与-undeclared-的区别" class="headerlink" title="undefined 与 undeclared 的区别"></a>undefined 与 undeclared 的区别</h2><blockquote><p>已在作用域中声明但还没有赋值的变量，是 undefined 的。相反，还没有在作用域中声明过的变量，是 undeclared 的。<br>  对于 undeclared 变量的引用，浏览器会报引用错误，如 <code>ReferenceError: b is not defined</code> 。但是我们可以使用 typeof 的安全防范机制来避免报错，因为对于 <code>undeclared</code>（或者 not defined ）变量，typeof 会返回 “<code>undefined</code>“。</p></blockquote><h2 id="null-和-undefined-的区别"><a href="#null-和-undefined-的区别" class="headerlink" title="null 和 undefined 的区别"></a>null 和 undefined 的区别</h2><blockquote><p>首先 <code>Undefined</code> 和 <code>Null</code> 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 <code>undefined</code> 和 <code>null。</code><br>  (1) <code>undefined</code> 代表的含义是未定义，null 代表的含义是空对象。一般变量声明了但还没有定义的时候会返回 undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化。<br>  (2) <code>undefined</code> 在 js 中不是一个保留字，这意味着我们可以使用 <code>undefined</code> 来作为一个变量名，这样的做法是非常危险的，它会影响我们对 <code>undefined</code> 值的判断。但是我们可以通过一些方法获得安全的 <code>undefined</code> 值，比如说 void 0。<br>  (3) 当我们对两种类型使用 typeof 进行判断的时候，Null 类型化会返回 “object”，这是一个历史遗留的问题。当我们使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。</p></blockquote><h2 id="如何获取安全的-undefined-值"><a href="#如何获取安全的-undefined-值" class="headerlink" title="如何获取安全的 undefined 值"></a>如何获取安全的 undefined 值</h2><blockquote><p>因为 <code>undefined</code> 是一个标识符，所以可以被当作变量来使用和赋值，但是这样会影响 <code>undefined</code> 的正常判断。<br>  表达式 <code>void</code> ___ 没有返回值，因此返回结果是 <code>undefined</code>,<code>void</code> 并不改变表达式的结果，只是让表达式不返回值。<br>  按惯例我们用 <code>void</code> 来获得 <code>undefined</code></p></blockquote><h2 id="说几条写-JavaScript-的基本规范"><a href="#说几条写-JavaScript-的基本规范" class="headerlink" title="说几条写 JavaScript 的基本规范"></a>说几条写 JavaScript 的基本规范</h2><blockquote><p>在平常项目开发中，我们遵守一些这样的基本规范，比如说：<br>  （1）一个函数作用域中所有的变量声明应该尽量提到函数首部，用一个 <code>var</code> 声明，不允许出现两个连续的 <code>var</code> 声明，声明时如果变量没有值，应该给该变量赋值对应类型的初始值，便于他人阅读代码时，能够一目了然的知道变量对应的类型值。<br>  （2）代码中出现地址、时间等字符串时需要使用常量代替。<br>  （3）在进行比较的时候吧，尽量使用’===’, ‘!==’代替’==’, ‘!=’。<br>  （4）不要在内置对象的原型上添加方法，如 Array, Date。<br>  （5）<code>switch</code> 语句必须带有 <code>default</code> 分支。<br>  （6）<code>for</code> 循环必须使用大括号。<br>  （7）if 语句必须使用大括号。</p></blockquote><h2 id="JavaScript-原型，原型链？-有什么特点"><a href="#JavaScript-原型，原型链？-有什么特点" class="headerlink" title="JavaScript 原型，原型链？ 有什么特点"></a>JavaScript 原型，原型链？ 有什么特点</h2><blockquote><p>(1) 在 js 中我们是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性值，这个属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当我们使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。<br>  (2) 一般来说我们是不应该能够获取到这个值的，但是现在浏览器中都实现了 <code>__proto__</code> 属性来让我们访问这个属性，但是我们最好不要使用这个属性，因为它不是规范中规定的。ES5新增了一个 <code>Object.getPrototypeOf()</code> 方法，我们可以通过这个方法来获取对象的原型。<br>  (3) 当我们访问一个对象的属性时，如果这个对象不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 <code>Object.prototype</code> 。所以这就是我们新建的对象为什么能够使用 toString() 等方法的原因。<br>  (4) JavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端面试 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML高频面试题-03</title>
      <link href="/61542/"/>
      <url>/61542/</url>
      
        <content type="html"><![CDATA[<h2 id="webSocket-如何兼容低版本浏览器？"><a href="#webSocket-如何兼容低版本浏览器？" class="headerlink" title="webSocket 如何兼容低版本浏览器？"></a>webSocket 如何兼容低版本浏览器？</h2><blockquote><pre><code>1. Adobe Flash Socket2. ActiveX HTMLFile (IE)3. 基于 multipart 编码发送 XHR4. 基于长轮询的 XHR</code></pre></blockquote><h2 id="页面可见性（Page-Visibility-API）-可以有哪些用途？"><a href="#页面可见性（Page-Visibility-API）-可以有哪些用途？" class="headerlink" title="页面可见性（Page Visibility API） 可以有哪些用途？"></a>页面可见性（Page Visibility API） 可以有哪些用途？</h2><blockquote><p>这个新的 API 的意义在于，通过监听网页的可见性，可以预判网页的卸载，还可以用来节省资源，减缓电能的消耗。比如，一旦用户<br>    不看网页，下面这些网页行为都是可以暂停的。<br>    1. 对服务器的轮询<br>    2. 网页动画<br>    3. 正在播放的音频或视频<br>   详细资料可以参考：<br>   <a href="http://www.ruanyifeng.com/blog/2018/10/page_visibility_api.html">《Page Visibility API 教程》</a></p></blockquote><h2 id="实现不使用-border-画出-1-px-高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。"><a href="#实现不使用-border-画出-1-px-高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。" class="headerlink" title="实现不使用 border 画出 1 px 高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。"></a>实现不使用 border 画出 1 px 高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。</h2>   <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;height:1px;overflow:hidden;background:red&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="title-与-h1-的区别？"><a href="#title-与-h1-的区别？" class="headerlink" title="title 与 h1 的区别？"></a>title 与 h1 的区别？</h2><blockquote><p>title 属性没有明确意义只表示是个标题，h1 则表示层次明确的标题，对页面信息的抓取也有很大的影响。</p></blockquote><h2 id="lt-img-gt-的-title-和-alt-有什么区别？"><a href="#lt-img-gt-的-title-和-alt-有什么区别？" class="headerlink" title="&lt;img&gt; 的 title 和 alt 有什么区别？"></a><code>&lt;img&gt;</code> 的 title 和 alt 有什么区别？</h2><blockquote><ol><li>title 通常当鼠标滑动到元素上的时候显示</li><li>alt 是 <code>img</code> 的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。</li></ol></blockquote><h2 id="Canvas-和-SVG-有什么区别？"><a href="#Canvas-和-SVG-有什么区别？" class="headerlink" title="Canvas 和 SVG 有什么区别？"></a>Canvas 和 SVG 有什么区别？</h2><blockquote><ol><li>Canvas 是一种通过 JavaScript 来绘制 2D 图形的方法。Canvas 是逐像素来进行渲染的，因此当我们对 Canvas 进行缩放时，会出现锯齿或者失真的情况。</li><li>SVG 是一种使用 XML 描述 2D 图形的语言。SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。我们可以为某个元素<br>附加 JavaScript 事件监听函数。并且 SVG 保存的是图形的绘制方法，因此当 SVG 图形缩放时并不会失真。<br>详细资料可以参考：<br><a href="https://www.zhihu.com/question/19690014">《SVG 与 HTML5 的 canvas 各有什么优点，哪个更有前途？》</a></li></ol></blockquote><h2 id="网页验证码是干嘛的，是为了解决什么安全问题？"><a href="#网页验证码是干嘛的，是为了解决什么安全问题？" class="headerlink" title="网页验证码是干嘛的，是为了解决什么安全问题？"></a>网页验证码是干嘛的，是为了解决什么安全问题？</h2><blockquote><ol><li>区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水</li><li>有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试</li></ol></blockquote><h2 id="渐进增强和优雅降级的定义"><a href="#渐进增强和优雅降级的定义" class="headerlink" title="渐进增强和优雅降级的定义"></a>渐进增强和优雅降级的定义</h2><blockquote><ol><li>渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进优化</li><li>优雅降级：一开始就根据高版本浏览器构建完整的功能，然后再针对低版本浏览器进行兼容。</li></ol></blockquote><h2 id="html-中attribute-和-property-的区别是什么？"><a href="#html-中attribute-和-property-的区别是什么？" class="headerlink" title="html 中attribute 和 property 的区别是什么？"></a>html 中attribute 和 property 的区别是什么？</h2><blockquote><ol><li>attribute 是 dom 元素在文档中作为 html 标签拥有的属性；</li><li>property 就是 dom 元素在 js 中作为对象拥有的属性。<br>对于 html 的标准属性来说，attribute 和 property 是同步的，是会自动更新的，<br>但是对于自定义的属性来说，他们是不同步的。</li></ol></blockquote><h2 id="对-web-标准、可用性、可访问性的理解"><a href="#对-web-标准、可用性、可访问性的理解" class="headerlink" title="对 web 标准、可用性、可访问性的理解"></a>对 web 标准、可用性、可访问性的理解</h2><blockquote><ol><li>可用性（Usability）：产品是否容易上手，用户能否完成任务，效率如何，以及这过程中用户的主观感受可好，是从用户的角度来看产品的质量。可用性好意味着产品质量高，是企业的核心竞争力<ol start="2"><li>可访问性（Accessibility）：Web 内容对于残障用户的可阅读和可理解性</li><li>可维护性（Maintainability）：一般包含两个层次，一是当系统出现问题时，快速定位并解决问题的成本，成本低则可维护性好。<br>二是代码是否容易被人理解，是否容易修改和增强功能。</li></ol></li></ol></blockquote><h2 id="IE-各版本和-Chrome-可以并行下载多少个资源？"><a href="#IE-各版本和-Chrome-可以并行下载多少个资源？" class="headerlink" title="IE 各版本和 Chrome 可以并行下载多少个资源？"></a>IE 各版本和 Chrome 可以并行下载多少个资源？</h2><blockquote><ol><li>IE6 2 个并发</li><li>iE7 升级之后的 6 个并发，之后版本也是 6 个</li><li>Firefox，chrome 也是6个</li></ol></blockquote><h2 id="怎么重构页面？"><a href="#怎么重构页面？" class="headerlink" title="怎么重构页面？"></a>怎么重构页面？</h2>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1） 编写 CSS</span><br><span class="line">（2） 让页面结构更合理化，提升用户体验</span><br><span class="line">（3） 实现良好的页面效果和提升性能</span><br></pre></td></tr></table></figure><h2 id="浏览器架构"><a href="#浏览器架构" class="headerlink" title="浏览器架构"></a>浏览器架构</h2>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 用户界面</span><br><span class="line">  * 主进程</span><br><span class="line">  * 内核</span><br><span class="line">      * 渲染引擎</span><br><span class="line">      * JS 引擎</span><br><span class="line">          * 执行栈</span><br><span class="line">      * 事件触发线程</span><br><span class="line">          * 消息队列</span><br><span class="line">              * 微任务</span><br><span class="line">              * 宏任务</span><br><span class="line">      * 网络异步线程</span><br><span class="line">      * 定时器线程</span><br></pre></td></tr></table></figure><h2 id="常用的-meta-标签"><a href="#常用的-meta-标签" class="headerlink" title="常用的 meta 标签"></a>常用的 meta 标签</h2>   <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span>&gt;</span> 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span>&gt;</span> 标签位于文档的头部，不包含任何内容。<span class="tag">&lt;<span class="name">meta</span>&gt;</span> 标签的属性定义了与文档相关联的名称/值对。</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span>  H5标准声明，使用 HTML5 doctype，不区分大小写</span><br><span class="line"><span class="tag">&lt;<span class="name">head</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span> 标准的 lang 属性写法</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span>    声明文档使用的字符编码</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge,chrome=1&quot;</span>/&gt;</span>   优先使用 IE 最新版本和 Chrome</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;不超过150个字符&quot;</span>/&gt;</span>       页面描述</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;&quot;</span>/&gt;</span>      页面关键词者</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">content</span>=<span class="string">&quot;name, email@gmail.com&quot;</span>/&gt;</span>    网页作</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;robots&quot;</span> <span class="attr">content</span>=<span class="string">&quot;index,follow&quot;</span>/&gt;</span>      搜索引擎抓取</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no&quot;</span>&gt;</span> 为移动设备添加 viewport</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;apple-mobile-web-app-title&quot;</span> <span class="attr">content</span>=<span class="string">&quot;标题&quot;</span>&gt;</span> iOS 设备 begin</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;apple-mobile-web-app-capable&quot;</span> <span class="attr">content</span>=<span class="string">&quot;yes&quot;</span>/&gt;</span>  添加到主屏后的标题（iOS 6 新增）</span><br><span class="line">是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;apple-itunes-app&quot;</span> <span class="attr">content</span>=<span class="string">&quot;app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL&quot;</span>&gt;</span></span><br><span class="line">添加智能 App 广告条 Smart App Banner（iOS 6+ Safari）</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;apple-mobile-web-app-status-bar-style&quot;</span> <span class="attr">content</span>=<span class="string">&quot;black&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;format-detection&quot;</span> <span class="attr">content</span>=<span class="string">&quot;telphone=no, email=no&quot;</span>/&gt;</span>  设置苹果工具栏颜色</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;renderer&quot;</span> <span class="attr">content</span>=<span class="string">&quot;webkit&quot;</span>&gt;</span>  启用360浏览器的极速模式(webkit)</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span>     避免IE使用兼容模式</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Cache-Control&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no-siteapp&quot;</span> /&gt;</span>    不让百度转码</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;HandheldFriendly&quot;</span> <span class="attr">content</span>=<span class="string">&quot;true&quot;</span>&gt;</span>     针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;MobileOptimized&quot;</span> <span class="attr">content</span>=<span class="string">&quot;320&quot;</span>&gt;</span>   微软的老式浏览器</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;screen-orientation&quot;</span> <span class="attr">content</span>=<span class="string">&quot;portrait&quot;</span>&gt;</span>   uc强制竖屏</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;x5-orientation&quot;</span> <span class="attr">content</span>=<span class="string">&quot;portrait&quot;</span>&gt;</span>    QQ强制竖屏</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;full-screen&quot;</span> <span class="attr">content</span>=<span class="string">&quot;yes&quot;</span>&gt;</span>              UC强制全屏</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;x5-fullscreen&quot;</span> <span class="attr">content</span>=<span class="string">&quot;true&quot;</span>&gt;</span>       QQ强制全屏</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;browsermode&quot;</span> <span class="attr">content</span>=<span class="string">&quot;application&quot;</span>&gt;</span>   UC应用模式</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;x5-page-mode&quot;</span> <span class="attr">content</span>=<span class="string">&quot;app&quot;</span>&gt;</span>    QQ应用模式</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;msapplication-tap-highlight&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no&quot;</span>&gt;</span>    windows phone 点击无高光</span><br><span class="line">设置页面不缓存</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;pragma&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no-cache&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;cache-control&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no-cache&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;expires&quot;</span> <span class="attr">content</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>   详细资料可以参考：<br>   <a href="http://www.cnblogs.com/qiumohanyu/p/5431859.html">《Meta 标签用法大全》</a></p><h2 id="css-reset-和-normalize-css-有什么区别？"><a href="#css-reset-和-normalize-css-有什么区别？" class="headerlink" title="css reset 和 normalize.css 有什么区别？"></a>css reset 和 normalize.css 有什么区别？</h2><blockquote><p>为什么会有 CSS Reset 的存在呢？那是因为早期的浏览器支持和理解的 CSS 规范不同，导致渲染页面时效果不一致，会出现很多<br>    兼容性问题。<br>    reset 的目的，是将所有的浏览器的自带样式重置掉，这样更易于保持各浏览器渲染的一致性。<br>    normalize 的理念则是尽量保留浏览器的默认样式，不进行太多的重置，而尽力让这些样式保持一致并尽可能与现代标准相符合。reset 是最早的一种解决浏览器间样式不兼容问题的方案，它的基本思想是将浏览器的所有样式都重置掉，从而达到所有浏览器<br>    样式保持一致的效果。但是使用这种方法，可能会带来一些性能上的问题，并且对于一些元素的不必要的样式的重置，其实反而会造成<br>    画蛇添足的效果。<br>    后面出现一种更好的解决浏览器间样式不兼容的方法，就是 normalize.css ，它的思想是尽量的保留浏览器自带的样式，通过在原<br>    有的样式的基础上进行调整，来保持各个浏览器间的样式表现一致。相对与 css reset，normalize.css 的方法保留了有价值的默<br>    认值，并且修复了一些浏览器的 bug，而且使用 normalize.css 不会造成元素复杂的继承链。<br>   详细资料可以参考：<br>   <a href="https://segmentfault.com/a/1190000003021766#articleHeader0">《关于CSS Reset 那些事（一）之 历史演变与 Normalize.css》</a><br>   <a href="https://segmentfault.com/q/1010000000117189">《Normalize.css 和 Reset CSS 有什么本质区别没？》</a></p></blockquote><h2 id="用于预格式化文本的标签是？"><a href="#用于预格式化文本的标签是？" class="headerlink" title="用于预格式化文本的标签是？"></a>用于预格式化文本的标签是？</h2>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">预格式化就是保留文字在源码中的格式 最后显示出来样式与源码中的样式一致 所见即所得。</span><br><span class="line"></span><br><span class="line">&lt;pre&gt; 定义预格式文本，保持文本原有的格式</span><br></pre></td></tr></table></figure><h2 id="head-标签中必不少的是？"><a href="#head-标签中必不少的是？" class="headerlink" title="head 标签中必不少的是？"></a>head 标签中必不少的是？</h2>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;head&gt; 标签用于定义文档的头部，它是所有头部元素的容器。&lt;head&gt; 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供</span><br><span class="line">元信息等等。</span><br><span class="line"></span><br><span class="line">文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数</span><br><span class="line">据都不会真正作为内容显示给读者。</span><br><span class="line"></span><br><span class="line">下面这些标签可用在 head 部分：&lt;base&gt;, &lt;link&gt;, &lt;meta&gt;, &lt;script&gt;, &lt;style&gt;, 以及 &lt;title&gt;。</span><br><span class="line"></span><br><span class="line">&lt;title&gt; 定义文档的标题，它是 head 部分中唯一必需的元素。</span><br></pre></td></tr></table></figure><h2 id="HTML5-新增的表单元素有？"><a href="#HTML5-新增的表单元素有？" class="headerlink" title="HTML5 新增的表单元素有？"></a>HTML5 新增的表单元素有？</h2>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">datalist 规定输入域的选项列表，通过 option 创建！ </span><br><span class="line"></span><br><span class="line">keygen 提供一种验证用户的可靠方法，密钥对生成器，私钥存于客户端，公钥发到服务器，用于之后验证客户端证书！</span><br><span class="line"></span><br><span class="line">output 元素用于不同类型的输出！</span><br></pre></td></tr></table></figure><h2 id="在-HTML5-中，哪个方法用于获得用户的当前位置？"><a href="#在-HTML5-中，哪个方法用于获得用户的当前位置？" class="headerlink" title="在 HTML5 中，哪个方法用于获得用户的当前位置？"></a>在 HTML5 中，哪个方法用于获得用户的当前位置？</h2>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getCurrentPosition()</span><br></pre></td></tr></table></figure><h2 id="文档的不同注释方式？"><a href="#文档的不同注释方式？" class="headerlink" title="文档的不同注释方式？"></a>文档的不同注释方式？</h2><blockquote><ol><li>HTML 的注释方法 <!--注释内容--> </li><li>CSS 的注释方法 /<em>注释内容</em>/ </li><li>JavaScript 的注释方法 /* 多行注释方式 */ //单行注释方式</li></ol></blockquote><h2 id="disabled-和-readonly-的区别？"><a href="#disabled-和-readonly-的区别？" class="headerlink" title="disabled 和 readonly 的区别？"></a>disabled 和 readonly 的区别？</h2><blockquote><ol><li>disabled 指当 input 元素加载时禁用此元素。input 内容不会随着表单提交。</li><li>readonly 规定输入字段为只读。input 内容会随着表单提交。</li><li>无论设置 readonly 还是 disabled，通过 js 脚本都能更改 input 的 value</li></ol></blockquote><h2 id="主流浏览器内核私有属性-css-前缀？"><a href="#主流浏览器内核私有属性-css-前缀？" class="headerlink" title="主流浏览器内核私有属性 css 前缀？"></a>主流浏览器内核私有属性 css 前缀？</h2><blockquote><ol><li>mozilla 内核 （firefox,flock 等）    -moz<ol start="2"><li>webkit  内核 （safari,chrome 等）   -webkit</li><li>opera   内核 （opera 浏览器）        -o</li><li>trident 内核 （ie 浏览器）           -ms</li></ol></li></ol></blockquote><h2 id="前端性能优化？"><a href="#前端性能优化？" class="headerlink" title="前端性能优化？"></a>前端性能优化？</h2><blockquote><p>前端性能优化主要是为了提高页面的加载速度，优化用户的访问体验。我认为可以从这些方面来进行优化。</p></blockquote><ol><li>第一个方面是页面的内容方面</li></ol><pre><code>（1）通过文件合并、css 雪碧图、使用 base64 等方式来减少 HTTP 请求数，避免过多的请求造成等待的情况。（2）通过 DNS 缓存等机制来减少 DNS 的查询次数。（3）通过设置缓存策略，对常用不变的资源进行缓存。（4）使用延迟加载的方式，来减少页面首屏加载时需要请求的资源。延迟加载的资源当用户需要访问时，再去请求加载。（5）通过用户行为，对某些资源使用预加载的方式，来提高用户需要访问资源时的响应速度。</code></pre><ol start="2"><li>第二个方面是服务器方面</li></ol><pre><code>（1）使用 CDN 服务，来提高用户对于资源请求时的响应速度。（2）服务器端启用 Gzip、Deflate 等方式对于传输的资源进行压缩，减小文件的体积。（3）尽可能减小 cookie 的大小，并且通过将静态资源分配到其他域名下，来避免对静态资源请求时携带不必要的 cookie</code></pre><ol start="3"><li>第三个方面是 CSS 和 JavaScript 方面</li></ol><pre><code>（1）把样式表放在页面的 head 标签中，减少页面的首次渲染的时间。（2）避免使用 @import 标签。（3）尽量把 js 脚本放在页面底部或者使用 defer 或 async 属性，避免脚本的加载和执行阻塞页面的渲染。（4）通过对 JavaScript 和 CSS 的文件进行压缩，来减小文件的体积。</code></pre><p>   详细的资料可以参考：<br>   <a href="https://juejin.im/post/5b73ef38f265da281e048e51#heading-10">《前端性能优化之雅虎35条军规》</a><br>   <a href="https://juejin.im/entry/58709b9a128fe1006b29cd5d">《你真的了解 gzip 吗？》</a><br>   <a href="https://segmentfault.com/a/1190000012571492">《前端性能优化之 gzip》</a></p><h2 id="Chrome-中的-Waterfall-？"><a href="#Chrome-中的-Waterfall-？" class="headerlink" title="Chrome 中的 Waterfall ？"></a>Chrome 中的 Waterfall ？</h2><blockquote><p>详细资料可以参考：<br>   <a href="https://blog.csdn.net/carian_violet/article/details/84954360">《前端性能之 Chrome 的 Waterfall》</a><br>   <a href="https://blog.csdn.net/csdn_girl/article/details/54911632">《教你读懂网络请求的瀑布图》</a>    <a href="https://www.zhihu.com/question/27085552/answer/35194131">《前端妹子跟我抱怨她们的页面加载很慢的时候，如何在她面前优雅地装逼？》</a></p></blockquote><h2 id="扫描二维码登录网页是什么原理，前后两个事件是如何联系的？"><a href="#扫描二维码登录网页是什么原理，前后两个事件是如何联系的？" class="headerlink" title="扫描二维码登录网页是什么原理，前后两个事件是如何联系的？"></a>扫描二维码登录网页是什么原理，前后两个事件是如何联系的？</h2><blockquote><p>核心过程应该是：浏览器获得一个临时 id，通过长连接等待客户端扫描带有此 id 的二维码后，从长连接中获得客户端上报给 serv<br>    er的帐号信息进行展示。并在客户端点击确认后，获得服务器授信的令牌，进行随后的信息交互过程。在超时、网络断开、其他设备<br>    上登录后，此前获得的令牌或丢失、或失效，对授权过程形成有效的安全防护。</p></blockquote><pre><code>我的理解二维码登录网页的基本原理是，用户进入登录网页后，服务器生成一个 uid 来标识一个用户。对应的二维码对应了一个对应 uid 的链接，任何能够识别二维码的应用都可以获得这个链接，但是它们没有办法和对应登录的服务器响应。比如微信的二维码登录，只有用微信识这个二维码才有效。当微信客户端打开这个链接时，对应的登录服务器就获得了用户的相关信息。这个时候登录网页根据先前的长连接获取到服务器传过来的用户信息进行显示。然后提前预加载一些登录后可能用到的信息。当客户端点击确认授权登陆后，服务器生成一个权限令牌给网页，网页之后使用这个令牌进行信息的交互过程。由于整个授权的过程都是在手机端进行的，因此能够很好的防止 PC 上泛滥的病毒。并且在超时、网络断开、其他设备上登录后，此前获得的令牌或丢失、或失效，对授权过程能够形成有效的安全防护。详细资料可以参考：</code></pre><p>   <a href="https://www.zhihu.com/question/20368066">《微信扫描二维码登录网页》</a></p><h2 id="Html-规范中为什么要求引用资源不加协议头http或者https？"><a href="#Html-规范中为什么要求引用资源不加协议头http或者https？" class="headerlink" title="Html 规范中为什么要求引用资源不加协议头http或者https？"></a>Html 规范中为什么要求引用资源不加协议头<code>http</code>或者<code>https</code>？</h2><blockquote><p>如果用户当前访问的页面是通过 HTTPS 协议来浏览的，那么网页中的资源也只能通过 HTTPS 协议来引用，否则浏览器会出现<br>    警告信息，不同浏览器警告信息展现形式不同。</p></blockquote><pre><code>为了解决这个问题，我们可以省略 URL 的协议声明，省略后浏览器照样可以正常引用相应的资源，这项解决方案称为 protocol-relative URL，暂且可译作协议相对 URL。如果使用协议相对 URL，无论是使用 HTTPS，还是 HTTP 访问页面，浏览器都会以相同的协议请求页面中的资源，避免弹出类似的警告信息，同时还可以节省5字节的数据量。</code></pre><p>   详细资料可以参考：<br>   <a href="https://www.ludou.org/the-protocol-relative-url.html">《协议相对 URL》</a><br>   <a href="https://www.tuicool.com/articles/nEjU7b">《Why you need protocol-relative URLs <em>now</em>》</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端面试 </category>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML高频面试题-02</title>
      <link href="/12455/"/>
      <url>/12455/</url>
      
        <content type="html"><![CDATA[<h2 id="CSS-如何阻塞文档解析？（浏览器解析过程）"><a href="#CSS-如何阻塞文档解析？（浏览器解析过程）" class="headerlink" title="CSS 如何阻塞文档解析？（浏览器解析过程）"></a>CSS 如何阻塞文档解析？（浏览器解析过程）</h2>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">理论上，既然样式表不改变 DOM 树，也就没有必要停下文档的解析等待它们，然而，存在一个问题，JavaScript 脚本执行时可</span><br><span class="line">能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。</span><br><span class="line"></span><br><span class="line">所以如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟 JavaScript 脚本执行和文档</span><br><span class="line">的解析，直至其完成 CSSOM 的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，</span><br><span class="line">最后再继续文档的解析。</span><br></pre></td></tr></table></figure><h2 id="渲染页面时常见哪些不良现象？（浏览器渲染过程）"><a href="#渲染页面时常见哪些不良现象？（浏览器渲染过程）" class="headerlink" title="渲染页面时常见哪些不良现象？（浏览器渲染过程）"></a>渲染页面时常见哪些不良现象？（浏览器渲染过程）</h2>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FOUC：主要指的是样式闪烁的问题，由于浏览器渲染机制（比如firefox），在 CSS 加载之前，先呈现了 HTML，就会导致展示</span><br><span class="line">      出无样式内容，然后样式突然呈现的现象。会出现这个问题的原因主要是 css 加载时间过长，或者 css 被放在了文档底</span><br><span class="line">      部。</span><br><span class="line"></span><br><span class="line">白屏：有些浏览器渲染机制（比如chrome）要先构建 DOM 树和 CSSOM 树，构建完成后再进行渲染，如果 CSS 部分放在 HTML </span><br><span class="line">     尾部，由于 CSS 未加载完成，浏览器迟迟未渲染，从而导致白屏；也可能是把 js 文件放在头部，脚本的加载会阻塞后面</span><br><span class="line">     文档内容的解析，从而页面迟迟未渲染出来，出现白屏问题。</span><br></pre></td></tr></table></figure><p>   详细资料可以参考：<br>    <a href="https://juejin.im/entry/58f867045c497d0058e2ff3a">《前端魔法堂：解秘 FOUC》</a><br>    <a href="https://www.jianshu.com/p/6617efa874b0">《白屏问题和 FOUC》</a></p><h2 id="如何优化关键渲染路径？（浏览器渲染过程）"><a href="#如何优化关键渲染路径？（浏览器渲染过程）" class="headerlink" title="如何优化关键渲染路径？（浏览器渲染过程）"></a>如何优化关键渲染路径？（浏览器渲染过程）</h2>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">为尽快完成首次渲染，我们需要最大限度减小以下三种可变因素：</span><br><span class="line"></span><br><span class="line">（1）关键资源的数量。</span><br><span class="line">（2）关键路径长度。</span><br><span class="line">（3）关键字节的数量。</span><br><span class="line"></span><br><span class="line">关键资源是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越小，对 CPU 以及其他资源的占用也就越少。</span><br><span class="line"></span><br><span class="line">同样，关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响：某些资源只能在上一资源处理完毕之后才能开始下载，</span><br><span class="line">并且资源越大，下载所需的往返次数就越多。</span><br><span class="line"></span><br><span class="line">最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。要减少字节数，我们可以减少资源数（将它</span><br><span class="line">们删除或设为非关键资源），此外还要压缩和优化各项资源，确保最大限度减小传送大小。</span><br><span class="line"></span><br><span class="line">优化关键渲染路径的常规步骤如下：</span><br><span class="line"></span><br><span class="line">（1）对关键路径进行分析和特性描述：资源数、字节数、长度。</span><br><span class="line">（2）最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。</span><br><span class="line">（3）优化关键字节数以缩短下载时间（往返次数）。</span><br><span class="line">（4）优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度。</span><br></pre></td></tr></table></figure><p>   详细资料可以参考：<br>   <a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/optimizing-critical-rendering-path?hl=zh-cn">《优化关键渲染路径》</a></p><h2 id="什么是重绘和回流？（浏览器绘制过程）"><a href="#什么是重绘和回流？（浏览器绘制过程）" class="headerlink" title="什么是重绘和回流？（浏览器绘制过程）"></a>什么是重绘和回流？（浏览器绘制过程）</h2>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">重绘: 当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的操作，比如 background</span><br><span class="line">      -color，我们将这样的操作称为重绘。</span><br><span class="line"></span><br><span class="line">回流：当渲染树中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变而需要重新构建的操作，会影响到布局的操作，这样</span><br><span class="line">     的操作我们称为回流。</span><br><span class="line"></span><br><span class="line">常见引起回流属性和方法：</span><br><span class="line"></span><br><span class="line">任何会改变元素几何信息（元素的位置和尺寸大小）的操作，都会触发回流。</span><br><span class="line"></span><br><span class="line">（1）添加或者删除可见的 DOM 元素；</span><br><span class="line">（2）元素尺寸改变——边距、填充、边框、宽度和高度</span><br><span class="line">（3）内容变化，比如用户在 input 框中输入文字</span><br><span class="line">（4）浏览器窗口尺寸改变——resize事件发生时</span><br><span class="line">（5）计算 offsetWidth 和 offsetHeight 属性</span><br><span class="line">（6）设置 style 属性的值</span><br><span class="line">（7）当你修改网页的默认字体时。</span><br><span class="line"></span><br><span class="line">回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列</span><br><span class="line">回流。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>   常见引起重绘属性和方法：</p><p>   <img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-14.png" alt="常见引起回流属性和方法"></p><p>   常见引起回流属性和方法：</p><p>   <img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-13.png" alt="常见引起重绘属性和方法"></p><p>   详细资料可以参考：<br>   <a href="https://juejin.im/post/5a9923e9518825558251c96a">《浏览器的回流与重绘》</a></p><h2 id="如何减少回流？（浏览器绘制过程）"><a href="#如何减少回流？（浏览器绘制过程）" class="headerlink" title="如何减少回流？（浏览器绘制过程）"></a>如何减少回流？（浏览器绘制过程）</h2>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）使用 transform 替代 top</span><br><span class="line"></span><br><span class="line">（2）不要把节点的属性值放在一个循环里当成循环里的变量</span><br><span class="line"></span><br><span class="line">（3）不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局</span><br><span class="line"></span><br><span class="line">（4）把 DOM 离线后修改。如：使用 documentFragment 对象在内存里操作 DOM</span><br><span class="line"></span><br><span class="line">（5）不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className。</span><br></pre></td></tr></table></figure><h2 id="为什么操作-DOM-慢？（浏览器绘制过程）"><a href="#为什么操作-DOM-慢？（浏览器绘制过程）" class="headerlink" title="为什么操作 DOM 慢？（浏览器绘制过程）"></a>为什么操作 DOM 慢？（浏览器绘制过程）</h2>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一些 DOM 的操作或者属性访问可能会引起页面的回流和重绘，从而引起性能上的消耗。</span><br></pre></td></tr></table></figure><h2 id="DOMContentLoaded-事件和-Load-事件的区别？"><a href="#DOMContentLoaded-事件和-Load-事件的区别？" class="headerlink" title="DOMContentLoaded 事件和 Load 事件的区别？"></a>DOMContentLoaded 事件和 Load 事件的区别？</h2>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和</span><br><span class="line">子框架的加载完成。</span><br><span class="line"></span><br><span class="line">Load 事件是当所有资源加载完成后触发的。</span><br></pre></td></tr></table></figure><p>   详细资料可以参考：<br>   <a href="https://www.jianshu.com/p/ca8dae435a2c">《DOMContentLoaded 事件 和 Load 事件的区别？》</a></p><h2 id="HTML5-有哪些新特性、移除了那些元素？"><a href="#HTML5-有哪些新特性、移除了那些元素？" class="headerlink" title="HTML5 有哪些新特性、移除了那些元素？"></a>HTML5 有哪些新特性、移除了那些元素？</h2>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。</span><br><span class="line"></span><br><span class="line">新增的有：</span><br><span class="line"> </span><br><span class="line">绘画 canvas;</span><br><span class="line">用于媒介回放的 video 和 audio 元素;</span><br><span class="line">本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;</span><br><span class="line">sessionStorage 的数据在浏览器关闭后自动删除;</span><br><span class="line">语意化更好的内容元素，比如 article、footer、header、nav、section;</span><br><span class="line">表单控件，calendar、date、time、email、url、search;</span><br><span class="line">新的技术 webworker, websocket;</span><br><span class="line">新的文档属性 document.visibilityState</span><br><span class="line"></span><br><span class="line">移除的元素有：</span><br><span class="line"></span><br><span class="line">纯表现的元素：basefont，big，center，font, s，strike，tt，u;</span><br><span class="line">对可用性产生负面影响的元素：frame，frameset，noframes；</span><br></pre></td></tr></table></figure><h2 id="如何处理-HTML5-新标签的浏览器兼容问题？"><a href="#如何处理-HTML5-新标签的浏览器兼容问题？" class="headerlink" title="如何处理 HTML5 新标签的浏览器兼容问题？"></a>如何处理 HTML5 新标签的浏览器兼容问题？</h2>   <figure class="highlight html"><table><tr><td class="code"><pre><span class="line">（1） IE8/IE7/IE6 支持通过 document.createElement 方法产生的标签，可以利用这一特性让这些浏览器</span><br><span class="line">    支持 HTML5 新标签，浏览器支持新标签后，还需要添加标签默认的样式。</span><br><span class="line"></span><br><span class="line">（2） 当然也可以直接使用成熟的框架，比如 html5shiv ;</span><br><span class="line">     `<span class="comment">&lt;!--[if lt IE 9]&gt;</span></span><br><span class="line"><span class="comment">     &lt;script&gt; src=&quot;https://cdn.jsdelivr.net/npm/html5shiv/dist/html5shiv.min.js&quot;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">     &lt;![endif]--&gt;</span>`</span><br><span class="line"></span><br><span class="line">     [if lte IE 9]……[endif] 判断 IE 的版本，限定只有 IE9 以下浏览器版本需要执行的语句。</span><br></pre></td></tr></table></figure><h2 id="简述一下你对-HTML-语义化的理解？"><a href="#简述一下你对-HTML-语义化的理解？" class="headerlink" title="简述一下你对 HTML 语义化的理解？"></a>简述一下你对 HTML 语义化的理解？</h2><p>   相关知识点：<br>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1） 用正确的标签做正确的事情。</span><br><span class="line">（2） html 语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;</span><br><span class="line">（3） 即使在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的;</span><br><span class="line">（4） 搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO ;</span><br><span class="line">（5） 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</span><br></pre></td></tr></table></figure></p><p>   回答：<br>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我认为 html 语义化主要指的是我们应该使用合适的标签来划分网页内容的结构。html 的本质作用其实就是定义网页文档的结构，</span><br><span class="line">一个语义化的文档，能够使页面的结构更加清晰，易于理解。这样不仅有利于开发者的维护和理解，同时也能够使机器对文档内容进</span><br><span class="line">行正确的解读。比如说我们常用的 b 标签和 strong 标签，它们在样式上都是文字的加粗，但是 strong 标签拥有强调的语义。</span><br><span class="line">对于一般显示来说，可能我们看上去没有差异，但是对于机器来说，就会有很大的不同。如果用户使用的是屏幕阅读器来访问网页的</span><br><span class="line">话，使用 strong 标签就会有明显的语调上的变化，而 b 标签则没有。如果是搜索引擎的爬虫对我们网页进行分析的话，那么它会</span><br><span class="line">依赖于 html 标签来确定上下文和各个关键字的权重，一个语义化的文档对爬虫来说是友好的，是有利于爬虫对文档内容解读的，</span><br><span class="line">从而有利于我们网站的 SEO 。从 html5 我们可以看出，标准是倾向于以语义化的方式来构建网页的，比如新增了 header 、fo</span><br><span class="line">oter 这些语义标签，删除了 big 、font 这些没有语义的标签。</span><br></pre></td></tr></table></figure><br>   详细资料可以参考：<br>   <a href="https://www.html.cn/archives/1668">《语义化的 HTML 结构到底有什么好处？》</a><br>   <a href="https://www.zhihu.com/question/20455165">《如何理解 Web 语义化？》</a><br>   <a href="https://juejin.im/post/5a9c8866f265da23741072bf#heading-5">《我的 HTML 会说话——从实用出发，谈谈 HTML 的语义化》</a></p><h2 id="b-与-strong-的区别和-i-与-em-的区别？"><a href="#b-与-strong-的区别和-i-与-em-的区别？" class="headerlink" title="b 与 strong 的区别和 i 与 em 的区别？"></a>b 与 strong 的区别和 i 与 em 的区别？</h2>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">从页面显示效果来看，被 &lt;b&gt; 和 &lt;strong&gt; 包围的文字将会被加粗，而被 &lt;i&gt; 和 &lt;em&gt; 包围的文字将以斜体的形式呈现。</span><br><span class="line"></span><br><span class="line">但是 &lt;b&gt; &lt;i&gt; 是自然样式标签，分别表示无意义的加粗，无意义的斜体，表现样式为 &#123; font-weight: bolder&#125;，仅仅表示「这</span><br><span class="line">里应该用粗体显示」或者「这里应该用斜体显示」，此两个标签在 HTML4.01 中并不被推荐使用。</span><br><span class="line"></span><br><span class="line">而 &lt;em&gt; 和 &lt;strong&gt; 是语义样式标签。 &lt;em&gt; 表示一般的强调文本，而 &lt;strong&gt; 表示比 &lt;em&gt; 语义更强的强调文本。</span><br><span class="line"></span><br><span class="line">使用阅读设备阅读网页时：&lt;strong&gt; 会重读，而 &lt;b&gt; 是展示强调内容。</span><br></pre></td></tr></table></figure><p>   详细资料可以参考：<br>   <a href="https://www.zhihu.com/question/19551271">《HTML5 中的 b/strong，i/em 有什么区别？》</a></p><h2 id="前端需要注意哪些-SEO-？"><a href="#前端需要注意哪些-SEO-？" class="headerlink" title="前端需要注意哪些 SEO ？"></a>前端需要注意哪些 SEO ？</h2>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）合理的 title、description、keywords：搜索对着三项的权重逐个减小，title 值强调重点即可，重要关键词出现不要超</span><br><span class="line">    过2次，而且要靠前，不同页面 title 要有所不同；description 把页面内容高度概括，长度合适，不可过分堆砌关键词，不</span><br><span class="line">    同页面 description 有所不同；keywords 列举出重要关键词即可。</span><br><span class="line"></span><br><span class="line">（2）语义化的 HTML 代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页。</span><br><span class="line"></span><br><span class="line">（3）重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容肯定被</span><br><span class="line">    抓取。</span><br><span class="line"> </span><br><span class="line">（4）重要内容不要用 js 输出：爬虫不会执行 js 获取内容</span><br><span class="line"></span><br><span class="line">（5）少用 iframe：搜索引擎不会抓取 iframe 中的内容</span><br><span class="line"></span><br><span class="line">（6）非装饰性图片必须加 alt</span><br><span class="line"></span><br><span class="line">（7）提高网站速度：网站速度是搜索引擎排序的一个重要指标</span><br></pre></td></tr></table></figure><h2 id="HTML5-的离线储存怎么使用，工作原理能不能解释一下？"><a href="#HTML5-的离线储存怎么使用，工作原理能不能解释一下？" class="headerlink" title="HTML5 的离线储存怎么使用，工作原理能不能解释一下？"></a>HTML5 的离线储存怎么使用，工作原理能不能解释一下？</h2>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。</span><br><span class="line"></span><br><span class="line">原理：HTML5 的离线存储是基于一个新建的 .appcache 文件的缓存机制（不是存储技术），通过这个文件上的解析清单离线存储资</span><br><span class="line">     源，这些资源就会像 cookie 一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面</span><br><span class="line">     展示。</span><br><span class="line"></span><br><span class="line">如何使用：</span><br><span class="line"></span><br><span class="line">（1）创建一个和 html 同名的 manifest 文件，然后在页面头部像下面一样加入一个 manifest 的属性。</span><br><span class="line"></span><br><span class="line">    &lt;html lang=&quot;en&quot; manifest=&quot;index.manifest&quot;&gt;</span><br><span class="line"></span><br><span class="line">（2）在如下 cache.manifest 文件的编写离线存储的资源。</span><br><span class="line">  CACHE MANIFEST</span><br><span class="line">  #v0.11</span><br><span class="line">  CACHE:</span><br><span class="line">  js/app.js</span><br><span class="line">  css/style.css</span><br><span class="line">  NETWORK:</span><br><span class="line">  resourse/logo.png</span><br><span class="line">  FALLBACK:</span><br><span class="line">  / /offline.html</span><br><span class="line"></span><br><span class="line">    CACHE: 表示需要离线存储的资源列表，由于包含 manifest 文件的页面将被自动离线存储，所以不需要把页面自身也列出</span><br><span class="line">           来。</span><br><span class="line"></span><br><span class="line">    NETWORK: 表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些</span><br><span class="line">             资源。不过，如果在 CACHE 和 NETWORK 中有一个相同的资源，那么这个资源还是会被离线存储，也就是说 C</span><br><span class="line">             ACHE 的优先级更高。</span><br><span class="line"></span><br><span class="line">    FALLBACK: 表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下</span><br><span class="line">              任何一个资源失败了，那么就去访问 offline.html 。</span><br><span class="line"></span><br><span class="line">（3）在离线状态时，操作 window.applicationCache 进行离线缓存的操作。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如何更新缓存：</span><br><span class="line"></span><br><span class="line">（1）更新 manifest 文件</span><br><span class="line">（2）通过 javascript 操作</span><br><span class="line">（3）清除浏览器缓存</span><br><span class="line"></span><br><span class="line">注意事项：</span><br><span class="line"></span><br><span class="line">（1）浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点 5MB）。</span><br><span class="line">（2）如果 manifest 文件，或者内部列举的某一个文件不能正常下载，整个更新过程都将失败，浏览器继续全部使用老的缓存。</span><br><span class="line">（3）引用 manifest 的 html 必须与 manifest 文件同源，在同一个域下。</span><br><span class="line">（4）FALLBACK 中的资源必须和 manifest 文件同源。</span><br><span class="line">（5）当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。</span><br><span class="line">（6）站点中的其他页面即使没有设置 manifest 属性，请求的资源如果在缓存中也从缓存中访问。</span><br><span class="line">（7）当 manifest 文件发生改变时，资源请求本身也会触发更新。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>   详细的使用可以参考：<br>   <a href="https://yanhaijing.com/html/2014/12/28/html5-manifest/">《HTML5 离线缓存-manifest 简介》</a><br>   <a href="https://segmentfault.com/a/1190000000732617">《有趣的 HTML5：离线存储》</a></p><h2 id="浏览器是怎么对-HTML5-的离线储存资源进行管理和加载的呢？"><a href="#浏览器是怎么对-HTML5-的离线储存资源进行管理和加载的呢？" class="headerlink" title="浏览器是怎么对 HTML5 的离线储存资源进行管理和加载的呢？"></a>浏览器是怎么对 HTML5 的离线储存资源进行管理和加载的呢？</h2>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问 app ，那么浏览器</span><br><span class="line">就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过 app 并且资源已经离线存储了，那么浏览器</span><br><span class="line">就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做</span><br><span class="line">任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。</span><br><span class="line"></span><br><span class="line">离线的情况下，浏览器就直接使用离线存储的资源。</span><br></pre></td></tr></table></figure><h2 id="常见的浏览器端的存储技术有哪些？"><a href="#常见的浏览器端的存储技术有哪些？" class="headerlink" title="常见的浏览器端的存储技术有哪些？"></a>常见的浏览器端的存储技术有哪些？</h2>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">浏览器常见的存储技术有 cookie、localStorage 和 sessionStorage。</span><br><span class="line"></span><br><span class="line">还有两种存储技术用于大规模数据存储，webSQL（已被废除）和 indexDB。</span><br><span class="line"></span><br><span class="line">IE 支持 userData 存储数据，但是基本很少使用到，除非有很强的浏览器兼容需求。</span><br></pre></td></tr></table></figure><p>   详细的资料可以参考：<br>   <a href="https://segmentfault.com/a/1190000012578794#articleHeader0">《很全很全的前端本地存储讲解》</a></p><h2 id="请描述一下-cookies，sessionStorage-和-localStorage-的区别？"><a href="#请描述一下-cookies，sessionStorage-和-localStorage-的区别？" class="headerlink" title="请描述一下 cookies，sessionStorage 和 localStorage 的区别？"></a>请描述一下 cookies，sessionStorage 和 localStorage 的区别？</h2><p>   相关资料：<br>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SessionStorage， LocalStorage， Cookie 这三者都可以被用来在浏览器端存储数据，而且都是字符串类型的键值对。区别</span><br><span class="line">在于前两者属于 HTML5 WebStorage，创建它们的目的便于客户端存储数据。而 cookie 是网站为了标示用户身份而储存在用户</span><br><span class="line">本地终端上的数据（通常经过加密）。cookie 数据始终在同源（协议、主机、端口相同）的 http 请求中携带（即使不需要），会</span><br><span class="line">在浏览器和服务器间来回传递。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">存储大小：</span><br><span class="line">  cookie 数据大小不能超过4 k 。</span><br><span class="line">  sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大。</span><br><span class="line"></span><br><span class="line">有期时间：</span><br><span class="line">  localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据。</span><br><span class="line">  sessionStorage  数据在页面会话结束时会被清除。页面会话在浏览器打开期间一直保持，并且重新加载或恢复页面仍会</span><br><span class="line">                    保持原来的页面会话。在新标签或窗口打开一个页面时会在顶级浏览上下文中初始化一个新的会话。</span><br><span class="line">  cookie          设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭。</span><br><span class="line"> </span><br><span class="line">作用域：</span><br><span class="line">    sessionStorage  只在同源的同窗口（或标签页）中共享数据，也就是只在当前会话中共享。</span><br><span class="line">    localStorage    在所有同源窗口中都是共享的。</span><br><span class="line">    cookie          在所有同源窗口中都是共享的。</span><br></pre></td></tr></table></figure></p><p>   回答：<br>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">浏览器端常用的存储技术是 cookie 、localStorage 和 sessionStorage。</span><br><span class="line"></span><br><span class="line">cookie 其实最开始是服务器端用于记录用户状态的一种方式，由服务器设置，在客户端存储，然后每次发起同源请求时，发送给服</span><br><span class="line">务器端。cookie 最多能存储 4 k 数据，它的生存时间由 expires 属性指定，并且 cookie 只能被同源的页面访问共享。</span><br><span class="line"></span><br><span class="line">sessionStorage 是 html5 提供的一种浏览器本地存储的方法，它借鉴了服务器端 session 的概念，代表的是一次会话中所保</span><br><span class="line">存的数据。它一般能够存储 5M 或者更大的数据，它在当前窗口关闭后就失效了，并且 sessionStorage 只能被同一个窗口的同源</span><br><span class="line">页面所访问共享。</span><br><span class="line"></span><br><span class="line">localStorage 也是 html5 提供的一种浏览器本地存储的方法，它一般也能够存储 5M 或者更大的数据。它和 sessionStorage </span><br><span class="line">不同的是，除非手动删除它，否则它不会失效，并且 localStorage 也只能被同源页面所访问共享。</span><br><span class="line"></span><br><span class="line">上面几种方式都是存储少量数据的时候的存储方式，当我们需要在本地存储大量数据的时候，我们可以使用浏览器的 indexDB 这是浏</span><br><span class="line">览器提供的一种本地的数据库存储机制。它不是关系型数据库，它内部采用对象仓库的形式存储数据，它更接近 NoSQL 数据库。</span><br></pre></td></tr></table></figure></p><p>   详细的资料可以参考：<br>   <a href="https://segmentfault.com/a/1190000017423117">《请描述一下 cookies，sessionStorage 和 localStorage 的区别？》</a><br>   <a href="http://www.ruanyifeng.com/blog/2018/07/indexeddb.html">《浏览器数据库 IndexedDB 入门教程》</a></p><h2 id="iframe-有那些缺点？"><a href="#iframe-有那些缺点？" class="headerlink" title="iframe 有那些缺点？"></a>iframe 有那些缺点？</h2>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。</span><br><span class="line"></span><br><span class="line">主要缺点有：</span><br><span class="line"></span><br><span class="line">（1） iframe 会阻塞主页面的 onload 事件。window 的 onload 事件需要在所有 iframe 加载完毕后（包含里面的元素）才</span><br><span class="line">     会触发。在 Safari 和 Chrome 里，通过 JavaScript 动态设置 iframe 的 src 可以避免这种阻塞情况。</span><br><span class="line">（2） 搜索引擎的检索程序无法解读这种页面，不利于网页的 SEO 。</span><br><span class="line">（3） iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。</span><br><span class="line">（4） 浏览器的后退按钮失效。</span><br><span class="line">（5） 小型的移动设备无法完全显示框架。</span><br></pre></td></tr></table></figure><p>   详细的资料可以参考：<br>   <a href="https://blog.csdn.net/yintianqin/article/details/72625785">《使用 iframe 的优缺点》</a><br>   <a href="https://segmentfault.com/a/1190000009891683">《iframe 简单探索以及 iframe 跨域处理》</a></p><h2 id="Label-的作用是什么？是怎么用的？"><a href="#Label-的作用是什么？是怎么用的？" class="headerlink" title="Label 的作用是什么？是怎么用的？"></a>Label 的作用是什么？是怎么用的？</h2>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">label 标签来定义表单控制间的关系，当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。</span><br><span class="line"></span><br><span class="line">&lt;label for=&quot;Name&quot;&gt;Number:&lt;/label&gt;</span><br><span class="line">&lt;input type=“text“ name=&quot;Name&quot; id=&quot;Name&quot;/&gt;</span><br></pre></td></tr></table></figure><h2 id="HTML5-的-form-的自动完成功能是什么？"><a href="#HTML5-的-form-的自动完成功能是什么？" class="headerlink" title="HTML5 的 form 的自动完成功能是什么？"></a>HTML5 的 form 的自动完成功能是什么？</h2>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">autocomplete 属性规定输入字段是否应该启用自动完成功能。默认为启用，设置为 autocomplete=off 可以关闭该功能。</span><br><span class="line"></span><br><span class="line">自动完成允许浏览器预测对字段的输入。当用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项。</span><br><span class="line"></span><br><span class="line">autocomplete 属性适用于 &lt;form&gt;，以及下面的 &lt;input&gt; 类型：text, search, url, telephone, email, password, </span><br><span class="line">datepickers, range 以及 color。</span><br></pre></td></tr></table></figure><h2 id="如何实现浏览器内多个标签页之间的通信"><a href="#如何实现浏览器内多个标签页之间的通信" class="headerlink" title="如何实现浏览器内多个标签页之间的通信?"></a>如何实现浏览器内多个标签页之间的通信?</h2><p>   相关资料：<br>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）使用 WebSocket，通信的标签页连接同一个服务器，发送消息到服务器后，服务器推送消息给所有连接的客户端。</span><br><span class="line"></span><br><span class="line">（2）使用 SharedWorker （只在 chrome 浏览器实现了），两个页面共享同一个线程，通过向线程发送数据和接收数据来实现标</span><br><span class="line">    签页之间的双向通行。</span><br><span class="line"></span><br><span class="line">（3）可以调用 localStorage、cookies 等本地存储方式，localStorge 另一个浏览上下文里被添加、修改或删除时，它都会触</span><br><span class="line">    发一个 storage 事件，我们通过监听 storage 事件，控制它的值来进行页面信息通信；</span><br><span class="line"></span><br><span class="line">（4）如果我们能够获得对应标签页的引用，通过 postMessage 方法也是可以实现多个标签页通信的。</span><br></pre></td></tr></table></figure></p><p>   回答：<br>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者，</span><br><span class="line">让标签页和中介者进行通信，然后让这个中介者来进行消息的转发。</span><br><span class="line"></span><br><span class="line">第一种实现的方式是使用 websocket 协议，因为 websocket 协议可以实现服务器推送，所以服务器就可以用来当做这个中介者。</span><br><span class="line">标签页通过向服务器发送数据，然后由服务器向其他标签页推送转发。</span><br><span class="line"></span><br><span class="line">第二种是使用 ShareWorker 的方式，shareWorker 会在页面存在的生命周期内创建一个唯一的线程，并且开启多个页面也只会使</span><br><span class="line">用同一个线程。这个时候共享线程就可以充当中介者的角色。标签页间通过共享一个线程，然后通过这个共享的线程来实现数据的交</span><br><span class="line">换。</span><br><span class="line"></span><br><span class="line">第三种方式是使用 localStorage 的方式，我们可以在一个标签页对 localStorage 的变化事件进行监听，然后当另一个标签页</span><br><span class="line">修改数据的时候，我们就可以通过这个监听事件来获取到数据。这个时候 localStorage 对象就是充当的中介者的角色。</span><br><span class="line"></span><br><span class="line">还有一种方式是使用 postMessage 方法，如果我们能够获得对应标签页的引用，我们就可以使用 postMessage 方法，进行通信。</span><br></pre></td></tr></table></figure><br>   详细的资料可以参考：</p><p>   <a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html">《WebSocket 教程》</a><br>   <a href="https://www.cnblogs.com/chyingp/p/websocket-deep-in.html">《WebSocket 协议：5分钟从入门到精通》</a><br>   <a href="https://segmentfault.com/a/1190000011538416">《WebSocket 学习（一）——基于 socket.io 实现简单多人聊天室》</a><br>   <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API">《使用 Web Storage API》</a><br>   <a href="https://www.zhuwenlong.com/blog/article/590ea64fe55f0f385f9a12e5">《JavaScript 的多线程，Worker 和 SharedWorker》</a><br>   <a href="https://juejin.im/post/5acdba01f265da23826e5633#heading-1">《实现多个标签页之间通信的几种方法》</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端面试 </category>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML高频面试题-01</title>
      <link href="/47977/"/>
      <url>/47977/</url>
      
        <content type="html"><![CDATA[<h2 id="DOCTYPE-的作用是什么？"><a href="#DOCTYPE-的作用是什么？" class="headerlink" title="DOCTYPE 的作用是什么？"></a>DOCTYPE 的作用是什么？</h2><blockquote><p><code>&lt;!DOCTYPE&gt;</code>  声明一般位于文档的第一行，它的作用主要是告诉浏览器以什么样的模式来解析文档。一般指定了之后会以标准模式来<br>   进行文档解析，否则就以兼容模式进行解析。在标准模式下，浏览器的解析规则都是按照最新的标准进行解析的。而在兼容模式下，浏<br>   览器会以向后兼容的方式来模拟老式浏览器的行为，以保证一些老的网站的正确访问。<br>   *** 在 html5 之后不再需要指定 DTD 文档，因为 html5 以前的 html 文档都是基于 SGML 的，所以需要通过指定 DTD 来定义文<br>   档中允许的属性以及一些规则。而 html5 不再基于 SGML 了，所以不再需要使用 DTD</p></blockquote><h2 id="标准模式与兼容模式各有什么区别？"><a href="#标准模式与兼容模式各有什么区别？" class="headerlink" title="标准模式与兼容模式各有什么区别？"></a>标准模式与兼容模式各有什么区别？</h2><blockquote><p>标准模式的渲染方式和 JS 引擎的解析方式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示模拟老式浏览器的行为以防止站点无法工作。</p></blockquote><h2 id="HTML5-为什么只需要写-lt-DOCTYPE-HTML-gt-，而不需要引入-DTD？"><a href="#HTML5-为什么只需要写-lt-DOCTYPE-HTML-gt-，而不需要引入-DTD？" class="headerlink" title="HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;，而不需要引入 DTD？"></a>HTML5 为什么只需要写 <code>&lt;!DOCTYPE HTML&gt;</code>，而不需要引入 DTD？</h2><blockquote><p>HTML5 不基于 SGML，因此不需要对 DTD 进行引用，但是需要 DOCTYPE 来规范浏览器的行为（让浏览器按照它们应该的方式来运行）。而 HTML4.01 基于 SGML ，所以需要对 DTD 进行引用，才能告知浏览器文档所使用的文档类型。</p></blockquote><h2 id="SGML-、-HTML-、XML-和-XHTML-的区别？"><a href="#SGML-、-HTML-、XML-和-XHTML-的区别？" class="headerlink" title="SGML 、 HTML 、XML 和 XHTML 的区别？"></a>SGML 、 HTML 、XML 和 XHTML 的区别？</h2><blockquote><p>(1) SGML 是标准通用标记语言，是一种定义电子文档结构和描述其内容的国际标准语言，是所有电子文档标记语言的起源<br>   (2) HTML 是超文本标记语言，主要是用于规定怎么显示网页。<br>   (3)  XML 是可扩展标记语言是未来网页语言的发展方向，XML 和 HTML 的最大区别就在于 XML 的标签是可以自己创建的，数量无限多而 HTML 的标签都是固定的而且数量有限。<br>   (4) XHTML 也是现在基本上所有网页都在用的标记语言，他其实和 HTML 没什么本质的区别，标签都一样，用法也都一样，就是比 HTML更严格，比如标签必须都用小写，标签都必须有闭合标签等。</p></blockquote><h2 id="DTD-介绍"><a href="#DTD-介绍" class="headerlink" title="DTD 介绍"></a>DTD 介绍</h2><blockquote><p>DTD（ Document Type Definition 文档类型定义）是一组机器可读的规则，它们定义 XML 或 HTML 的特定版本中所有允许元素及它们的属性和层次关系的定义。在解析网页时，浏览器将使用这些规则检查页面的有效性并且采取相应的措施。DTD 是对 HTML 文档的声明，还会影响浏览器的渲染模式（工作模式）。</p></blockquote><h2 id="行内元素定义"><a href="#行内元素定义" class="headerlink" title="行内元素定义"></a>行内元素定义</h2><blockquote><p>HTML4 中，元素被分成两大类: inline （内联元素）与 block（块级元素）。一个行内元素只占据它对应标签的边框所包含的空<br>   间。常见的行内元素有 a b span img strong sub sup button input label select textarea</p></blockquote><h2 id="块级元素定义"><a href="#块级元素定义" class="headerlink" title="块级元素定义"></a>块级元素定义</h2><blockquote><p>块级元素占据其父元素（容器）的整个宽度，因此创建了一个“块”。<br>   常见的块级元素有  <code>div</code> <code>ul</code> <code>ol</code> <code>li</code> <code>dl</code> <code>dt</code> <code>dd</code> <code>h1</code> <code>h2</code>…</p></blockquote><h2 id="行内元素与块级元素的区别？"><a href="#行内元素与块级元素的区别？" class="headerlink" title="行内元素与块级元素的区别？"></a>行内元素与块级元素的区别？</h2><blockquote><p>HTML4中，元素被分成两大类：inline （内联元素）与 block （块级元素）。<br>   （1） 格式上，默认情况下，行内元素不会以新行开始，而块级元素会新起一行。<br>   （2） 内容上，默认情况下，行内元素只能包含文本和其他行内元素。而块级元素可以包含行内元素和其他块级元素。<br>   （3） 行内元素与块级元素属性的不同，主要是盒模型属性上：行内元素设置 width 无效，height 无效（可以设置 line-height）设置 margin 和 padding 的上下不会对其他元素产生影响。</p></blockquote><h2 id="HTML5-元素的分类"><a href="#HTML5-元素的分类" class="headerlink" title="HTML5 元素的分类"></a>HTML5 元素的分类</h2><blockquote><p>HTML4中，元素被分成两大类: inline（内联元素）与 block（块级元素）。但在实际的开发过程中，因为页面表现的需要，前端工程师经常把 inline 元素的 display 值设定为 block （比如 a 标签），也经常把 block 元素的 display 值设定为<br>   inline 之后更是出现了 inline-block 这一对外呈现 inline 对内呈现 block 的属性。因此，简单地把 HTML 元素划分为<br>   inline 与 block 已经不再符合实际需求。<br>   HTML5中，元素主要分为7类：Metadata Flow Sectioning Heading Phrasing Embedded Interactive</p></blockquote><h2 id="空元素定义"><a href="#空元素定义" class="headerlink" title="空元素定义"></a>空元素定义</h2><blockquote><p>标签内没有内容的 HTML 标签被称为空元素。空元素是在开始标签中关闭的。常见的空元素有：<code>br</code> <code>hr</code> <code>img</code> <code>input</code> <code>link</code> <code>meta</code></p></blockquote><h2 id="link-标签定义"><a href="#link-标签定义" class="headerlink" title="link 标签定义"></a>link 标签定义</h2><blockquote><p>link 标签定义文档与外部资源的关系。link 元素是空元素，它仅包含属性。 此元素只能存在于 head 部分，不过它可出现任何次数。link 标签中的 rel 属性定义了当前文档与被链接文档之间的关系。常见的 stylesheet 指的是定义一个外部加载的样式表。</p></blockquote><h2 id="页面导入样式时，使用-link-和-import-有什么区别？"><a href="#页面导入样式时，使用-link-和-import-有什么区别？" class="headerlink" title="页面导入样式时，使用 link 和 @import 有什么区别？"></a>页面导入样式时，使用 link 和 @import 有什么区别？</h2><blockquote><p>（1）从属关系区别。 @import 是 CSS 提供的语法规则，只有导入样式表的作用；link 是 HTML 提供的标签，不仅可以加<br>        载 CSS 文件，还可以定义 <code>RSS</code>、<code>rel</code> 连接属性、引入网站图标等。<br>   （2）加载顺序区别。加载页面时，link 标签引入的 CSS 被同时加载；@import 引入的 CSS 将在页面加载完毕后被加载。<br>   （3）兼容性区别。@import 是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link 标签作为 HTML 元素，不存在兼容<br>        性问题。<br>   （4）DOM 可控性区别。可以通过 JS 操作 DOM ，插入 link 标签来改变样式；由于 DOM 方法是基于文档的，无法使用 <code>@import</code> 的方式插入样式。</p></blockquote><h2 id="介绍一下你对浏览器内核的理解？"><a href="#介绍一下你对浏览器内核的理解？" class="headerlink" title="介绍一下你对浏览器内核的理解？"></a>介绍一下你对浏览器内核的理解？</h2><blockquote><p>主要分成两部分：渲染引擎和 JS 引擎。<br>   (1) 渲染引擎的职责就是渲染，即在浏览器窗口中显示所请求的内容。默认情况下，渲染引擎可以显示 <code>html、xml</code> 文档及图片，它也<br>   可以借助插件（一种浏览器扩展）显示其他类型数据，例如使用 PDF 阅读器插件，可以显示 PDF 格式。<br>   (2) JS 引擎：解析和执行 <code>javascript</code> 来实现网页的动态效果。<br>   最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。</p></blockquote><h2 id="浏览器的渲染原理？"><a href="#浏览器的渲染原理？" class="headerlink" title="浏览器的渲染原理？"></a>浏览器的渲染原理？</h2><blockquote><p>（1）首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。<br>    （2）然后对 CSS 进行解析，生成 CSSOM 规则树。<br>    （3）根据 <code>DOM</code> 树和 <code>CSSOM</code> 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形,渲染对象和 <code>DOM</code> 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM<br>    元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。<br>    （4）当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。<br>    （5）布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的<code>html</code> 都解析完成之后再去构建和布局 <code>render</code> 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。详细资料可以参考：<br>   <a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc7207f265da613c09425d">《浏览器渲染原理》</a><br>   <a href="https://coolshell.cn/articles/9666.html">《浏览器的渲染原理简介》</a><br>   <a href="https://kb.cnblogs.com/page/129756/">《前端必读：浏览器内部工作原理》</a><br>   <a href="https://blog.fundebug.com/2019/01/03/understand-browser-rendering/">《深入浅出浏览器渲染原理》</a></p></blockquote><h2 id="渲染过程中遇到-JS-文件怎么处理？（浏览器解析过程）"><a href="#渲染过程中遇到-JS-文件怎么处理？（浏览器解析过程）" class="headerlink" title="渲染过程中遇到 JS 文件怎么处理？（浏览器解析过程）"></a>渲染过程中遇到 JS 文件怎么处理？（浏览器解析过程）</h2><blockquote><p><code>JavaScript</code> 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么它会暂停文档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。</p></blockquote><h2 id="async-和-defer-的作用是什么？有什么区别？（浏览器解析过程）"><a href="#async-和-defer-的作用是什么？有什么区别？（浏览器解析过程）" class="headerlink" title="async 和 defer 的作用是什么？有什么区别？（浏览器解析过程）"></a>async 和 defer 的作用是什么？有什么区别？（浏览器解析过程）</h2><blockquote><p>(1）脚本没有 <code>defer</code> 或 <code>async</code>，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并行。<br>   (2）defer 属性表示延迟执行引入的 <code>JavaScript</code>，即这段<code>JavaScript</code> 加载时 <code>HTML</code> 并未停止解析，这两个过程是并行的.当整个 document 解析完毕后再执行脚本文件，在 <code>DOMContentLoaded</code> 事件触发之前完成。多个脚本按顺序执行。<br>   (3）async 属性表示异步执行引入的 <code>JavaScript，与</code> defer 的区别在于，如果已经加载好，就会开始执行，也就是说它的执行仍然会阻塞文档的解析，只是它的加载过程不会阻塞。多个脚本的执行顺序无法保证。<br>   详细资料可以参考：<br>   <a href="https://segmentfault.com/q/1010000000640869">《defer 和 async 的区别》</a></p></blockquote><h2 id="什么是文档的预解析？（浏览器解析过程）"><a href="#什么是文档的预解析？（浏览器解析过程）" class="headerlink" title="什么是文档的预解析？（浏览器解析过程）"></a>什么是文档的预解析？（浏览器解析过程）</h2><blockquote><p><code>Webkit</code> 和 <code>Firefox</code> 都做了这个优化，当执行 <code>JavaScript</code> 脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变 DOM 树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端面试 </category>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS高频面试题</title>
      <link href="/37435/"/>
      <url>/37435/</url>
      
        <content type="html"><![CDATA[<h2 id="描述下-“reset”-CSS-文件的作用和使用它的好处"><a href="#描述下-“reset”-CSS-文件的作用和使用它的好处" class="headerlink" title="描述下 “reset” CSS 文件的作用和使用它的好处?"></a>描述下 “reset” CSS 文件的作用和使用它的好处?</h2><p>  A：<br>    - 作用以及好处：因为各个浏览器默认对CSS的渲染有差异，”reset” CSS 通过重新定义标签样式，对浏览器进行默认样式“清零”重置，样式保持一致。<br>    - 不足:<br>      + css文件大小增加；<br>      + 许多样式本身就需要重置，多此一举；<br>      + 增加浏览器对CSS 的渲染。</p><pre><code>可以阅读以下文章增强了解：- [CSS reset的重新审视 – 避免样式重置](http://www.zhangxinxu.com/wordpress/2010/04/css-reset%E7%9A%84%E9%87%8D%E6%96%B0%E5%AE%A1%E8%A7%86-%E9%81%BF%E5%85%8D%E6%A0%B7%E5%BC%8F%E9%87%8D%E7%BD%AE/)- [常见标签的默认属性值及相互作用——关于CSS reset的思考](http://www.cnblogs.com/dolphinx/p/3509515.html)- [reset.css](http://baike.baidu.com/view/5186496.htm)- [前端面试问题](http://handyxuefeng.blog.163.com/blog/static/454521722013111714040259/)</code></pre><h2 id="Q-解释下浮动和它的工作原理？"><a href="#Q-解释下浮动和它的工作原理？" class="headerlink" title="Q: 解释下浮动和它的工作原理？"></a>Q: 解释下浮动和它的工作原理？</h2><p>  A: 浮动出现的最开始出现的意义是用来让文字环绕图片而已。<code>float</code>可以自动包裹元素。<code>float</code>会导致高度塌陷。<code>float</code>为什么会导致高度塌陷：元素含有浮动属性 –&gt; 破坏<code>inline box</code> –&gt; 破坏<code>line box</code>高度 –&gt; 没有高度 –&gt; 塌陷。什么时候会塌陷：当标签里面的元素只要样子没有实际高度时会塌陷。浮动会脱离文档流。产生自己的块级格式化上下文。</p><pre><code>可以阅读以下文章增加理解：- [CSS float浮动的深入研究、详解及拓展(一)](http://www.zhangxinxu.com/wordpress/2010/01/css-float%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6%E3%80%81%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%8B%93%E5%B1%95%E4%B8%80/)- [CSS float浮动的深入研究、详解及拓展(二)](http://www.zhangxinxu.com/wordpress/2010/01/css-float%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6%E3%80%81%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%8B%93%E5%B1%95%E4%BA%8C/)- [那些年我们一起清除过的浮动](http://www.iyunlu.com/view/css-xhtml/55.html)- 《CSS权威指南》</code></pre><h2 id="列举不同的清除浮动的技巧，并指出它们各自适用的使用场景。"><a href="#列举不同的清除浮动的技巧，并指出它们各自适用的使用场景。" class="headerlink" title="列举不同的清除浮动的技巧，并指出它们各自适用的使用场景。"></a>列举不同的清除浮动的技巧，并指出它们各自适用的使用场景。</h2><ul><li><p>直接把<code>&lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt;</code>放到当作最后一个子标签放到父标签那儿，此方法兼容性强，使用方便，但是浪费了一个标签，而且只能使用一次，而且有时候如果不注意中间多了个空格会产生一段空白高度。</p><ul><li>优点：通俗易懂，容易掌握；</li><li>缺点：可以想象通过此方法，会添加多少无意义的空标签，有违结构与表现的分离，在后期维护中将是噩梦。</li></ul></li><li><p>如下:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.clearfix&#123;overflow:hidden; zoom:1;&#125;</span><br></pre></td></tr></table></figure><p>此方法优点在于代码简洁，涵盖所有浏览器，可是对于<code>overflow:hidden;</code>要是里面的元素要是想来个<code>margin</code>负值定位或是负的绝对定位，岂不是直接被裁掉了，所以此方法是有不小的局限性的。</p><ul><li>优点：不存在结构和语义化问题，代码量极少；</li><li>缺点：内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素。</li></ul></li><li><p>如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.fix&#123;zoom:1;&#125;</span><br><span class="line">.fix:after&#123;</span><br><span class="line">    display:block;</span><br><span class="line">    content:&#x27;.&#x27;;</span><br><span class="line">    clear:both;</span><br><span class="line">    line-height:0;</span><br><span class="line">    visibility:hidden;&#125;</span><br></pre></td></tr></table></figure><p><code>line-height:0</code>写成<code>height:0</code>也是可以的。不会影响任何其他样式，通用性强，覆盖面广，我很推荐哦。</p></li><li><p>父元素也浮动：</p><ul><li>优点：不存在结构和语义化问题，代码量极少</li><li>缺点：使得与父元素相邻的元素的布局会受到影响，不可能一直浮动到body，不推荐使用</li></ul></li></ul><p>  总结：<br>    + 其一，通过在浮动元素的末尾添加一个空元素，设置 <code>clear：both</code>属性，<code>after</code>伪元素其实也是通过 <code>content</code> 在元素的后面生成了内容为一个点的块级元素；<br>    + 其二，通过设置父元素 <code>overflow</code> 或者<code>display：table</code> 属性来闭合浮动，这里的原理涉及到BFC，不再赘述。</p><p>   同样请参考上一题给出的参考文章进行阅读加以理解。</p><h2 id="Q-解释下-CSS-sprites，以及你要如何在页面或网站中使用它"><a href="#Q-解释下-CSS-sprites，以及你要如何在页面或网站中使用它" class="headerlink" title="Q: 解释下 CSS sprites，以及你要如何在页面或网站中使用它?"></a>Q: 解释下 CSS sprites，以及你要如何在页面或网站中使用它?</h2><p>  A: CSS Sprites就是把网页中一些小图片整合到一张图片文件中，再利用CSS的<code>background-image</code>，<code>background- repeat</code>，<code>background-position</code>的组合进行背景定位，<code>background-position</code>可以用数字能精确的定位出背景图片的位置。可以减少http请求。</p><h2 id="Q-你最喜欢的图片替换方法是什么，你如何选择使用"><a href="#Q-你最喜欢的图片替换方法是什么，你如何选择使用" class="headerlink" title="Q: 你最喜欢的图片替换方法是什么，你如何选择使用?"></a>Q: 你最喜欢的图片替换方法是什么，你如何选择使用?</h2><p>  A:<br>    - 一些图标是使用before和after伪元素;<br>    - 还有一些使用iconfont;<br>    - 使用sprite图;<br>    - 用背景图片代替图片。</p><pre><code>举个栗子：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;h1 class=&quot;nir&quot;&gt;[content]&lt;/h1&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.nir &#123;</span><br><span class="line">   height: 100px; /* height of replacement image */</span><br><span class="line">   padding: 0;</span><br><span class="line">   margin: 0;</span><br><span class="line">   overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.nir:before &#123;</span><br><span class="line">     content: url(image.gif);</span><br><span class="line">     display: block;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>详细可阅读：[CSS image replacement with pseudo-elements](http://nicolasgallagher.com/css-image-replacement-with-pseudo-elements/)</code></pre><h2 id="讨论CSS-hacks，条件引用或者其他。"><a href="#讨论CSS-hacks，条件引用或者其他。" class="headerlink" title="讨论CSS hacks，条件引用或者其他。"></a>讨论CSS hacks，条件引用或者其他。</h2><p>  A: CSS主要由三种方法：</p><pre><code>- 属性前缀法(即类内部Hack)：例如 IE6能识别下划线&quot;\_&quot;和星号&quot; \* &quot;，IE7能识别星号&quot; \* &quot;，但不能识别下划线&quot;\_&quot;，IE6~IE10都认识&quot;\9&quot;，但firefox前述三个都不能认识。- 选择器前缀法(即选择器Hack)：例如 IE6能识别`*html .class&#123;&#125;`，IE7能识别`*+html .class&#123;&#125;`或者`*:first-child+html .class&#123;&#125;`。- IE条件注释法(即HTML条件注释Hack)：针对所有IE(注：IE10+已经不再支持条件注释)： &lt;!--[if IE]&gt;IE浏览器显示的内容 &lt;![endif]--&gt;，针对IE6及以下版本： &lt;!--[if lt IE 6]&gt;只在IE6-显示的内容 &lt;![endif]--&gt;。这类Hack不仅对CSS生效，对写在判断语句里面的所有代码都会生效。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Css Hack&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">    #test</span><br><span class="line">    &#123;</span><br><span class="line">        width:300px;</span><br><span class="line">        height:300px;</span><br><span class="line"></span><br><span class="line">        background-color:blue;      /*firefox*/</span><br><span class="line">        background-color:red\9;      /*all ie*/</span><br><span class="line">        background-color:yellow\0;    /*ie8*/</span><br><span class="line">        +background-color:pink;        /*ie7*/</span><br><span class="line">        _background-color:orange;       /*ie6*/</span><br><span class="line">    &#125;</span><br><span class="line">    :root #test &#123; background-color:purple\9; &#125;  /*ie9*/</span><br><span class="line">    @media all and (min-width:0px)&#123; #test &#123;background-color:black\0;&#125; &#125;  /*opera*/</span><br><span class="line">    @media screen and (-webkit-min-device-pixel-ratio:0)&#123; #test &#123;background-color:gray;&#125; &#125;  /*chrome and safari*/</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;test&quot;&gt;test&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></code></pre><p>  想要更多的了解CSS hack 方面的知识可以参考：</p><pre><code>- [史上最全的CSS hack方式一览](http://blog.csdn.net/freshlover/article/details/12132801)- [史上最全的css hack](http://www.cnblogs.com/wuqiang/archive/2011/08/23/2150240.html)</code></pre><h2 id="Q-如何为有功能限制的浏览器提供网页？"><a href="#Q-如何为有功能限制的浏览器提供网页？" class="headerlink" title="Q: 如何为有功能限制的浏览器提供网页？"></a>Q: 如何为有功能限制的浏览器提供网页？</h2><ul><li>Q: 你会使用哪些技术和处理方法？</li></ul><p>   A: 功能限制的浏览器，比如 IE 低版本、手机浏览器、奇葩国内浏览器，会在很多功能上不符合 Web 标准，而应对的方式有这么几种：</p><pre><code>- 只提供符合 Web 标准的页面；- 提供另一个符合那些浏览器标准的页面(例如说移动端一套css,电脑端一套css);- 兼容：这里有两种思路，一个是渐进增强，一个优雅降级。  渐进增强的思路就是提供一个可用的原型，后来再为高级浏览器提供优化。优雅降级的思路是根据高级浏览器提供一个版本，然后有功能限制的浏览器只需要一个刚好能用的版本。当然，工作中的标准都是尽量满足设计，如果不能满足的话就尽量贴近，不得已（性能之类的问题）才会砍掉某个浏览器版本上的需求。相关技术:- Media Query- CSS hack- 条件判断 `&lt;!--[if !IE]&gt;&lt;!--&gt;除IE外都可识别 &lt;!--&lt;![endif]--&gt;`</code></pre><h2 id="有哪些的隐藏内容的方法（如果同时还要保证屏幕阅读器可用呢？）"><a href="#有哪些的隐藏内容的方法（如果同时还要保证屏幕阅读器可用呢？）" class="headerlink" title="有哪些的隐藏内容的方法（如果同时还要保证屏幕阅读器可用呢？）"></a>有哪些的隐藏内容的方法（如果同时还要保证屏幕阅读器可用呢？）</h2><p>  A: <code>display:none</code>看不见也摸不着，屏幕阅读器更会忽略其内容；而<code>visibility:hidden</code>虽然看得见但是摸不着，占据了一定的物理空间，屏幕阅读器也会忽略。如果想要在读屏设备中让这些内容可见。解决方案的基本思路都是将这些内容放到屏幕、视线意外的地方，或者就是将大小设置成 0。比如 <code>text-indent: -9999em;</code>、<code>overflow: hidden;</code>、<code>height: 0</code>。</p><pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.texthidden &#123;</span><br><span class="line">  display:block;/*统一转化为块级元素*/</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  width: 0;</span><br><span class="line">  height: 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></code></pre><p>  更详细的方法可以参考这篇文章<a href="http://snook.ca/archives/html_and_css/hiding-content-for-accessibility">HIDING CONTENT FOR ACCESSIBILITY</a></p><p>  不过既然这是了读屏而优化的，那么可以用 media query 来完成，media speech 用于语音输出的读屏设备。<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@media speech &#123;</span><br><span class="line">    /* media-specify rules */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  以上转自<a href="http://witcher42.github.io/2014/06/06/what-are-the-different-ways-to-visually-hide-content-and-make-it-available-only-for-screen-readers/">Witcher42</a>给出的答案。</p><h2 id="你用过栅格系统吗？如果使用过，你最喜欢哪种？"><a href="#你用过栅格系统吗？如果使用过，你最喜欢哪种？" class="headerlink" title="你用过栅格系统吗？如果使用过，你最喜欢哪种？"></a>你用过栅格系统吗？如果使用过，你最喜欢哪种？</h2><p>  A：使用过bootstarp。易于上手，学习成本低，还能做出比较大方美观的页面。</p><p>  可阅读<a href="http://mux.baidu.com/?p=1550">栅格系统延续美学</a>。</p><ul><li><p>Q: 你用过媒体查询，或针对移动端的布局/CSS 吗？</p><p>A:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@media screen and (min-width:600px) &#123;</span><br><span class="line">  nav &#123;</span><br><span class="line">    float: left;</span><br><span class="line">    width: 25%;</span><br><span class="line">  &#125;</span><br><span class="line">  section &#123;</span><br><span class="line">    margin-left: 25%;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media screen and (max-width:599px) &#123;</span><br><span class="line">  nav li &#123;</span><br><span class="line">    display: inline;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  可参考：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Media_queries">CSS媒体查询</a></li><li><a href="http://www.ibm.com/developerworks/cn/web/wa-cssqueries/">使用 CSS 媒体查询创建响应式网站</a><h2 id="Q-你熟悉-SVG-样式的书写吗？"><a href="#Q-你熟悉-SVG-样式的书写吗？" class="headerlink" title="Q:你熟悉 SVG 样式的书写吗？"></a>Q:你熟悉 SVG 样式的书写吗？</h2></li></ul><p>A:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot;&gt;</span><br><span class="line"> &lt;circle cx=&quot;40&quot; cy=&quot;40&quot; r=&quot;24&quot; style=&quot;stroke:#006600; fill:#00cc00&quot;/&gt;</span><br><span class="line"> &lt;text x=&quot;250&quot; y=&quot;150&quot; font-family=&quot;Verdana&quot; font-size=&quot;10px&quot; fill=&quot;blue&quot;&gt;Hello, out there&lt;/text&gt;</span><br><span class="line"> &lt;defs&gt;&lt;style type=&quot;text/css&quot;&gt; &lt;![CDATA[.sample&#123;stroke:blue;fill:#0080FF;opacity:1;&#125;]]&gt;&lt;/style&gt;&lt;/defs&gt;</span><br><span class="line"> &lt;use xlink:href=&quot;#sample1&quot; class=&quot;sample&quot;/&gt;</span><br><span class="line"> &lt;/svg&gt;</span><br></pre></td></tr></table></figure><p>教程参考: <a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial">SVG教程</a></p></li></ul><h2 id="Q-如何优化网页的打印样式？"><a href="#Q-如何优化网页的打印样式？" class="headerlink" title="Q: 如何优化网页的打印样式？"></a>Q: 如何优化网页的打印样式？</h2><p>  A:</p><p>  <code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;screen&quot; href=&quot;xxx.css&quot; /&gt;</code></p><p> 其中media指定的属性就是设备，显示器上就是screen，打印机则是print，电视是tv，投影仪是projection。</p><p> <code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;print&quot; href=&quot;yyy.css&quot; /&gt;</code></p><p> 但打印样式表也应有些注意事项：</p><p>  1 打印样式表中最好不要用背景图片，因为打印机不能打印CSS中的背景。如要显示图片，请使用html插入到页面中。<br>  2 最好不要使用像素作为单位，因为打印样式表要打印出来的会是实物，所以建议使用pt和cm。<br>  3 隐藏掉不必要的内容。（<code>@print div&#123;display:none;&#125;</code>）<br>  4 打印样式表中最好少用浮动属性，因为它们会消失。<br> 如果想要知道打印样式表的效果如何，直接在浏览器上选择打印预览就可以了。</p><h2 id="Q-书写高效-CSS-时会有哪些问题需要考虑？"><a href="#Q-书写高效-CSS-时会有哪些问题需要考虑？" class="headerlink" title="Q: 书写高效 CSS 时会有哪些问题需要考虑？"></a>Q: 书写高效 CSS 时会有哪些问题需要考虑？</h2><p>  A:</p><ul><li>样式是：从右向左的解析一个选择器</li><li>ID最快，Universal最慢 有四种类型的key selector，解析速度由快到慢依次是：ID、class、tag和universal</li><li>不要tag-qualify （永远不要这样做 ul#main-navigation { } ID已经是唯一的，不需要Tag来标识，这样做会让选择器变慢。）</li><li>后代选择器最糟糕（换句话说，下面这个选择器是很低效的： html body ul li a { }）</li><li>想清楚你为什么这样写</li><li>CSS3的效率问题（CSS3选择器（比如 :nth-child）能够漂亮的定位我们想要的元素，又能保证我们的CSS整洁易读。但是这些神奇的选择器会浪费很多的浏览器资源。）</li><li>我们知道#ID速度是最快的，那么我们都用ID，是不是很快。但是我们不应该为了效率而牺牲可读性和可维护性`</li></ul><p>  可参考： <a href="http://blog.jobbole.com/55067/">http://blog.jobbole.com/55067/</a></p><p>  等我重写这道题答案。=。=</p><h2 id="使用-CSS-预处理器的优缺点有哪些？-SASS，Compass，Stylus，LESS"><a href="#使用-CSS-预处理器的优缺点有哪些？-SASS，Compass，Stylus，LESS" class="headerlink" title="使用 CSS 预处理器的优缺点有哪些？(SASS，Compass，Stylus，LESS)"></a>使用 CSS 预处理器的优缺点有哪些？(SASS，Compass，Stylus，LESS)</h2><h2 id="描述下你曾经使用过的-CSS-预处理的优缺点。"><a href="#描述下你曾经使用过的-CSS-预处理的优缺点。" class="headerlink" title="描述下你曾经使用过的 CSS 预处理的优缺点。"></a>描述下你曾经使用过的 CSS 预处理的优缺点。</h2><h2 id="如果设计中使用了非标准的字体，你该如何去实现？"><a href="#如果设计中使用了非标准的字体，你该如何去实现？" class="headerlink" title="如果设计中使用了非标准的字体，你该如何去实现？"></a>如果设计中使用了非标准的字体，你该如何去实现？</h2><ul><li>Webfonts (字体服务例如：Google Webfonts，Typekit 等等。)</li></ul><h2 id="解释下浏览器是如何判断元素是否匹配某个-CSS-选择器？"><a href="#解释下浏览器是如何判断元素是否匹配某个-CSS-选择器？" class="headerlink" title="解释下浏览器是如何判断元素是否匹配某个 CSS 选择器？"></a>解释下浏览器是如何判断元素是否匹配某个 CSS 选择器？</h2><h2 id="解释一下你对盒模型的理解，以及如何在-CSS-中告诉浏览器使用不同的盒模型来渲染你的布局。"><a href="#解释一下你对盒模型的理解，以及如何在-CSS-中告诉浏览器使用不同的盒模型来渲染你的布局。" class="headerlink" title="解释一下你对盒模型的理解，以及如何在 CSS 中告诉浏览器使用不同的盒模型来渲染你的布局。"></a>解释一下你对盒模型的理解，以及如何在 CSS 中告诉浏览器使用不同的盒模型来渲染你的布局。</h2><h2 id="请解释一下-box-sizing-border-box-的作用-并且说明使用它有什么好处？"><a href="#请解释一下-box-sizing-border-box-的作用-并且说明使用它有什么好处？" class="headerlink" title="请解释一下 * { box-sizing: border-box; } 的作用, 并且说明使用它有什么好处？"></a>请解释一下 <code>* &#123; box-sizing: border-box; &#125;</code> 的作用, 并且说明使用它有什么好处？</h2><h2 id="请罗列出你所知道的-display-属性的全部值"><a href="#请罗列出你所知道的-display-属性的全部值" class="headerlink" title="请罗列出你所知道的 display 属性的全部值"></a>请罗列出你所知道的 display 属性的全部值</h2><h2 id="请解释一下-inline-和-inline-block-的区别？"><a href="#请解释一下-inline-和-inline-block-的区别？" class="headerlink" title="请解释一下 inline 和 inline-block 的区别？"></a>请解释一下 inline 和 inline-block 的区别？</h2><h2 id="请解释一下-relative、fixed、absolute-和-static-元素的区别"><a href="#请解释一下-relative、fixed、absolute-和-static-元素的区别" class="headerlink" title="请解释一下 relative、fixed、absolute 和 static 元素的区别"></a>请解释一下 relative、fixed、absolute 和 static 元素的区别</h2><h2 id="你目前在使用哪一套CSS框架，或者在产品线上使用过哪一套？-Bootstrap-PureCSS-Foundation-等等"><a href="#你目前在使用哪一套CSS框架，或者在产品线上使用过哪一套？-Bootstrap-PureCSS-Foundation-等等" class="headerlink" title="你目前在使用哪一套CSS框架，或者在产品线上使用过哪一套？(Bootstrap, PureCSS, Foundation 等等)"></a>你目前在使用哪一套CSS框架，或者在产品线上使用过哪一套？(Bootstrap, PureCSS, Foundation 等等)</h2><ul><li>如果有，请问是哪一套？如果可以，你如何改善CSS框架？</li></ul><h2 id="请问你有使用过-CSS-Flexbox-或者-Grid-specs-吗？"><a href="#请问你有使用过-CSS-Flexbox-或者-Grid-specs-吗？" class="headerlink" title="请问你有使用过 CSS Flexbox 或者 Grid specs 吗？"></a>请问你有使用过 CSS Flexbox 或者 Grid specs 吗？</h2><ul><li>如果有，请问在性能和效率的方面你是怎么看的？</li></ul><h2 id="如何居中div？如何居中一个浮动元素？"><a href="#如何居中div？如何居中一个浮动元素？" class="headerlink" title="如何居中div？如何居中一个浮动元素？"></a>如何居中div？如何居中一个浮动元素？</h2>]]></content>
      
      
      <categories>
          
          <category> 前端面试 </category>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
