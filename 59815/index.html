<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>React高级实战 | 高级前端进阶</title><meta name="keywords" content="高级前端开发,JavaScript,面试,js,React,React.js,React面试题"><meta name="author" content="souldjl"><meta name="copyright" content="souldjl"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="高级前端开发,JavaScript,面试,js,React,React.js,React面试题"><meta property="og:type" content="article"><meta property="og:title" content="React高级实战"><meta property="og:url" content="https://www.daijl.cn/59815/index.html"><meta property="og:site_name" content="高级前端进阶"><meta property="og:description" content="高级前端开发,JavaScript,面试,js,React,React.js,React面试题"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.daijl.cn/img/cover/cover_6.jpg"><meta property="article:published_time" content="2022-02-08T06:21:43.000Z"><meta property="article:modified_time" content="2022-02-08T06:21:43.000Z"><meta property="article:author" content="souldjl"><meta property="article:tag" content="React"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.daijl.cn/img/cover/cover_6.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://www.daijl.cn/59815/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="T8zNWQNhDDztzYe6Y7pYKuJIY8LO45bxxN1iGheQnI"><meta name="baidu_site_verification" content="code-UTlFxDZspp"><meta name="sogou_site_verification" content="pSw0CiDaj7"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?f30a76e6d5701be25349f80c829c0a52";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:50,languages:{author:"作者: souldjl",link:"链接: ",source:"来源: 高级前端进阶",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"null",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"React高级实战",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-02-08 14:21:43"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0!==o){const a=new Date;o=864e5*o,o={value:t,expiry:a.getTime()+o};localStorage.setItem(e,JSON.stringify(o))}},get:function(e){var t=localStorage.getItem(e);if(t){t=JSON.parse(t);const o=new Date;if(!(o.getTime()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=a=>new Promise((t,e)=>{const o=document.createElement("script");o.src=a,o.async=!0,o.onerror=e,o.onload=o.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(o.onload=o.onreadystatechange=null,t())},document.head.appendChild(o)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};e=saveToLocal.get("theme");"dark"===e?activateDarkMode():"light"===e&&activateLightMode();e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/Swiper/7.4.1/swiper-bundle.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">52</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/recommend-books/"><i class="fa-fw fas fa-link"></i><span> 好书推荐</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-tools"></i><span> 实用工具</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://nav.daijl.cn/"><span>编程导航</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">高级前端进阶</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/recommend-books/"><i class="fa-fw fas fa-link"></i><span> 好书推荐</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-tools"></i><span> 实用工具</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://nav.daijl.cn/"><span>编程导航</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">React高级实战</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-02-08T06:21:43.000Z" title="发表于 2022-02-08 14:21:43">2022-02-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-02-08T06:21:43.000Z" title="更新于 2022-02-08 14:21:43">2022-02-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%A1%86%E6%9E%B6/React/">React</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">4.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>17分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="React高级实战"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/59815/#post-comment"><span class="gitalk-comment-count"></span></a></span></div></div></div><article class="post-content" id="article-container"><h2 id="7-1-TypeScripts实战上"><a href="#7-1-TypeScripts实战上" class="headerlink" title="7.1 TypeScripts实战上"></a>7.1 TypeScripts实战上</h2><p>在编程语言中如果按类型检测划分，可以分为2大类，一类是静态类型和一类是动态类型；我们所了解的java、c、c++等后端语言都是静态类型，而javascript属于动态类型；由于静态类型已经被证明符合管理复杂的应用，所以我们要学一下typescript是有必要的。</p><h3 id="7-1-1-TypeScript-设计原则"><a href="#7-1-1-TypeScript-设计原则" class="headerlink" title="7.1.1 TypeScript 设计原则"></a>7.1.1 TypeScript 设计原则</h3><ul><li>静态识别可能出现错误的代码结构。</li><li>为大型应用的代码提供结构化的机制。</li><li>不增加程序运行时开销，保留javascript运行时行为这一特性。</li><li>语言层面提供可组合性、可推理性。</li><li>语法层面保持和ECMAScript提案一致。</li><li>不增家额外的表达示层面的语法。</li></ul><h3 id="7-1-2-TypeScript-基础"><a href="#7-1-2-TypeScript-基础" class="headerlink" title="7.1.2 TypeScript 基础"></a>7.1.2 TypeScript 基础</h3><h4 id="ts的特点"><a href="#ts的特点" class="headerlink" title="ts的特点"></a>ts的特点</h4><ol><li><p>跨平台，mac和window都支持。</p></li><li><p>静态类型检测。</p></li><li><p>可选的类型检测。</p></li><li><p>面向对象</p></li><li><p>ES6特性的支持</p></li><li><p>对DOM的支持</p></li></ol><h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sting类型</span></span><br><span class="line"><span class="keyword">const</span> name:<span class="built_in">string</span>=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="comment">// number类型</span></span><br><span class="line"><span class="keyword">const</span> money:<span class="built_in">number</span>=<span class="number">100</span></span><br><span class="line"><span class="comment">// boolean类型</span></span><br><span class="line"><span class="keyword">const</span> boolShow:<span class="built_in">boolean</span>=<span class="literal">true</span></span><br><span class="line"><span class="comment">// 定义数组类型</span></span><br><span class="line"> <span class="keyword">const</span> list:<span class="built_in">number</span>[]=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"> <span class="keyword">const</span> list2:<span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt;=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment">//  定义元组类型</span></span><br><span class="line"><span class="keyword">const</span> tuple:[<span class="built_in">number</span>,<span class="built_in">string</span>]=[<span class="number">1</span>,<span class="string">&#x27;nice&#x27;</span>]</span><br><span class="line"><span class="comment">// 枚举 Monday默认值0，剩下的依次递增</span></span><br><span class="line"><span class="built_in">enum</span> DateEnum &#123;</span><br><span class="line">    Monday,</span><br><span class="line">    Tuesday,</span><br><span class="line">    Wednesday,</span><br><span class="line">    Thursday,</span><br><span class="line">    Friday</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> date:DateEnum=DateEnum.Monday</span><br><span class="line"><span class="comment">// void 表示无返回值</span></span><br><span class="line"><span class="keyword">const</span> setValue:<span class="function">()=&gt;</span><span class="built_in">void</span>=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">otherSetValue</span>(<span class="params"></span>):<span class="title">void</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> simpvalue:<span class="built_in">any</span>=<span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="变量的基本类型"><a href="#变量的基本类型" class="headerlink" title="变量的基本类型"></a>变量的基本类型</h4><table><thead><tr><th align="center">类型名称</th><th align="center">表示式</th></tr></thead><tbody><tr><td align="center">布尔值</td><td align="center">boolean</td></tr><tr><td align="center">数字</td><td align="center">number</td></tr><tr><td align="center">字符串</td><td align="center">string</td></tr><tr><td align="center">数组</td><td align="center">number[] 或 Array&lt;number&gt;</td></tr><tr><td align="center">元组</td><td align="center">[number,string]</td></tr><tr><td align="center">枚举</td><td align="center">enum</td></tr><tr><td align="center">Any</td><td align="center">any</td></tr><tr><td align="center">Void</td><td align="center">void</td></tr><tr><td align="center">Null</td><td align="center">null</td></tr><tr><td align="center">Undefined</td><td align="center">undefined</td></tr><tr><td align="center">Never</td><td align="center">never</td></tr></tbody></table><p>Never永远不存在，或者不是我们想要的，用在抛出异常的函数里；never用try catch的catch</p><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>标准类型-interface</p><p>在面向对象语言中，接口（interface)是一个很重要的概念，它是对行为的抽象，而具体如何行动需要有类（class）去实现。</p><p>TypeScript中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「Shape」进行描述。</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首字母大写</span></span><br><span class="line">    <span class="keyword">interface</span> Iprops &#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="built_in">string</span>,</span><br><span class="line">        <span class="attr">gender</span>:<span class="built_in">number</span>,</span><br><span class="line">        <span class="attr">address</span>:<span class="built_in">string</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> staff:Iprops=&#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;zk&#x27;</span>,</span><br><span class="line">        <span class="attr">gender</span>:<span class="number">1</span>,</span><br><span class="line">        <span class="attr">address</span>:<span class="string">&#x27;suzhou&#x27;</span> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">register</span> (<span class="params"></span>):<span class="title">Iprops</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">name</span>:<span class="string">&#x27;zk&#x27;</span>,</span><br><span class="line">            <span class="attr">gender</span>:<span class="number">1</span>,</span><br><span class="line">            <span class="attr">address</span>:<span class="string">&#x27;suzhou&#x27;</span> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="类型别名-type"><a href="#类型别名-type" class="headerlink" title="类型别名-type"></a>类型别名-type</h4><ul><li>类型别名用来给一个类型起一个新名字</li><li>字符串字面量类型用来约束取值只能是某几个字符串中的一个</li><li>type可以扩展，但是不能继承</li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首字母大写</span></span><br><span class="line">    <span class="keyword">type</span> Iprops =&#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="built_in">string</span>,</span><br><span class="line">        <span class="attr">gender</span>:<span class="built_in">number</span>,</span><br><span class="line">        <span class="attr">address</span>:<span class="built_in">string</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> staff:Iprops=&#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;zk&#x27;</span>,</span><br><span class="line">        <span class="attr">gender</span>:<span class="number">1</span>,</span><br><span class="line">        <span class="attr">address</span>:<span class="string">&#x27;suzhou&#x27;</span> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">register</span> (<span class="params"></span>):<span class="title">Iprops</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">name</span>:<span class="string">&#x27;zk&#x27;</span>,</span><br><span class="line">            <span class="attr">gender</span>:<span class="number">1</span>,</span><br><span class="line">            <span class="attr">address</span>:<span class="string">&#x27;suzhou&#x27;</span> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="接口VS类型别名"><a href="#接口VS类型别名" class="headerlink" title="接口VS类型别名"></a>接口VS类型别名</h4><p>接口</p><ul><li><p>可以继承，可以多态。接口的实现需要implements</p></li><li><p>既是“抽象”也是“约束”</p></li><li><p>优先使用</p></li></ul><p>类型别名</p><ul><li><p>只是类型的别名，没有创建新类型。扩展可以使用&amp;实现</p></li><li><p>主要是约束作用，早期TypeScript主要用作函数、对象的约束</p></li></ul><h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><ul><li><p>typeScript 允许你覆盖它的推断，并且能以你任何你想要的方式分析它，这种机制被称为类型断言</p></li><li><p>通常用来手动指定一个值的类型</p></li><li><p>JSX不能使用<code>&lt;&gt;</code></p></li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line">值 <span class="keyword">as</span> 类型</span><br><span class="line">   or</span><br><span class="line">&lt;类型&gt;值</span><br><span class="line"><span class="keyword">interface</span> Hello &#123;</span><br><span class="line">    <span class="attr">sayHello</span>:<span class="function">()=&gt;</span><span class="built_in">void</span>,</span><br><span class="line">    <span class="attr">name</span>:<span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a=&#123;&#125; </span><br><span class="line">a.name =<span class="string">&#x27;zs&#x27;</span> <span class="comment">// 没有定义类型，会提示类型“&#123;&#125;”上不存在属性“name”</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用类型断言指定类型</span></span><br><span class="line"><span class="keyword">const</span> a =&#123;&#125; <span class="keyword">as</span> Hello</span><br><span class="line">  or</span><br><span class="line"><span class="keyword">const</span> a=&lt;Hello&gt;&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>类型断言是欺骗类型检测，所以最好在确定类型的情况下去用。</p><h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><p>泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 泛型接口</span></span><br><span class="line"><span class="keyword">interface</span> IGprops &#123;</span><br><span class="line">    <span class="attr">setName</span>:&lt;T&gt;<span class="function">(<span class="params">str:T</span>)=&gt;</span><span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> nameWrapper:IGprops=&#123;</span><br><span class="line">    <span class="attr">setName</span>:&lt;T&gt;<span class="function">(<span class="params">str:T</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> userNameArr2:T[]=[]</span><br><span class="line">        userNameArr2.push(str)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nameWrapper.setName(<span class="string">&#x27;zs&#x27;</span>)</span><br><span class="line">nameWrapper.setName(<span class="number">123</span>)</span><br></pre></td></tr></table></figure><h2 id="7-2-TypeScripts实战下"><a href="#7-2-TypeScripts实战下" class="headerlink" title="7.2 TypeScripts实战下"></a>7.2 TypeScripts实战下</h2><h3 id="7-2-1-TypeScript-amp-React实践"><a href="#7-2-1-TypeScript-amp-React实践" class="headerlink" title="7.2.1 TypeScript &amp; React实践"></a>7.2.1 TypeScript &amp; React实践</h3><h4 id="tsconfig-json"><a href="#tsconfig-json" class="headerlink" title="tsconfig.json"></a>tsconfig.json</h4><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;target&quot;</span>: <span class="string">&quot;ESNext&quot;</span>, <span class="comment">// 指定ECMA的版本，这里我们指定了最新版本</span></span><br><span class="line">    <span class="string">&quot;module&quot;</span>: <span class="string">&quot;ESNext&quot;</span>, <span class="comment">// 代码组织方式</span></span><br><span class="line">    <span class="string">&quot;lib&quot;</span>: [ <span class="comment">//工程中依赖的配置</span></span><br><span class="line">      <span class="string">&quot;DOM&quot;</span>,</span><br><span class="line">      <span class="string">&quot;DOM.Iterable&quot;</span>,</span><br><span class="line">      <span class="string">&quot;ESNext&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;moduleResolution&quot;</span>: <span class="string">&quot;node&quot;</span>, </span><br><span class="line">    <span class="string">&quot;experimentalDecorators&quot;</span>: <span class="literal">true</span>, <span class="comment">// 是否开启装饰器</span></span><br><span class="line">    <span class="string">&quot;allowSyntheticDefaultImports&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;outDir&quot;</span>: <span class="string">&quot;dist&quot;</span>, <span class="comment">//输出目录</span></span><br><span class="line">    <span class="string">&quot;strictNullChecks&quot;</span>: <span class="literal">true</span>, <span class="comment">// 对null严格检测</span></span><br><span class="line">    <span class="string">&quot;sourceMap&quot;</span>: <span class="literal">true</span>, <span class="comment">//开启开发者调试</span></span><br><span class="line">    <span class="string">&quot;baseUrl&quot;</span>: <span class="string">&quot;.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;rootDir&quot;</span>: <span class="string">&quot;.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;jsx&quot;</span>: <span class="string">&quot;react&quot;</span>,</span><br><span class="line">    <span class="string">&quot;allowJs&quot;</span>: <span class="literal">true</span>, <span class="comment">// 所有的js都需要编译</span></span><br><span class="line">    <span class="string">&quot;resolveJsonModule&quot;</span>: <span class="comment">// true,是否用json文件</span></span><br><span class="line">    <span class="string">&quot;typeRoots&quot;</span>: [ <span class="comment">// 第三方包和自己包的类型声明</span></span><br><span class="line">      <span class="string">&quot;node_modules/@types&quot;</span>,</span><br><span class="line">      <span class="string">&quot;src/types&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;paths&quot;</span>: &#123; <span class="comment">// alias配置</span></span><br><span class="line">      <span class="string">&quot;@/*&quot;</span>: [<span class="string">&quot;./src/*&quot;</span>],</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;exclude&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;node_modules&quot;</span>,</span><br><span class="line">    <span class="string">&quot;dist&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;compileOnSave&quot;</span>: <span class="literal">false</span> <span class="comment">//是否在保存的时候进行编译</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-2-扩展学习"><a href="#7-2-2-扩展学习" class="headerlink" title="7.2.2 扩展学习"></a>7.2.2 扩展学习</h3><p><a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/typescript-from-scratch.html">ts官方文档（最新文档）</a></p><p><a target="_blank" rel="noopener" href="https://www.tslang.cn/docs/handbook/basic-types.html">中文文档</a></p><p><a target="_blank" rel="noopener" href="https://ts.xcatliu.com/">入门教程</a></p><p><a target="_blank" rel="noopener" href="https://medium.com/@rossbulat/typescript-generics-explained-15c6493b510f">更好的理解 TS 泛型</a></p><h2 id="7-3-React-性能优化"><a href="#7-3-React-性能优化" class="headerlink" title="7.3 React 性能优化"></a>7.3 React 性能优化</h2><h3 id="7-3-1-React-组件性能探寻"><a href="#7-3-1-React-组件性能探寻" class="headerlink" title="7.3.1 React 组件性能探寻"></a>7.3.1 React 组件性能探寻</h3><h4 id="React-Devtools-（react中的性能分析工具）推荐"><a href="#React-Devtools-（react中的性能分析工具）推荐" class="headerlink" title="React Devtools （react中的性能分析工具）推荐"></a>React Devtools （react中的性能分析工具）推荐</h4><ul><li>React v16.5.0+（开发模式）</li><li>React Developer Tools V3.3.2+</li></ul><p>追踪用户行为</p><ol><li><p>安装schedule包， yarn add schedule</p></li><li><p>在需要追踪的地方嵌入代码</p></li></ol><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; unstable_track <span class="keyword">as</span> track&#125; <span class="keyword">from</span> <span class="string">&#x27;schedule/track&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Home</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    handleSubmit =<span class="function"><span class="params">e</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> text = e.target.value.trim()</span><br><span class="line">        <span class="comment">// 用户点击了回车按钮就进行追踪</span></span><br><span class="line">        <span class="keyword">if</span>(e.which===<span class="number">13</span>)&#123;</span><br><span class="line">            track(<span class="string">&quot;Add TOdo&quot;</span>,performance,now,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                <span class="built_in">this</span>.props.onSave(text)</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">this</span>.props.newTodo)&#123;</span><br><span class="line">                    <span class="built_in">this</span>.setState(&#123;<span class="attr">text</span>:<span class="string">&#x27;&#x27;</span>&#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="React-Profiler-API（react中的性能分析工具）"><a href="#React-Profiler-API（react中的性能分析工具）" class="headerlink" title="React Profiler API（react中的性能分析工具）"></a>React Profiler API（react中的性能分析工具）</h4><ol><li>Profilter在“react”包中。</li><li>onRender回调函数，返回一系列信息。</li></ol><h3 id="7-3-2-组件性能优化"><a href="#7-3-2-组件性能优化" class="headerlink" title="7.3.2 组件性能优化"></a>7.3.2 组件性能优化</h3><h4 id="1-PureComponent"><a href="#1-PureComponent" class="headerlink" title="1. PureComponent"></a>1. PureComponent</h4><ul><li><p>class 组件优化工具</p></li><li><p>实质是shouldComponentUpdate 方法中进行浅比较</p></li></ul><p>父组件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React  <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;</span><br><span class="line">            <span class="attr">date</span> : <span class="keyword">new</span> <span class="built_in">Date</span>(),</span><br><span class="line">            <span class="attr">id</span>:<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">                <span class="attr">date</span>:<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Child</span> <span class="attr">seconds</span>=<span class="string">&#123;id&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.state.date.toString()&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从上面可以看出<code>date</code>变量的变化，整个组件都需要diff，我们看出child组件并不依赖<code>date</code>变量；所以date变化的时候，子组件完全没不要渲染，那么我们可以用<code>PureComponent</code>优化一下。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.seconds&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-memo"><a href="#2-memo" class="headerlink" title="2. memo"></a>2. memo</h4><ul><li><p>函数组件优化工具</p></li><li><p>是一个高阶函数，在其内部进行类似shouldComponentUpdate的比较</p></li><li><p>可以指定比较函数</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">&#123;seconds&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>I am update every &#123;seconds&#125; seconds<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.memo(Child)</span><br></pre></td></tr></table></figure><p>不要以为子组件用React.memo就万事大吉了</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">&#123;seconds&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     我们向子组件传递函数，但是函数组件里的函数在每次更新的情况下，函数是重新创建的</span></span><br><span class="line"><span class="comment">     那么子组件每次发现传递函数变化了，也会进行更新，那么你用React.memo进行优化就没有作用了</span></span><br><span class="line"><span class="comment">     怎么解决呢？可以用useCallback进行包裹</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//优化前</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优化后</span></span><br><span class="line">    <span class="keyword">const</span> change  = useCallback(<span class="function">()=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">change</span>=<span class="string">&#123;change&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">&#123;seconds&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>I am update every &#123;seconds&#125; seconds<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.memo(Child)</span><br></pre></td></tr></table></figure><p>::: warning<br>React.memo()可接受2个参数，第一个参数为纯函数的组件，第二个参数用于对比props控制是否刷新，与shouldComponentUpdate()功能类似。[2]</p><p>React.memo 等效于 PureComponent，但它只比较 props。（你也可以通过第二个参数指定一个自定义的比较函数来比较新旧 props。如果函数返回 true，就会跳过更新。）<br>:::</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">&#123;seconds&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>I am update every &#123;seconds&#125; seconds<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">areEqual</span>(<span class="params">prevProps, nextProps</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prevProps.seconds===nextProps.seconds)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.memo(Child,areEqual)</span><br></pre></td></tr></table></figure><h4 id="3-原生事件、定时器的销毁"><a href="#3-原生事件、定时器的销毁" class="headerlink" title="3 原生事件、定时器的销毁"></a>3 原生事件、定时器的销毁</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="~@/react/reactNature.png"></p><h4 id="4-使用不变的数据结构"><a href="#4-使用不变的数据结构" class="headerlink" title="4.使用不变的数据结构"></a>4.使用不变的数据结构</h4><p>数据不变性不是架构或设计模式，而是一种固执己见的代码编写方式。这迫使您考虑如何组织应用程序数据流。在我看来，数据不变性是围绕严格的单向数据流进行的实践。</p><p>优势：</p><ul><li>零副作用</li><li>不可变数据对象更易于创建、测试和使用</li><li>容易跟踪变化</li></ul><p>案例：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Imu</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">    state = &#123;</span><br><span class="line">       <span class="attr">users</span>: []</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   addNewUser = <span class="function">() =&gt;</span>&#123;</span><br><span class="line">       <span class="keyword">const</span> users = <span class="built_in">this</span>.state.users;</span><br><span class="line">       users.push(&#123;</span><br><span class="line">           <span class="attr">userName</span>: <span class="string">&quot;robin&quot;</span>,</span><br><span class="line">           <span class="attr">email</span>: <span class="string">&quot;email@email.com&quot;</span></span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="built_in">this</span>.setState(&#123;<span class="attr">users</span>: users&#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种情况，user和this.state.users是同一个引用，我们直接修改user，相当于直接修改了this.state.users；react状态应该是不可变的,因为setState()之后，能替换调你在之前所做的修改</p><p>直接修改state带来的问题：</p><p>我们利用shouldComponentUpdate来判断是否重新渲染组件，this.state.users和nextState.user是同一个引用，所以即使数组变化了,React也不会重新渲染UI</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">shouldComponentUpdate</span>(<span class="params">nextProps, nextState</span>)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.state.users !== nextState.users) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>如何避免此类问题</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">addNewUser = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">       <span class="attr">users</span>: state.users.concat(&#123;</span><br><span class="line">         <span class="attr">timeStamp</span>: <span class="keyword">new</span> <span class="built_in">Date</span>(),</span><br><span class="line">         <span class="attr">userName</span>: <span class="string">&quot;robin&quot;</span>,</span><br><span class="line">         <span class="attr">email</span>: <span class="string">&quot;email@email.com&quot;</span></span><br><span class="line">       &#125;)</span><br><span class="line">     &#125;));</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p>可以考虑以下不可变的方法：</p><p>数组：[].concat 或 […params]</p><p>对象：Object.assign({}, …)或 es6{…params}</p><p>可变数据结构的优化库:</p><ol><li><p>mmutable.js</p></li><li><p>react-copy-write</p></li></ol><h4 id="5-拆分文件"><a href="#5-拆分文件" class="headerlink" title="5. 拆分文件"></a>5. 拆分文件</h4><p>随着不断的添加新功能和依赖项，不只不觉你的项目变的巨大，我们可以考虑分离第三方包；把您的应用程序代码和第三方库分离，<br>通过拆分文件，您的浏览器可以并行下载资源，减少等待时间，<a target="_blank" rel="noopener" href="https://webpack.js.org/plugins/split-chunks-plugin/">SplitChunksPlugin</a></p><h4 id="6-依赖优化"><a href="#6-依赖优化" class="headerlink" title="6. 依赖优化"></a>6. 依赖优化</h4><p>在优化应用程序代码的时候，有必要检查你在程序中使用了多少库的代码，例如你使用了Moment.js;这个库包含了许多你不需要的国家化语言包，那么您可以考虑使用moment-locales-webpack-plugin为您的最终包删除未使用的语言包。</p><p>lodash，你可以用lodash-webpack-plugin删除未使用的功能</p><h4 id="7-React-Fragments-用于避免多余HTML元素"><a href="#7-React-Fragments-用于避免多余HTML元素" class="headerlink" title="7. React.Fragments 用于避免多余HTML元素"></a>7. React.Fragments 用于避免多余HTML元素</h4><p>在react中我们必须用一个根元素包裹子元素，我们可以用React.Fragment进行包裹，在渲染的时候它并不会渲染成真的HTML元素</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Comments</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">PureComponent</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Comment Title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>comments<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>comment time<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Comments</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">PureComponent</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Comment Title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>comments<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>comment time<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-避免在渲染函数中使用内联函数定义"><a href="#8-避免在渲染函数中使用内联函数定义" class="headerlink" title="8. 避免在渲染函数中使用内联函数定义"></a>8. 避免在渲染函数中使用内联函数定义</h4><p>由于函数是 JavaScript ( {} !== {})中的对象，因此当 React 进行 diff 检查时，内联函数将始终diff失败。此外，如果在 JSX 属性中使用箭头函数，则会在每个渲染上创建该函数的新实例。这可能会为垃圾收集器带来大量工作。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">CommentList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        <span class="attr">comments</span>: [],</span><br><span class="line">        <span class="attr">selectedCommentId</span>: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; comments &#125; = <span class="built_in">this</span>.state;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">           comments.map(<span class="function">(<span class="params">comment</span>)=&gt;</span>&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Comment</span> <span class="attr">onClick</span>=<span class="string">&#123;(e)</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="xml">                    this.setState(&#123;selectedCommentId:comment.commentId&#125;)</span></span><br><span class="line"><span class="xml">               &#125;&#125; comment=&#123;comment&#125; key=&#123;comment.id&#125;/&gt;</span></span><br><span class="line">           &#125;) </span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>您可以定义箭头函数，而不是为 props 定义内联函数。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">CommentList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        <span class="attr">comments</span>: [],</span><br><span class="line">        <span class="attr">selectedCommentId</span>: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    onCommentClick = <span class="function">(<span class="params">commentId</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;<span class="attr">selectedCommentId</span>:commentId&#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; comments &#125; = <span class="built_in">this</span>.state;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">           comments.map(<span class="function">(<span class="params">comment</span>)=&gt;</span>&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Comment</span> <span class="attr">onClick</span>=<span class="string">&#123;this.onCommentClick&#125;</span> </span></span></span><br><span class="line"><span class="tag"><span class="xml">                <span class="attr">comment</span>=<span class="string">&#123;comment&#125;</span> <span class="attr">key</span>=<span class="string">&#123;comment.id&#125;/</span>&gt;</span></span></span><br><span class="line">           &#125;) </span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-使用防抖节流"><a href="#9-使用防抖节流" class="headerlink" title="9. 使用防抖节流"></a>9. 使用防抖节流</h4><p>节流：在规定时间内去触发一次，在这个时间内无论你做多少行为，我只触发一次行为</p><p>防抖：防止事件频繁触发，只在用户停止行为后，在延迟之后的时间触发</p><p>可以使用lodash</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> debouce <span class="keyword">from</span> <span class="string">&#x27;lodash.debounce&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SearchComments</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">   <span class="built_in">super</span>(props);</span><br><span class="line">   <span class="built_in">this</span>.state = &#123; <span class="attr">searchQuery</span>: “” &#125;;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> setSearchQuery = debounce(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">this</span>.setState(&#123; <span class="attr">searchQuery</span>: e.target.value &#125;);</span><br><span class="line"> &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> (</span><br><span class="line">     <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">       <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Search Comments<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">       <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.setSearchQuery&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">   );</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-避免使用-Index-作为-Map-的-Key"><a href="#10-避免使用-Index-作为-Map-的-Key" class="headerlink" title="10. 避免使用 Index 作为 Map 的 Key"></a>10. 避免使用 Index 作为 Map 的 Key</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    comments.map(<span class="function">(<span class="params">comment, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">Comment</span> </span></span></span><br><span class="line"><span class="tag"><span class="xml">            &#123;<span class="attr">..comment</span>&#125;</span></span></span><br><span class="line"><span class="tag"><span class="xml">            <span class="attr">key</span>=<span class="string">&#123;index&#125;</span> /&gt;</span></span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用index可能导致你的应用程序显示不正确，因为在diff的时候会使用到key；当你在删除、添加、移动列表的时候，key值相同的<br>元素已经不是同一个元素了。</p><p>在某些情况下可以使用index作为key</p><ul><li>列表和项目是静态的</li><li>列表中的项目没有 ID，列表永远不会被重新排序或过滤</li><li>列表是不可变的</li></ul><h4 id="11-避免用props初始组件的状态"><a href="#11-避免用props初始组件的状态" class="headerlink" title="11. 避免用props初始组件的状态"></a>11. 避免用props初始组件的状态</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EditPanelComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.state =&#123;</span><br><span class="line">            <span class="attr">isEditMode</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">applyCoupon</span>: props.applyCoupon</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    &#123;this.state.applyCoupon &amp;&amp; </span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;&gt;</span>Enter Coupon: <span class="tag">&lt;<span class="name">Input</span>/&gt;</span><span class="tag">&lt;/&gt;</span></span>&#125;</span><br><span class="line">               &lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在没有刷新组件的情况下更改了 props，则新的 props 值将永远不会分配给状态的applyCoupon,因为constructor只会在初始化的时候调用。</p><p>解决方法：可以componentWillReceiveProps，可以通过props来更新状态</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.state =&#123;</span><br><span class="line">            <span class="attr">isEditMode</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">applyCoupon</span>: props.applyCoupon</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">componentWillReceiveProps</span>(<span class="params">nextProps</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nextProps.applyCoupon !== <span class="built_in">this</span>.props.applyCoupon) &#123;</span><br><span class="line">            <span class="built_in">this</span>.setState(&#123; <span class="attr">applyCoupon</span>: nextProps.applyCoupon &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.applyCoupon &amp;&amp; </span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;&gt;</span>Enter Coupon: <span class="tag">&lt;<span class="name">Input</span>/&gt;</span><span class="tag">&lt;/&gt;</span></span>&#125;&lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="12-webpack-使用mode"><a href="#12-webpack-使用mode" class="headerlink" title="12. webpack 使用mode"></a>12. webpack 使用mode</h4><p>webpack4 ,mode设置为<code>production</code>,webpack会使用内置优化</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">     <span class="attr">mode</span>: <span class="string">&#x27;production&#x27;</span></span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure><h4 id="13-在-DOM-元素上传播-props"><a href="#13-在-DOM-元素上传播-props" class="headerlink" title="13. 在 DOM 元素上传播 props"></a>13. 在 DOM 元素上传播 props</h4><p>这样做会添加未知的html属性，这是没有必要的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CommentsText = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span> &#123;<span class="attr">...props</span>&#125;&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;props.text&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>可以设置特定属性</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CommentsText = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">specificAttr</span>=<span class="string">&#123;props.specificAttr&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;props.text&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="14-CSS-动画代替-JS-动画"><a href="#14-CSS-动画代替-JS-动画" class="headerlink" title="14. CSS 动画代替 JS 动画"></a>14. CSS 动画代替 JS 动画</h4><p>动画对于流畅和愉悦的用户体验来说是不可避免的。有很多方法可以实现网页动画。一般来说，我们可以通过三种方式创建动画：</p><p>CSS 过渡</p><p>CSS 动画</p><p>JavaScript</p><h4 id="15-CDN"><a href="#15-CDN" class="headerlink" title="15. CDN"></a>15. CDN</h4><p>CDN 可以将静态内容传输的更快，从您的网站或移动应用程序更快。</p><h4 id="16-Web-Workers-API-尝试"><a href="#16-Web-Workers-API-尝试" class="headerlink" title="16 Web Workers API 尝试"></a>16 Web Workers API 尝试</h4><ul><li><p>Web Workers 使用后，Web应用程序可以：</p><ul><li>在独立于主线程的后台线程中运行一个脚本；</li><li>在独立线程中执行费时的任务，避免一些耗时的任务阻断用户体验</li></ul></li><li><p>通信机制 Web Worker执行完耗时任务后与主线程的通信</p><ul><li>postMessage</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sort.worker.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>  <span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    self.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!e) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">let</span> posts = e.data;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>, len = posts.length - <span class="number">1</span>; index &lt; len; index++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> count = index+<span class="number">1</span>; count &lt; posts.length; count++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (posts[index].commentCount &gt; posts[count].commentCount) &#123;</span><br><span class="line">                    <span class="keyword">const</span> temp = posts[index];</span><br><span class="line">                    posts[index] = users[count];</span><br><span class="line">                    posts[count] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        postMessage(posts);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Posts <span class="keyword">extends</span> React.Component&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(posts);</span><br><span class="line">    &#125;</span><br><span class="line">    state = &#123;</span><br><span class="line">        <span class="attr">posts</span>: <span class="built_in">this</span>.props.posts</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.worker = <span class="keyword">new</span> Worker(<span class="string">&#x27;sort.worker.js&#x27;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">this</span>.worker.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> sortedPosts = event.data;</span><br><span class="line">            <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">                <span class="attr">posts</span>: sortedPosts</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    doSortingByComment = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.state.posts &amp;&amp; <span class="built_in">this</span>.state.posts.length)&#123;</span><br><span class="line">            <span class="built_in">this</span>.worker.postMessage(<span class="built_in">this</span>.state.posts);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> posts = <span class="built_in">this</span>.state.posts;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.doSortingByComment&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    Sort By Comments</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">PostList</span> <span class="attr">posts</span>=<span class="string">&#123;posts&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">PostList</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="17-虚拟化长列表"><a href="#17-虚拟化长列表" class="headerlink" title="17. 虚拟化长列表"></a>17. 虚拟化长列表</h4><p>列表虚拟化或窗口化是一种在呈现长数据列表时提高性能的技术。这种技术在任何给定时间只渲染一小部分行，并且可以显着减少重新渲染组件所需的时间，以及创建的 DOM 节点的数量。</p><p>有一些流行的 React 库，比如react-window和react-virtualized，它们提供了几个可重用的组件来显示列表、网格和表格数据。</p><h4 id="18-服务端渲染"><a href="#18-服务端渲染" class="headerlink" title="18. 服务端渲染"></a>18. 服务端渲染</h4><p>可以参考最后一章，项目实战，有服务端渲染代码</p><h4 id="19-在-Web-服务器上启用-Gzip-压缩"><a href="#19-在-Web-服务器上启用-Gzip-压缩" class="headerlink" title="19. 在 Web 服务器上启用 Gzip 压缩"></a>19. 在 Web 服务器上启用 Gzip 压缩</h4><h4 id="20-useMemo进行缓存大量计算数据，useCallback-进行缓存函数，避免重复创建"><a href="#20-useMemo进行缓存大量计算数据，useCallback-进行缓存函数，避免重复创建" class="headerlink" title="20. useMemo进行缓存大量计算数据，useCallback 进行缓存函数，避免重复创建"></a>20. useMemo进行缓存大量计算数据，useCallback 进行缓存函数，避免重复创建</h4><p>在hooks章节有讲解</p><h4 id="21-惰性初始化"><a href="#21-惰性初始化" class="headerlink" title="21. 惰性初始化"></a>21. 惰性初始化</h4><p>优化前：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">table</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [state,setState]=useState(createRows(props.count))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面这种写法，会导致，每次组件更新都要调用createRows，相当于下面的写法</span></span><br><span class="line"><span class="keyword">const</span> values = createRows(props.count)</span><br><span class="line"><span class="keyword">const</span> [state,setState]=useState(values)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>优化后：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">table</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [state,setState]=useState(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> createRows(props.count)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>建议先进行基准测试和测量性能。您可以考虑使用 Chrome 时间轴分析和可视化组件。可以查看哪些组件被卸载、安装、更新，以及它们相对于彼此所花费的时间。它将帮助您开始性能优化之旅。</p><h3 id="7-3-3-扩展资料"><a href="#7-3-3-扩展资料" class="headerlink" title="7.3.3 扩展资料"></a>7.3.3 扩展资料</h3><p><a target="_blank" rel="noopener" href="https://reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html">React Profiler 博客</a></p><p><a target="_blank" rel="noopener" href="http://www.brendangregg.com/flamegraphs.html">理解火焰图</a></p><p><a target="_blank" rel="noopener" href="https://reactjs.org/docs/profiler.html#gatsby-focus-wrapper">React Profiler API</a></p><p><a target="_blank" rel="noopener" href="https://www.codementor.io/blog/react-optimization-5wiwjnf9hj">React 优化手段</a></p></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/React/">React</a></div><div class="post_share"><div class="social-share" data-image="/img/cover/cover_6.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="ads-wrap">/img/banner/banner_2.jpeg</div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/59814/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover_9.jpg" onerror='onerror=null,src="/img/404.png"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">React状态管理</div></div></a></div><div class="next-post pull-right"><a href="/11559/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover_11.jpg" onerror='onerror=null,src="/img/404.png"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">React hooks</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/11239/" title="入门介绍"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover_2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-08</div><div class="title">入门介绍</div></div></a></div><div><a href="/10919/" title="步入React"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover_9.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-08</div><div class="title">步入React</div></div></a></div><div><a href="/60006/" title="React正篇"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover_7.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-08</div><div class="title">React正篇</div></div></a></div><div><a href="/10279/" title="React生态"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover_2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-08</div><div class="title">React生态</div></div></a></div><div><a href="/59622/" title="React原理"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover_11.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-08</div><div class="title">React原理</div></div></a></div><div><a href="/59814/" title="React状态管理"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover_9.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-08</div><div class="title">React状态管理</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">总结整理前端知识点 \(￣︶￣*\))<br>持续更新中...<br>ヾ(•ω•`)o</div></div><div class="sticky_layout"><div class="top-banner card-widget card-ads"><div class="mySwiper adWarpper" id="swiper"><div class="swiper-wrapper"><div class="swiper-slide"><a class="swiper-slide-link" target="_blank" rel="noopener" href="https://curl.qcloud.com/NRfY770X"><img class="swiper-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/ads/tx_345x200.jpg" alt="error"><p class="desc">腾讯云限时秒杀,40元/1年,200元/3年</p></a></div><div class="swiper-slide"><a class="swiper-slide-link" target="_blank" rel="noopener" href="https://cashier.iqiyi.com/cashier/cashier/cashier.html#/?fv=pu_9ee7da3ed3b1d683&amp;fc=886ad403a20bb50d&amp;allowpay=1&amp;vipType=1&amp;offline=1&amp;payAutoRenew=3&amp;amount=12"><img class="swiper-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/ads/iqy.png" alt="error"></a></div></div><div class="swiper-pagination"></div></div></div><script type="text/javascript">window.addEventListener("load",function(){new Swiper(".adWarpper",{spaceBetween:30,centeredSlides:!0,effect:"cube",fadeEffect:{crossFade:!0},autoplay:{delay:2500,disableOnInteraction:!1},loop:!0,pagination:{el:".swiper-pagination",clickable:!0}})})</script><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-TypeScripts%E5%AE%9E%E6%88%98%E4%B8%8A"><span class="toc-number">1.</span> <span class="toc-text">7.1 TypeScripts实战上</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-1-TypeScript-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">1.1.</span> <span class="toc-text">7.1.1 TypeScript 设计原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-2-TypeScript-%E5%9F%BA%E7%A1%80"><span class="toc-number">1.2.</span> <span class="toc-text">7.1.2 TypeScript 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ts%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.2.1.</span> <span class="toc-text">ts的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="toc-number">1.2.2.</span> <span class="toc-text">变量声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.3.</span> <span class="toc-text">变量的基本类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.4.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D-type"><span class="toc-number">1.2.5.</span> <span class="toc-text">类型别名-type</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3VS%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-number">1.2.6.</span> <span class="toc-text">接口VS类型别名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="toc-number">1.2.7.</span> <span class="toc-text">类型断言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.2.8.</span> <span class="toc-text">泛型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-TypeScripts%E5%AE%9E%E6%88%98%E4%B8%8B"><span class="toc-number">2.</span> <span class="toc-text">7.2 TypeScripts实战下</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-1-TypeScript-amp-React%E5%AE%9E%E8%B7%B5"><span class="toc-number">2.1.</span> <span class="toc-text">7.2.1 TypeScript &amp; React实践</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tsconfig-json"><span class="toc-number">2.1.1.</span> <span class="toc-text">tsconfig.json</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-2-%E6%89%A9%E5%B1%95%E5%AD%A6%E4%B9%A0"><span class="toc-number">2.2.</span> <span class="toc-text">7.2.2 扩展学习</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-React-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">3.</span> <span class="toc-text">7.3 React 性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-1-React-%E7%BB%84%E4%BB%B6%E6%80%A7%E8%83%BD%E6%8E%A2%E5%AF%BB"><span class="toc-number">3.1.</span> <span class="toc-text">7.3.1 React 组件性能探寻</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#React-Devtools-%EF%BC%88react%E4%B8%AD%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%EF%BC%89%E6%8E%A8%E8%8D%90"><span class="toc-number">3.1.1.</span> <span class="toc-text">React Devtools （react中的性能分析工具）推荐</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#React-Profiler-API%EF%BC%88react%E4%B8%AD%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%EF%BC%89"><span class="toc-number">3.1.2.</span> <span class="toc-text">React Profiler API（react中的性能分析工具）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-2-%E7%BB%84%E4%BB%B6%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">3.2.</span> <span class="toc-text">7.3.2 组件性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-PureComponent"><span class="toc-number">3.2.1.</span> <span class="toc-text">1. PureComponent</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-memo"><span class="toc-number">3.2.2.</span> <span class="toc-text">2. memo</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8E%9F%E7%94%9F%E4%BA%8B%E4%BB%B6%E3%80%81%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E9%94%80%E6%AF%81"><span class="toc-number">3.2.3.</span> <span class="toc-text">3 原生事件、定时器的销毁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%8F%98%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.2.4.</span> <span class="toc-text">4.使用不变的数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%8B%86%E5%88%86%E6%96%87%E4%BB%B6"><span class="toc-number">3.2.5.</span> <span class="toc-text">5. 拆分文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E4%BE%9D%E8%B5%96%E4%BC%98%E5%8C%96"><span class="toc-number">3.2.6.</span> <span class="toc-text">6. 依赖优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-React-Fragments-%E7%94%A8%E4%BA%8E%E9%81%BF%E5%85%8D%E5%A4%9A%E4%BD%99HTML%E5%85%83%E7%B4%A0"><span class="toc-number">3.2.7.</span> <span class="toc-text">7. React.Fragments 用于避免多余HTML元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E9%81%BF%E5%85%8D%E5%9C%A8%E6%B8%B2%E6%9F%93%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89"><span class="toc-number">3.2.8.</span> <span class="toc-text">8. 避免在渲染函数中使用内联函数定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E4%BD%BF%E7%94%A8%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81"><span class="toc-number">3.2.9.</span> <span class="toc-text">9. 使用防抖节流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8-Index-%E4%BD%9C%E4%B8%BA-Map-%E7%9A%84-Key"><span class="toc-number">3.2.10.</span> <span class="toc-text">10. 避免使用 Index 作为 Map 的 Key</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E9%81%BF%E5%85%8D%E7%94%A8props%E5%88%9D%E5%A7%8B%E7%BB%84%E4%BB%B6%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">3.2.11.</span> <span class="toc-text">11. 避免用props初始组件的状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-webpack-%E4%BD%BF%E7%94%A8mode"><span class="toc-number">3.2.12.</span> <span class="toc-text">12. webpack 使用mode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-%E5%9C%A8-DOM-%E5%85%83%E7%B4%A0%E4%B8%8A%E4%BC%A0%E6%92%AD-props"><span class="toc-number">3.2.13.</span> <span class="toc-text">13. 在 DOM 元素上传播 props</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-CSS-%E5%8A%A8%E7%94%BB%E4%BB%A3%E6%9B%BF-JS-%E5%8A%A8%E7%94%BB"><span class="toc-number">3.2.14.</span> <span class="toc-text">14. CSS 动画代替 JS 动画</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-CDN"><span class="toc-number">3.2.15.</span> <span class="toc-text">15. CDN</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-Web-Workers-API-%E5%B0%9D%E8%AF%95"><span class="toc-number">3.2.16.</span> <span class="toc-text">16 Web Workers API 尝试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-%E8%99%9A%E6%8B%9F%E5%8C%96%E9%95%BF%E5%88%97%E8%A1%A8"><span class="toc-number">3.2.17.</span> <span class="toc-text">17. 虚拟化长列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93"><span class="toc-number">3.2.18.</span> <span class="toc-text">18. 服务端渲染</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19-%E5%9C%A8-Web-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E5%90%AF%E7%94%A8-Gzip-%E5%8E%8B%E7%BC%A9"><span class="toc-number">3.2.19.</span> <span class="toc-text">19. 在 Web 服务器上启用 Gzip 压缩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-useMemo%E8%BF%9B%E8%A1%8C%E7%BC%93%E5%AD%98%E5%A4%A7%E9%87%8F%E8%AE%A1%E7%AE%97%E6%95%B0%E6%8D%AE%EF%BC%8CuseCallback-%E8%BF%9B%E8%A1%8C%E7%BC%93%E5%AD%98%E5%87%BD%E6%95%B0%EF%BC%8C%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E5%88%9B%E5%BB%BA"><span class="toc-number">3.2.20.</span> <span class="toc-text">20. useMemo进行缓存大量计算数据，useCallback 进行缓存函数，避免重复创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21-%E6%83%B0%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.2.21.</span> <span class="toc-text">21. 惰性初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.2.22.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-3-%E6%89%A9%E5%B1%95%E8%B5%84%E6%96%99"><span class="toc-number">3.3.</span> <span class="toc-text">7.3.3 扩展资料</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/59814/" title="React状态管理"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover_9.jpg" onerror='this.onerror=null,this.src="/img/404.png"' alt="React状态管理"></a><div class="content"><a class="title" href="/59814/" title="React状态管理">React状态管理</a><time datetime="2022-02-08T06:21:43.000Z" title="发表于 2022-02-08 14:21:43">2022-02-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/59815/" title="React高级实战"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover_6.jpg" onerror='this.onerror=null,this.src="/img/404.png"' alt="React高级实战"></a><div class="content"><a class="title" href="/59815/" title="React高级实战">React高级实战</a><time datetime="2022-02-08T06:21:43.000Z" title="发表于 2022-02-08 14:21:43">2022-02-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/11559/" title="React hooks"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover_11.jpg" onerror='this.onerror=null,this.src="/img/404.png"' alt="React hooks"></a><div class="content"><a class="title" href="/11559/" title="React hooks">React hooks</a><time datetime="2022-02-08T06:21:43.000Z" title="发表于 2022-02-08 14:21:43">2022-02-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/59622/" title="React原理"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover_11.jpg" onerror='this.onerror=null,this.src="/img/404.png"' alt="React原理"></a><div class="content"><a class="title" href="/59622/" title="React原理">React原理</a><time datetime="2022-02-08T06:21:39.000Z" title="发表于 2022-02-08 14:21:39">2022-02-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/10279/" title="React生态"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover_2.jpg" onerror='this.onerror=null,this.src="/img/404.png"' alt="React生态"></a><div class="content"><a class="title" href="/10279/" title="React生态">React生态</a><time datetime="2022-02-08T06:21:34.000Z" title="发表于 2022-02-08 14:21:34">2022-02-08</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By souldjl</div><div class="footer_custom_text">没有行动的梦想，都是妄想～</div><a href="/statement">免责申明</a><span class="footer-separator">| 友情链接:</span><a target="_blank" rel="noopener" href="https://blog.xujiayao.top">Xujiayao's Blog</a></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function addGitalkSource(){const t=document.createElement("link");t.rel="stylesheet",t.href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css",document.getElementsByTagName("head")[0].appendChild(t)}function loadGitalk(){function t(){new Gitalk(Object.assign({clientID:"28388bc5382cb36e8b6a",clientSecret:"0976a3fb2d62d4e2b86385d26451a23ead66f6eb",repo:"souldjl.github.io",owner:"souldjl",admin:["souldjl"],id:"4e17bf57bfaa98ce70e652a796f12045",updateCountCallback:commentCount},null)).render("gitalk-container")}"function"==typeof Gitalk?t():(addGitalkSource(),getScript("https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js").then(t))}function commentCount(t){let e=document.querySelector("#post-meta .gitalk-comment-count");e&&(e.innerHTML=t)}function loadOtherComment(){loadGitalk()}loadGitalk()</script></div><script src="https://cdn.bootcdn.net/ajax/libs/Swiper/7.4.1/swiper-bundle.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",function(){if(window.removeEventListener("scroll",window.tocScrollFn),window.removeEventListener("scroll",scrollCollect),"object"==typeof preloader&&preloader.initLoading(),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")}),document.addEventListener("pjax:complete",function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script");var o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()}),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>