<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>JS面试知识点总结(十) | 高级前端进阶</title><meta name="keywords" content="前端面试,Javascript面试知识点,JavaScript 面试知识点总结"><meta name="author" content="souldjl"><meta name="copyright" content="souldjl"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="介绍一下-js-的节流与防抖 与原来的比较操作符 “&#x3D;&#x3D;&#x3D;”、“&#x3D;&#x3D;” 的区别？]( objectis-与原来的比较操作符--的区别) escapeencodeuriencodeuricomponent-有什么区别 unicode-和-utf-8-之间的关系 js-的事件循环是什么 js-中的深浅拷贝实现 手写-callapply-及-bind-函数 函数柯里化的实现 为什么-01--02--03"><meta property="og:type" content="article"><meta property="og:title" content="JS面试知识点总结(十)"><meta property="og:url" content="https://www.daijl.cn/48401/index.html"><meta property="og:site_name" content="高级前端进阶"><meta property="og:description" content="介绍一下-js-的节流与防抖 与原来的比较操作符 “&#x3D;&#x3D;&#x3D;”、“&#x3D;&#x3D;” 的区别？]( objectis-与原来的比较操作符--的区别) escapeencodeuriencodeuricomponent-有什么区别 unicode-和-utf-8-之间的关系 js-的事件循环是什么 js-中的深浅拷贝实现 手写-callapply-及-bind-函数 函数柯里化的实现 为什么-01--02--03"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.daijl.cn/img/cover/cover_4.jpg"><meta property="article:published_time" content="2022-01-17T11:47:12.000Z"><meta property="article:modified_time" content="2022-01-19T04:55:19.231Z"><meta property="article:author" content="souldjl"><meta property="article:tag" content="Javascript"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.daijl.cn/img/cover/cover_4.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://www.daijl.cn/48401/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="T8zNWQNhDDztzYe6Y7pYKuJIY8LO45bxxN1iGheQnI"><meta name="baidu_site_verification" content="code-UTlFxDZspp"><meta name="sogou_site_verification" content="pSw0CiDaj7"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?f30a76e6d5701be25349f80c829c0a52";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:50,languages:{author:"作者: souldjl",link:"链接: ",source:"来源: 高级前端进阶",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"null",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"JS面试知识点总结(十)",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-01-19 12:55:19"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0!==o){const a=new Date;o=864e5*o,o={value:t,expiry:a.getTime()+o};localStorage.setItem(e,JSON.stringify(o))}},get:function(e){var t=localStorage.getItem(e);if(t){t=JSON.parse(t);const o=new Date;if(!(o.getTime()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=a=>new Promise((t,e)=>{const o=document.createElement("script");o.src=a,o.async=!0,o.onerror=e,o.onload=o.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(o.onload=o.onreadystatechange=null,t())},document.head.appendChild(o)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};e=saveToLocal.get("theme");"dark"===e?activateDarkMode():"light"===e&&activateLightMode();e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/Swiper/7.4.1/swiper-bundle.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-tools"></i><span> 实用工具</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://nav.daijl.cn/"><span>编程导航</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">高级前端进阶</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-tools"></i><span> 实用工具</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://nav.daijl.cn/"><span>编程导航</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">JS面试知识点总结(十)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-17T11:47:12.000Z" title="发表于 2022-01-17 19:47:12">2022-01-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-01-19T04:55:19.231Z" title="更新于 2022-01-19 12:55:19">2022-01-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/">前端面试</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/Javascript/">Javascript</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">3.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>13分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="JS面试知识点总结(十)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/48401/#post-comment"><span class="gitalk-comment-count"></span></a></span></div></div></div><article class="post-content" id="article-container"><h2 id="介绍一下-js-的节流与防抖？"><a href="#介绍一下-js-的节流与防抖？" class="headerlink" title="介绍一下 js 的节流与防抖？"></a>介绍一下 js 的节流与防抖？</h2><p>相关知识点：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数防抖： 在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数节流： 规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数防抖的实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="built_in">this</span>,</span><br><span class="line">      args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果此时存在定时器的话，则取消之前的定时器重新记时</span></span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">      timer = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置定时器，使事件间隔指定事件后执行</span></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数节流的实现;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> preTime = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="built_in">this</span>,</span><br><span class="line">      args = <span class="built_in">arguments</span>,</span><br><span class="line">      nowTime = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果两次时间间隔超过了指定时间，则执行函数。</span></span><br><span class="line">    <span class="keyword">if</span> (nowTime - preTime &gt;= delay) &#123;</span><br><span class="line">      preTime = <span class="built_in">Date</span>.now();</span><br><span class="line">      <span class="keyword">return</span> fn.apply(context, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回答：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。</span><br><span class="line"></span><br><span class="line">函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a target="_blank" rel="noopener" href="https://juejin.im/post/5a35ed25f265da431d3cc1b1">《轻松理解 JS 函数节流和函数防抖》</a><br><a target="_blank" rel="noopener" href="https://juejin.im/post/5aa60b0e518825556b6c6d1a">《JavaScript 事件节流和事件防抖》</a><br><a target="_blank" rel="noopener" href="https://juejin.im/entry/5b1d2d54f265da6e2545bfa4">《JS 的防抖与节流》</a></p><h2 id="Object-is-与原来的比较操作符-“-”、“-”-的区别？"><a href="#Object-is-与原来的比较操作符-“-”、“-”-的区别？" class="headerlink" title="Object.is() 与原来的比较操作符 “===”、“==” 的区别？"></a>Object.is() 与原来的比较操作符 “===”、“==” 的区别？</h2><p>相关知识点：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">两等号判等，会在比较时进行类型转换。</span><br><span class="line">三等号判等（判断严格），比较时不进行隐式类型转换，（类型不同则会返回false）。</span><br><span class="line"></span><br><span class="line">Object.is 在三等号判等的基础上特别处理了 NaN 、-0 和 +0 ，保证 -0 和 +0 不再相同，但 Object.is(NaN, NaN) 会返回 true.</span><br><span class="line"></span><br><span class="line">Object.is 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。</span><br></pre></td></tr></table></figure><p>回答：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用双等号进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较。</span><br><span class="line"></span><br><span class="line">使用三等号进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false。</span><br><span class="line"></span><br><span class="line">使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 认定为是相等的。</span><br></pre></td></tr></table></figure><h2 id="escape-encodeURI-encodeURIComponent-有什么区别？"><a href="#escape-encodeURI-encodeURIComponent-有什么区别？" class="headerlink" title="escape,encodeURI,encodeURIComponent 有什么区别？"></a>escape,encodeURI,encodeURIComponent 有什么区别？</h2><p>相关知识点：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">escape 和 encodeURI 都属于 Percent-encoding，基本功能都是把 URI 非法字符转化成合法字符，转化后形式类似「%*」。</span><br><span class="line">它们的根本区别在于，escape 在处理 0xff 之外字符的时候，是直接使用字符的 unicode 在前面加上一个「%u」，而 encode URI 则是先进行 UTF-8，再在 UTF-8 的每个字节码前加上一个「%」；在处理 0xff 以内字符时，编码方式是一样的（都是「%XX」，XX 为字符的 16 进制 unicode，同时也是字符的 UTF-8），只是范围（即哪些字符编码哪些字符不编码）不一样。</span><br></pre></td></tr></table></figure><p>回答：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">encodeURI 是对整个 URI 进行转义，将 URI 中的非法字符转换为合法字符，所以对于一些在 URI 中有特殊意义的字符不会进行转义。</span><br><span class="line"></span><br><span class="line">encodeURIComponent 是对 URI 的组成部分进行转义，所以一些特殊字符也会得到转义。</span><br><span class="line"></span><br><span class="line">escape 和 encodeURI 的作用相同，不过它们对于 unicode 编码为 0xff 之外字符的时候会有区别，escape 是直接在字符的 unicode 编码前加上 %u，而 encodeURI 首先会将字符转换为 UTF-8 的格式，再在每个字节前加上 %。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/21861899">《escape,encodeURI,encodeURIComponent 有什么区别?》</a></p><h2 id="Unicode-和-UTF-8-之间的关系？"><a href="#Unicode-和-UTF-8-之间的关系？" class="headerlink" title="Unicode 和 UTF-8 之间的关系？"></a>Unicode 和 UTF-8 之间的关系？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Unicode 是一种字符集合，现在可容纳 100 多万个字符。每个字符对应一个不同的 Unicode 编码，它只规定了符号的二进制代码，却没有规定这个二进制代码在计算机中如何编码传输。</span><br><span class="line"></span><br><span class="line">UTF-8 是一种对 Unicode 的编码方式，它是一种变长的编码方式，可以用 1~4 个字节来表示一个字符。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a target="_blank" rel="noopener" href="https://blog.51cto.com/polaris/377468">《字符编码详解》</a><br><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html">《字符编码笔记：ASCII，Unicode 和 UTF-8》</a></p><h2 id="js-的事件循环是什么？"><a href="#js-的事件循环是什么？" class="headerlink" title="js 的事件循环是什么？"></a>js 的事件循环是什么？</h2><p>相关知识点：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">事件队列是一个存储着待执行任务的队列，其中的任务严格按照时间先后顺序执行，排在队头的任务将会率先执行，而排在队尾的任务会最后执行。事件队列每次仅执行一个任务，在该任务执行完毕之后，再执行下一个任务。执行栈则是一个类似于函数调用栈的运行容器，当执行栈为空时，JS 引擎便检查事件队列，如果不为空的话，事件队列便将第一个任务压入执行栈中运行。</span><br></pre></td></tr></table></figure><p>回答：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">因为 js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当异步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。</span><br><span class="line"></span><br><span class="line">微任务包括了 promise 的回调、node 中的 process.nextTick 、对 Dom 变化监听的 MutationObserver。</span><br><span class="line"></span><br><span class="line">宏任务包括了 script 脚本的执行、setTimeout ，setInterval ，setImmediate 一类的定时事件，还有如 I/O 操作、UI 渲</span><br><span class="line">染等。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a target="_blank" rel="noopener" href="https://juejin.im/post/5afbc62151882542af04112d">《浏览器事件循环机制（event loop）》</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/33058983">《详解 JavaScript 中的 Event Loop（事件循环）机制》</a><br><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2013/10/event_loop.html">《什么是 Event Loop？》</a><br><a target="_blank" rel="noopener" href="https://juejin.im/post/59e85eebf265da430d571f89">《这一次，彻底弄懂 JavaScript 执行机制》</a></p><h2 id="js-中的深浅拷贝实现？"><a href="#js-中的深浅拷贝实现？" class="headerlink" title="js 中的深浅拷贝实现？"></a>js 中的深浅拷贝实现？</h2><p>相关资料：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 浅拷贝的实现;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowCopy</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 只拷贝对象</span></span><br><span class="line">  <span class="keyword">if</span> (!object || <span class="keyword">typeof</span> object !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据 object 的类型判断是新建一个数组还是对象</span></span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="built_in">Array</span>.isArray(object) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历 object，并且判断是 object 的属性才拷贝</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">    <span class="keyword">if</span> (object.hasOwnProperty(key)) &#123;</span><br><span class="line">      newObject[key] = object[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 深拷贝的实现;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!object || <span class="keyword">typeof</span> object !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span> object;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="built_in">Array</span>.isArray(object) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">    <span class="keyword">if</span> (object.hasOwnProperty(key)) &#123;</span><br><span class="line">      newObject[key] = deepCopy(object[key]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回答：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">浅拷贝指的是将一个对象的属性值复制到另一个对象，如果有的属性的值为引用类型的话，那么会将这个引用的地址复制给对象，因此两个对象会有同一个引用类型的引用。浅拷贝可以使用  Object.assign 和展开运算符来实现。</span><br><span class="line"></span><br><span class="line">深拷贝相对浅拷贝而言，如果遇到属性值为引用类型的时候，它新建一个引用类型并将对应的值复制给它，因此对象获得的一个新的引用类型而不是一个原有类型的引用。深拷贝对于一些对象可以使用 JSON 的两个函数来实现，但是由于 JSON 的对象格式比 js 的对象格式更加严格，所以如果属性值里边出现函数或者 Symbol 类型的值时，会转换失败。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog/issues/32">《JavaScript 专题之深浅拷贝》</a><br><a target="_blank" rel="noopener" href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bed40d951882545f73004f6">《前端面试之道》</a></p><h2 id="手写-call、apply-及-bind-函数"><a href="#手写-call、apply-及-bind-函数" class="headerlink" title="手写 call、apply 及 bind 函数"></a>手写 call、apply 及 bind 函数</h2><p>相关资料：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// call函数实现</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断调用对象</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">&quot;type error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取参数</span></span><br><span class="line">  <span class="keyword">let</span> args = [...arguments].slice(<span class="number">1</span>),</span><br><span class="line">    result = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断 context 是否传入，如果未传入则设置为 window</span></span><br><span class="line">  context = context || <span class="built_in">window</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将调用函数设为对象的方法</span></span><br><span class="line">  context.fn = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用函数</span></span><br><span class="line">  result = context.fn(...args);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将属性删除</span></span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// apply 函数实现</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断调用对象是否为函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断 context 是否存在，如果未传入则为 window</span></span><br><span class="line">  context = context || <span class="built_in">window</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将函数设为对象的方法</span></span><br><span class="line">  context.fn = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">    result = context.fn(...arguments[<span class="number">1</span>]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = context.fn();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将属性删除</span></span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bind 函数实现</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断调用对象是否为函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取参数</span></span><br><span class="line">  <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>),</span><br><span class="line">    fn = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 根据调用方式，传入不同绑定值</span></span><br><span class="line">    <span class="keyword">return</span> fn.apply(</span><br><span class="line">      <span class="built_in">this</span> <span class="keyword">instanceof</span> Fn ? <span class="built_in">this</span> : context,</span><br><span class="line">      args.concat(...arguments)</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>回答：</p><p>call 函数的实现步骤：</p><ul><li>1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>2.判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li><li>3.处理传入的参数，截取第一个参数后的所有参数。</li><li>4.将函数作为上下文对象的一个属性。</li><li>5.使用上下文对象来调用这个方法，并保存返回结果。</li><li>6.删除刚才新增的属性。</li><li>7.返回结果。</li></ul><p>apply 函数的实现步骤：</p><ul><li>1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>2.判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li><li>3.将函数作为上下文对象的一个属性。</li><li>4.判断参数值是否传入</li><li>4.使用上下文对象来调用这个方法，并保存返回结果。</li><li>5.删除刚才新增的属性</li><li>6.返回结果</li></ul><p>bind 函数的实现步骤：</p><ul><li>1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>2.保存当前函数的引用，获取其余传入参数值。</li><li>3.创建一个函数返回</li><li>4.函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。</li></ul><p>详细资料可以参考：<br><a target="_blank" rel="noopener" href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdd0d8e6fb9a04a044073fe">《手写 call、apply 及 bind 函数》</a><br><a target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog/issues/11">《JavaScript 深入之 call 和 apply 的模拟实现》</a></p><h2 id="函数柯里化的实现"><a href="#函数柯里化的实现" class="headerlink" title="函数柯里化的实现"></a>函数柯里化的实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn, args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取函数需要的参数长度</span></span><br><span class="line">  <span class="keyword">let</span> length = fn.length;</span><br><span class="line"></span><br><span class="line">  args = args || [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> subArgs = args.slice(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接得到现有的所有参数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">      subArgs.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断参数的长度是否已经满足函数所需参数的长度</span></span><br><span class="line">    <span class="keyword">if</span> (subArgs.length &gt;= length) &#123;</span><br><span class="line">      <span class="comment">// 如果满足，执行函数</span></span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="built_in">this</span>, subArgs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果不满足，递归返回科里化的函数，等待参数的传入</span></span><br><span class="line">      <span class="keyword">return</span> curry.call(<span class="built_in">this</span>, fn, subArgs);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6 实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fn.length &lt;= args.length ? fn(...args) : curry.bind(<span class="literal">null</span>, fn, ...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog/issues/42">《JavaScript 专题之函数柯里化》</a></p><h2 id="为什么-0-1-0-2-0-3？如何解决这个问题？"><a href="#为什么-0-1-0-2-0-3？如何解决这个问题？" class="headerlink" title="为什么 0.1 + 0.2 != 0.3？如何解决这个问题？"></a>为什么 0.1 + 0.2 != 0.3？如何解决这个问题？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当计算机计算 0.1+0.2 的时候，实际上计算的是这两个数字在计算机里所存储的二进制，0.1 和 0.2 在转换为二进制表示的时候会出现位数无限循环的情况。js 中是以 64 位双精度格式来存储数字的，只有 53 位的有效数字，超过这个长度的位数会被截取掉这样就造成了精度丢失的问题。这是第一个会造成精度丢失的地方。在对两个以 64 位双精度格式的数据进行计算的时候，首先会进行对阶的处理，对阶指的是将阶码对齐，也就是将小数点的位置对齐后，再进行计算，一般是小阶向大阶对齐，因此小阶的数在对齐的过程中，有效数字会向右移动，移动后超过有效位数的位会被截取掉，这是第二个可能会出现精度丢失的地方。当两个数据阶码对齐后，进行相加运算后，得到的结果可能会超过 53 位有效数字，因此超过的位数也会被截取掉，这是可能发生精度丢失的第三个地方。</span><br><span class="line"></span><br><span class="line">对于这样的情况，我们可以将其转换为整数后再进行运算，运算后再转换为对应的小数，以这种方式来解决这个问题。</span><br><span class="line"></span><br><span class="line">我们还可以将两个数相加的结果和右边相减，如果相减的结果小于一个极小数，那么我们就可以认定结果是相等的，这个极小数可以</span><br><span class="line">使用 es6 的 Number.EPSILON</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/Lixuanshengchao/article/details/82049191">《十进制的 0.1 为什么不能用二进制很好的表示？》</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhengyanan815/article/details/78550073">《十进制浮点数转成二进制》</a><br><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html">《浮点数的二进制表示》</a><br><a target="_blank" rel="noopener" href="https://juejin.im/post/5b372f106fb9a00e6714aa21">《js 浮点数存储精度丢失原理》</a><br><a target="_blank" rel="noopener" href="https://juejin.im/post/594a31d0a0bb9f006b0b2624">《浮点数精度之谜》</a><br><a target="_blank" rel="noopener" href="https://github.com/camsong/blog/issues/9">《JavaScript 浮点数陷阱及解法》</a><br><a target="_blank" rel="noopener" href="https://juejin.im/post/5bd2f10a51882555e072d0c4">《0.1+0.2 !== 0.3？》</a><br><a target="_blank" rel="noopener" href="https://juejin.im/entry/59cdd7fb6fb9a00a600f8eef">《JavaScript 中奇特的~运算符》</a></p><h2 id="原码、反码和补码的介绍"><a href="#原码、反码和补码的介绍" class="headerlink" title="原码、反码和补码的介绍"></a>原码、反码和补码的介绍</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原码是计算机中对数字的二进制的定点表示方法，最高位表示符号位，其余位表示数值位。优点是易于分辨，缺点是不能够直接参与运算。</span><br><span class="line"></span><br><span class="line">正数的反码和其原码一样；负数的反码，符号位为1，数值部分按原码取反。</span><br><span class="line">如 [+7]原 = 00000111，[+7]反 = 00000111； [-7]原 = 10000111，[-7]反 = 11111000。</span><br><span class="line"></span><br><span class="line">正数的补码和其原码一样；负数的补码为其反码加1。</span><br><span class="line"></span><br><span class="line">例如 [+7]原 = 00000111，[+7]反 = 00000111，[+7]补 = 00000111；</span><br><span class="line">[-7]原 = 10000111，[-7]反 = 11111000，[-7]补 = 11111001</span><br><span class="line"></span><br><span class="line">之所以在计算机中使用补码来表示负数的原因是，这样可以将加法运算扩展到所有的数值计算上，因此在数字电路中我们只需要考虑加法器的设计就行了，而不用再为减法设置新的数字电路。</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2009/08/twos_complement.html">《关于 2 的补码》</a></p></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Javascript/">Javascript</a></div><div class="post_share"><div class="social-share" data-image="/img/cover/cover_4.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/file/donate.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/file/donate.png" alt="wechat"></a><div class="post-qr-code-desc">wechat</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/32208/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover_9.jpg" onerror='onerror=null,src="/img/404.png"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JS面试知识点总结(十一)</div></div></a></div><div class="next-post pull-right"><a href="/5788/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover_4.jpg" onerror='onerror=null,src="/img/404.png"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JS面试知识点总结(九)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/53408/" title="JS面试知识点总结 (一)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover_4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-17</div><div class="title">JS面试知识点总结 (一)</div></div></a></div><div><a href="/31888/" title="JS面试知识点总结(十二)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover_3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-17</div><div class="title">JS面试知识点总结(十二)</div></div></a></div><div><a href="/32208/" title="JS面试知识点总结(十一)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover_9.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-17</div><div class="title">JS面试知识点总结(十一)</div></div></a></div><div><a href="/32272/" title="JS面试知识点总结(十四)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover_2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-17</div><div class="title">JS面试知识点总结(十四)</div></div></a></div><div><a href="/48209/" title="JS面试知识点总结(十三)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover_4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-17</div><div class="title">JS面试知识点总结(十三)</div></div></a></div><div><a href="/48849/" title="JS面试知识点总结(十五)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover_8.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-17</div><div class="title">JS面试知识点总结(十五)</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">总结整理前端知识点 \(￣︶￣*\))<br>持续更新中...<br>ヾ(•ω•`)o</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-js-%E7%9A%84%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">介绍一下 js 的节流与防抖？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-is-%E4%B8%8E%E5%8E%9F%E6%9D%A5%E7%9A%84%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C%E7%AC%A6-%E2%80%9C-%E2%80%9D%E3%80%81%E2%80%9C-%E2%80%9D-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">Object.is() 与原来的比较操作符 “&#x3D;&#x3D;&#x3D;”、“&#x3D;&#x3D;” 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#escape-encodeURI-encodeURIComponent-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">escape,encodeURI,encodeURIComponent 有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unicode-%E5%92%8C-UTF-8-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">Unicode 和 UTF-8 之间的关系？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js-%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">js 的事件循环是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js-%E4%B8%AD%E7%9A%84%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">6.</span> <span class="toc-text">js 中的深浅拷贝实现？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99-call%E3%80%81apply-%E5%8F%8A-bind-%E5%87%BD%E6%95%B0"><span class="toc-number">7.</span> <span class="toc-text">手写 call、apply 及 bind 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.</span> <span class="toc-text">函数柯里化的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-0-1-0-2-0-3%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">9.</span> <span class="toc-text">为什么 0.1 + 0.2 !&#x3D; 0.3？如何解决这个问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E5%92%8C%E8%A1%A5%E7%A0%81%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">10.</span> <span class="toc-text">原码、反码和补码的介绍</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/46710/" title="前端书籍推荐"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover_7.jpg" onerror='this.onerror=null,this.src="/img/404.png"' alt="前端书籍推荐"></a><div class="content"><a class="title" href="/46710/" title="前端书籍推荐">前端书籍推荐</a><time datetime="2022-01-24T03:42:58.000Z" title="发表于 2022-01-24 11:42:58">2022-01-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/48387/" title="手写-new 操作符"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover_10.jpg" onerror='this.onerror=null,this.src="/img/404.png"' alt="手写-new 操作符"></a><div class="content"><a class="title" href="/48387/" title="手写-new 操作符">手写-new 操作符</a><time datetime="2022-01-20T05:53:44.000Z" title="发表于 2022-01-20 13:53:44">2022-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/61177/" title="实现一个手写bind？"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover_5.png" onerror='this.onerror=null,this.src="/img/404.png"' alt="实现一个手写bind？"></a><div class="content"><a class="title" href="/61177/" title="实现一个手写bind？">实现一个手写bind？</a><time datetime="2022-01-20T05:25:41.000Z" title="发表于 2022-01-20 13:25:41">2022-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/14068/" title="计算机网络常见面试题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover_8.jpg" onerror='this.onerror=null,this.src="/img/404.png"' alt="计算机网络常见面试题"></a><div class="content"><a class="title" href="/14068/" title="计算机网络常见面试题">计算机网络常见面试题</a><time datetime="2022-01-19T05:48:07.000Z" title="发表于 2022-01-19 13:48:07">2022-01-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/29428/" title="计算机网络知识点"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover_5.png" onerror='this.onerror=null,this.src="/img/404.png"' alt="计算机网络知识点"></a><div class="content"><a class="title" href="/29428/" title="计算机网络知识点">计算机网络知识点</a><time datetime="2022-01-19T05:44:44.000Z" title="发表于 2022-01-19 13:44:44">2022-01-19</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By souldjl</div><div class="footer_custom_text">没有行动的梦想，都是妄想～</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function addGitalkSource(){const t=document.createElement("link");t.rel="stylesheet",t.href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css",document.getElementsByTagName("head")[0].appendChild(t)}function loadGitalk(){function t(){new Gitalk(Object.assign({clientID:"28388bc5382cb36e8b6a",clientSecret:"0976a3fb2d62d4e2b86385d26451a23ead66f6eb",repo:"souldjl.github.io",owner:"souldjl",admin:["souldjl"],id:"ef0eb4f2978f4ae2d92497b26058f819",updateCountCallback:commentCount},null)).render("gitalk-container")}"function"==typeof Gitalk?t():(addGitalkSource(),getScript("https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js").then(t))}function commentCount(t){let e=document.querySelector("#post-meta .gitalk-comment-count");e&&(e.innerHTML=t)}function loadOtherComment(){loadGitalk()}loadGitalk()</script></div><script src="https://cdn.bootcdn.net/ajax/libs/Swiper/7.4.1/swiper-bundle.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",function(){if(window.removeEventListener("scroll",window.tocScrollFn),window.removeEventListener("scroll",scrollCollect),"object"==typeof preloader&&preloader.initLoading(),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")}),document.addEventListener("pjax:complete",function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script");var o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()}),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>